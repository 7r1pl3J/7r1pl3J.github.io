<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="7r1p13J">





<title>Buddy System源码阅读 | Hexo</title>



    <link rel="icon" href="/github-11-48.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">7r1pl3J&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">7r1pl3J&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Buddy System源码阅读</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">7r1p13J</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">November 19, 2022&nbsp;&nbsp;10:28:05</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/kernel/">kernel</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="CS144"><a href="#CS144" class="headerlink" title="CS144"></a>CS144</h1><p><del>计网一直只是看了点书（学校大三才给选），感觉看了也很容易忘，这个lab做完只能说tcp应该是理解且记住了(</del></p>
<p>环境为本地VMware workstation+ubuntu 20.04 </p>
<p>依赖可以参考官网<a target="_blank" rel="noopener" href="https://stanford.edu/class/cs144/vm_howto/">https://stanford.edu/class/cs144/vm_howto/</a> </p>
<blockquote>
<p>You’re welcome to use any Linux installation, in a VM or not, provided that it has a reasonably recent kernel (4.x should be fine) and a C++17 compiler.</p>
<p><strong>Please note</strong> that the CAs will not be available to help you debug a BYO Linux installation. If you’re in doubt, please consider using the <a target="_blank" rel="noopener" href="https://stanford.edu/class/cs144/vm_howto/vm-howto-image.html">prepared image</a> or following our <a target="_blank" rel="noopener" href="https://stanford.edu/class/cs144/vm_howto/vm-howto-iso.html">VM setup instructions</a>.</p>
<h3 id="Packages-you’ll-need"><a href="#Packages-you’ll-need" class="headerlink" title="Packages you’ll need"></a>Packages you’ll need</h3><p>To run the labs, you’ll need the following software:</p>
<ul>
<li>g++ version 8.x</li>
<li>clang-tidy version 6 or 7</li>
<li>clang-format version 6 or 7</li>
<li>cmake version 3 or later</li>
<li>libpcap development headers (libpcap-dev on Debian-like distributions)</li>
<li>git</li>
<li>iptables</li>
<li>mininet 2.2.0 or later</li>
<li>tcpdump</li>
<li>telnet</li>
<li>wireshark</li>
<li>socat</li>
<li>netcat-openbsd</li>
<li>GNU coreutils</li>
<li>bash</li>
<li>doxygen</li>
<li>graphviz</li>
</ul>
<p><strong>Note:</strong> there are at least three versions of netcat. You won’t be using it much, but when you do, we will assume you’ve got the OpenBSD variant. Others might also work, though it is possible that they will require different commandline flags.</p>
<p>We’ve tested the labs with recent Debian-derived systems (Ubuntu 18.04 and similar) and Arch Linux. In all likelihood, other modern Linux distributions will also work.</p>
</blockquote>
<p>资料主要参考课程文档</p>
<h2 id="lab0"><a href="#lab0" class="headerlink" title="lab0"></a>lab0</h2><h4 id="获取网页："><a href="#获取网页：" class="headerlink" title="获取网页："></a>获取网页：</h4><p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221228224208183.png" alt="image-20221228224208183"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">telnet cs144.keithw.org http <span class="comment">//telnet 用于在本地计算机与远程计算机之间打开一个可靠的字节流，并在该计算机上运行特定的服务：http服务</span></span><br><span class="line">GET /hello HTTP/<span class="number">1.1</span> <span class="comment">//告诉服务器URL的路径</span></span><br><span class="line">Host: cs144.keithw.org <span class="comment">//告诉服务器主机</span></span><br><span class="line">Connection: close <span class="comment">//告诉服务请完成请求，在完成回复后立刻关闭</span></span><br><span class="line"><span class="comment">//这里的话必须再按一次回车，用于告诉服务器你已经完成了http请求，否则将会收到 408 Request Timeout</span></span><br></pre></td></tr></table></figure>



<h4 id="netcat-telnet-实现简单客户端服务端"><a href="#netcat-telnet-实现简单客户端服务端" class="headerlink" title="netcat+telnet 实现简单客户端服务端"></a>netcat+telnet 实现简单客户端服务端</h4><p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221228225514738.png" alt="image-20221228225514738"></p>
<h4 id="实现webget"><a href="#实现webget" class="headerlink" title="实现webget"></a>实现webget</h4><p>参考<a target="_blank" rel="noopener" href="https://cs144.github.io/doc/lab0/class_t_c_p_socket.html">https://cs144.github.io/doc/lab0/class_t_c_p_socket.html</a> 文档</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;socket.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;socket.hh&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_URL</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;host, <span class="type">const</span> <span class="built_in">string</span> &amp;path)</span> &#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// You will need to connect to the &quot;http&quot; service on</span></span><br><span class="line">    <span class="comment">// the computer whose name is in the &quot;host&quot; string,</span></span><br><span class="line">    <span class="comment">// then request the URL path given in the &quot;path&quot; string.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then you&#x27;ll need to print out everything the server sends back,</span></span><br><span class="line">    <span class="comment">// (not just one call to read() -- everything) until you reach</span></span><br><span class="line">    <span class="comment">// the &quot;eof&quot; (end of file).</span></span><br><span class="line"></span><br><span class="line">    TCPSocket sock;</span><br><span class="line">    sock.connect(Address(host,<span class="string">&quot;http&quot;</span>));</span><br><span class="line">    sock.write(<span class="string">&quot;GET &quot;</span>+path+<span class="string">&quot; HTTP/1.1\r\nHost: &quot;</span>+host+<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    sock.write(<span class="string">&quot;Connection: close\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!sock.eof())&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sock.read();</span><br><span class="line">    &#125;</span><br><span class="line">    sock.close();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="keyword">if</span> (argc &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">abort</span>();  <span class="comment">// For sticklers: don&#x27;t try to access argv[0] if argc &lt;= 0.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The program takes two command-line arguments: the hostname and &quot;path&quot; part of the URL.</span></span><br><span class="line">        <span class="comment">// Print the usage message unless there are these two arguments (plus the program name</span></span><br><span class="line">        <span class="comment">// itself, so arg count = 3 in total).</span></span><br><span class="line">        <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; HOST PATH\n&quot;</span>;</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;\tExample: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; stanford.edu /class/cs144\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the command-line arguments.</span></span><br><span class="line">        <span class="type">const</span> <span class="built_in">string</span> host = argv[<span class="number">1</span>];</span><br><span class="line">        <span class="type">const</span> <span class="built_in">string</span> path = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call the student-written function.</span></span><br><span class="line">        get_URL(host, path);</span><br><span class="line">    &#125; catch (<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230104152159878.png" alt="image-20230104152159878"></p>
<h4 id="lab0-1"><a href="#lab0-1" class="headerlink" title="lab0"></a>lab0</h4><p>实现抽象字节流对象：</p>
<ul>
<li>有输出输入端</li>
<li>写者可以结束输入</li>
<li>…</li>
</ul>
<p>要实现一段输入另一端输出，可以考虑用循环队列deque实现。</p>
<p>坑点：只有读写都完成了，也就是input_ended同时buffer也为空时 才判定为eof</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230104165012511.png" alt="image-20230104165012511"></p>
<p>byte_stream.hh</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SPONGE_LIBSPONGE_BYTE_STREAM_HH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPONGE_LIBSPONGE_BYTE_STREAM_HH</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//! \brief An in-order byte stream.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! Bytes are written on the &quot;input&quot; side and read from the &quot;output&quot;</span></span><br><span class="line"><span class="comment">//! side.  The byte stream is finite: the writer can end the input,</span></span><br><span class="line"><span class="comment">//! and then no more bytes can be written.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint: This doesn&#x27;t need to be a sophisticated data structure at</span></span><br><span class="line">    <span class="comment">// all, but if any of your tests are taking longer than a second,</span></span><br><span class="line">    <span class="comment">// that&#x27;s a sign that you probably want to keep exploring</span></span><br><span class="line">    <span class="comment">// different approaches.</span></span><br><span class="line">    std::deque&lt;<span class="type">char</span>&gt; _stream_buffer;</span><br><span class="line">    <span class="type">size_t</span> _capacity ;</span><br><span class="line">    <span class="type">size_t</span> _read_cnt ;</span><br><span class="line">    <span class="type">size_t</span> _write_cnt ;</span><br><span class="line">    <span class="type">bool</span> _end_of_input ;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> _error;  <span class="comment">//!&lt; Flag indicating that the stream suffered an error.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! Construct a stream with room for `capacity` bytes.</span></span><br><span class="line">    <span class="built_in">ByteStream</span>(<span class="type">const</span> <span class="type">size_t</span> capacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name &quot;Input&quot; interface for the writer</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Write a string of bytes into the stream. Write as many</span></span><br><span class="line">    <span class="comment">//! as will fit, and return how many were written.</span></span><br><span class="line">    <span class="comment">//! \returns the number of bytes accepted into the stream</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string &amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns the number of additional bytes that the stream has space for</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">remaining_capacity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Signal that the byte stream has reached its ending</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">end_input</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Indicate that the stream suffered an error.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_error</span><span class="params">()</span> </span>&#123; _error = <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name &quot;Output&quot; interface for the reader</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Peek at next &quot;len&quot; bytes of the stream</span></span><br><span class="line">    <span class="comment">//! \returns a string</span></span><br><span class="line">    <span class="function">std::string <span class="title">peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Remove bytes from the buffer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span></span><br><span class="line">    <span class="comment">//! \returns a string</span></span><br><span class="line">    <span class="function">std::string <span class="title">read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns `true` if the stream input has ended</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">input_ended</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns `true` if the stream has suffered an error</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">error</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _error; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns the maximum amount that can currently be read from the stream</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns `true` if the buffer is empty</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">buffer_empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns `true` if the output has reached the ending</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eof</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name General accounting</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Total number of bytes written</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">bytes_written</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Total number of bytes popped</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">bytes_read</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// SPONGE_LIBSPONGE_BYTE_STREAM_HH</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>byte_stream.cc</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;byte_stream.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy implementation of a flow-controlled in-memory byte stream.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For Lab 0, please replace with a real implementation that passes the</span></span><br><span class="line"><span class="comment">// automated checks run by `make check_lab0`.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You will need to add private members to the class declaration in `byte_stream.hh`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// template &lt;typename... Targs&gt;</span></span><br><span class="line"><span class="comment">// void DUMMY_CODE(Targs &amp;&amp;... /* unused */) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="type">const</span> <span class="type">size_t</span> capacity) :_stream_buffer(),_capacity(capacity),_read_cnt(<span class="number">0</span>),_write_cnt(<span class="number">0</span>),_end_of_input(<span class="literal">false</span>),_error(<span class="literal">false</span>)</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*    if (_end_of_input)</span></span><br><span class="line"><span class="comment">        return 0;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">min</span>(data.<span class="built_in">length</span>(), _capacity - _stream_buffer.<span class="built_in">size</span>());</span><br><span class="line">    _write_cnt += len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        _stream_buffer.<span class="built_in">push_back</span>(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> peek_size = <span class="built_in">min</span>(len, _stream_buffer.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(_stream_buffer.<span class="built_in">begin</span>(), _stream_buffer.<span class="built_in">begin</span>() + peek_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> pop_size = <span class="built_in">min</span>(len, _stream_buffer.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pop_size; i++)</span><br><span class="line">        _stream_buffer.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">    _read_cnt += pop_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be popped and returned</span></span><br><span class="line"><span class="comment">//! \returns a string</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    string data = <span class="keyword">this</span>-&gt;<span class="built_in">peek_output</span>(len);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">pop_output</span>(len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123; _end_of_input = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _end_of_input; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _stream_buffer.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _stream_buffer.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">input_ended</span>()&amp;&amp;<span class="built_in">buffer_empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _write_cnt; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _read_cnt; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> &#123;_capacity - _stream_buffer.<span class="built_in">size</span>()&#125;; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><p>运行git 以获取lab1的初始代码以及测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/lab1-starterco</span><br></pre></td></tr></table></figure>

<p>在build目录下执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure>



<h3 id="子串拼接"><a href="#子串拼接" class="headerlink" title="子串拼接"></a>子串拼接</h3><p>本实验会对后续实验的速度造成影响，所以得写好些。</p>
<p>TCP ⾃⾝可以使⽤不可靠的数据报提供⼀对可靠的字节流，以此为基础，我们将完成数据报到字节流的拼接。</p>
<p>实验给出的数据报 以函数参数的形式给出，分别包含index，以及data，这其实是为后面TCP接受实际数据包的载体做准备</p>
<p>完成本实验的难点主要在于理解题目。。</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230104234752817.png" alt="image-20230104234752817"></p>
<ul>
<li>我们会不断接受到 无序的，可能带有重复字节的数据报</li>
<li>如果收到的字节流刚好覆盖了我们写的起始点，我们就执行写入</li>
<li>对收到的字节流进行去重 合并操作</li>
</ul>
<p>思路：</p>
<p>需要一个_next_assembled_index 来记录我们下一次要写入字节流的位置</p>
<p>_capacity为总的容量，那么_capacity+next_assembled_index 就是我们当前需要接受的一个范围。</p>
<p>这里分成三种情况即可：</p>
<ol>
<li>要写入的index + data.len &lt; &#x3D;next_assembled_index ，说明已经写过了，略过即可。</li>
<li>要写入的 index + data.len &gt; next_assembled_index （过了1的话这里已经成立了）同时（index &lt; _next_assembled_index），也就是说有一部分数据是在我们要写入的位置之后，是有效的， 我们就直接对该数据报去重，方便后面统一的操作。</li>
<li>index &gt; _next_assembled_index ，完全没写过的情况，正常处理即可。</li>
</ol>
<p>然后再对数据报进行去重，这里我选择用set对数据报进行临时存储（查询快），每次都去找相零的数据报，如果有重复的部分就去重，注意，这是一个类似迭代的操作，因为去重完了合成的新数据报可能可以继续去重。</p>
<p>去重分为两种，一种是后面重合了，一种是前面重合了。</p>
<p>最后就是执行写入和判断eof的操作。</p>
<p>仅有当数据完全写入，也就是empty，同时已经接受到有eof的数据报后，才能算作处理结束了。</p>
<p>测试结果：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230104234319667.png" alt="image-20230104234319667"></p>
<p>stream_reassembler.hh</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SPONGE_LIBSPONGE_STREAM_REASSEMBLER_HH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPONGE_LIBSPONGE_STREAM_REASSEMBLER_HH</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;byte_stream.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! \brief A class that assembles a series of excerpts from a byte stream (possibly out of order,</span></span><br><span class="line"><span class="comment">//! possibly overlapping) into an in-order byte stream.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">broken_bytestream</span> &#123;</span><br><span class="line">    std::string _data;</span><br><span class="line">    <span class="type">size_t</span> _begin_index;</span><br><span class="line">    <span class="type">size_t</span> _len;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> broken_bytestream t) <span class="type">const</span> &#123; <span class="keyword">return</span> _begin_index &lt; t._begin_index; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> broken_bytestream t) <span class="type">const</span> &#123; <span class="keyword">return</span> _begin_index &gt; t._begin_index; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> broken_bytestream t) <span class="type">const</span> &#123; <span class="keyword">return</span> _begin_index == t._begin_index; &#125;</span><br><span class="line">    <span class="built_in">broken_bytestream</span>(std::string data, <span class="type">size_t</span> index) : _data(data), _begin_index(index), _len(data.<span class="built_in">length</span>()) &#123;&#125;</span><br><span class="line">    <span class="built_in">broken_bytestream</span>() : _data(), _begin_index(<span class="number">0</span>), _len(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamReassembler</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line"></span><br><span class="line">    ByteStream _output;    <span class="comment">//!&lt; The reassembled in-order byte stream</span></span><br><span class="line">    <span class="type">size_t</span> _capacity = <span class="number">0</span>;  <span class="comment">//!&lt; The maximum number of bytes</span></span><br><span class="line"></span><br><span class="line">    std::set&lt;broken_bytestream&gt; _fragments&#123;&#125;;</span><br><span class="line">    <span class="type">size_t</span> _next_assembled_index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> _unassembled_bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> _eof_flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span>  <span class="title">merge_fragments</span><span class="params">(broken_bytestream &amp;t1, <span class="type">const</span> broken_bytestream &amp;t2)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">judge_eof</span><span class="params">(<span class="type">const</span> <span class="type">bool</span> _eof)</span></span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! \brief Construct a `StreamReassembler` that will store up to `capacity` bytes.</span></span><br><span class="line">    <span class="comment">//! \note This capacity limits both the bytes that have been reassembled,</span></span><br><span class="line">    <span class="comment">//! and those that have not yet been reassembled.</span></span><br><span class="line">    <span class="built_in">StreamReassembler</span>(<span class="type">const</span> <span class="type">size_t</span> capacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Receive a substring and write any newly contiguous bytes into the stream.</span></span><br><span class="line">    <span class="comment">//!</span></span><br><span class="line">    <span class="comment">//! The StreamReassembler will stay within the memory limits of the `capacity`.</span></span><br><span class="line">    <span class="comment">//! Bytes that would exceed the capacity are silently discarded.</span></span><br><span class="line">    <span class="comment">//!</span></span><br><span class="line">    <span class="comment">//! \param data the substring</span></span><br><span class="line">    <span class="comment">//! \param index indicates the index (place in sequence) of the first byte in `data`</span></span><br><span class="line">    <span class="comment">//! \param eof the last byte of `data` will be the last byte in the entire stream</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_substring</span><span class="params">(<span class="type">const</span> std::string &amp;data, <span class="type">const</span> <span class="type">uint64_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name Access the reassembled byte stream</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line">    <span class="function"><span class="type">const</span> ByteStream &amp;<span class="title">stream_out</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _output; &#125;</span><br><span class="line">    <span class="function">ByteStream &amp;<span class="title">stream_out</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _output; &#125;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! The number of bytes in the substrings stored but not yet reassembled</span></span><br><span class="line">    <span class="comment">//!</span></span><br><span class="line">    <span class="comment">//! \note If the byte at a particular index has been pushed more than once, it</span></span><br><span class="line">    <span class="comment">//! should only be counted once for the purpose of this function.</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">unassembled_bytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Is the internal state empty (other than the output stream)?</span></span><br><span class="line">    <span class="comment">//! \returns `true` if no substrings are waiting to be assembled</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// SPONGE_LIBSPONGE_STREAM_REASSEMBLER_HH</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>stream_reassembler.cc</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stream_reassembler.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// Dummy implementation of a stream reassembler.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For Lab 1, please replace with a real implementation that passes the</span></span><br><span class="line"><span class="comment">// automated checks run by `make check_lab1`.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You will need to add private members to the class declaration in `stream_reassembler.hh`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// template &lt;typename... Targs&gt;</span></span><br><span class="line"><span class="comment">// void DUMMY_CODE(Targs &amp;&amp;... /* unused */) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">StreamReassembler::<span class="built_in">StreamReassembler</span>(<span class="type">const</span> <span class="type">size_t</span> capacity)</span><br><span class="line">    : _output(capacity)</span><br><span class="line">    , _capacity(capacity)</span><br><span class="line">    , _fragments()</span><br><span class="line">    , _next_assembled_index(<span class="number">0</span>)</span><br><span class="line">    , _unassembled_bytes(<span class="number">0</span>)</span><br><span class="line">    , _eof_flag(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \details This function accepts a substring (aka a segment) of bytes,</span></span><br><span class="line"><span class="comment">//! possibly out-of-order, from the logical stream, and assembles any newly</span></span><br><span class="line"><span class="comment">//! contiguous substrings and writes them into the output stream in order.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::judge_eof</span><span class="params">(<span class="type">const</span> <span class="type">bool</span> _eof)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_eof) &#123;</span><br><span class="line">        _eof_flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_eof_flag &amp;&amp; <span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _output.<span class="built_in">end_input</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里要是 &gt;= ，因为lab4会给到刚好等于的样例。。。 虽然&gt; 也能过lab1，但是会过不了lab4</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= _next_assembled_index + _capacity)</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// overflow</span></span><br><span class="line"></span><br><span class="line">    broken_bytestream current_stream;</span><br><span class="line">    <span class="keyword">if</span> (index + data.<span class="built_in">length</span>() &lt;= _next_assembled_index) &#123;</span><br><span class="line">        <span class="built_in">judge_eof</span>(eof);</span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; _next_assembled_index) &#123;</span><br><span class="line">        <span class="comment">// cut prev  </span></span><br><span class="line">        <span class="type">size_t</span> offset = _next_assembled_index-index ;</span><br><span class="line">        current_stream._begin_index = _next_assembled_index;</span><br><span class="line">        current_stream._data.<span class="built_in">assign</span>(data.<span class="built_in">begin</span>() + offset, data.<span class="built_in">end</span>());</span><br><span class="line">        current_stream._len = current_stream._data.<span class="built_in">length</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// index &gt; _next_assembled_index </span></span><br><span class="line">        current_stream._begin_index = index;</span><br><span class="line">        current_stream._data = data;</span><br><span class="line">        current_stream._len = data.<span class="built_in">length</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _unassembled_bytes += current_stream._len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do merge</span></span><br><span class="line">     <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">// find next fragments</span></span><br><span class="line">    <span class="type">ssize_t</span> merged_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> near_iter = _fragments.<span class="built_in">lower_bound</span>(current_stream);</span><br><span class="line">    <span class="comment">// merge next</span></span><br><span class="line">    <span class="keyword">while</span> (near_iter != _fragments.<span class="built_in">end</span>() &amp;&amp; (merged_size = <span class="built_in">merge_fragments</span>(current_stream, *near_iter)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        _unassembled_bytes -= merged_size;</span><br><span class="line">        _fragments.<span class="built_in">erase</span>(near_iter);  <span class="comment">// merged next overed, delete the next;</span></span><br><span class="line">        near_iter = _fragments.<span class="built_in">lower_bound</span>(current_stream);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// merge prev</span></span><br><span class="line">    <span class="keyword">if</span> (near_iter == _fragments.<span class="built_in">begin</span>()) </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    near_iter--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((merged_size = <span class="built_in">merge_fragments</span>(current_stream, *near_iter)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        _unassembled_bytes -= merged_size;</span><br><span class="line">        _fragments.<span class="built_in">erase</span>(near_iter);</span><br><span class="line">        near_iter = _fragments.<span class="built_in">lower_bound</span>(current_stream);</span><br><span class="line">        <span class="keyword">if</span> (near_iter == _fragments.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        near_iter--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    _fragments.<span class="built_in">insert</span>(current_stream);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!_fragments.<span class="built_in">empty</span>() &amp;&amp; _fragments.<span class="built_in">begin</span>()-&gt;_begin_index == _next_assembled_index) &#123;</span><br><span class="line">        <span class="type">const</span> broken_bytestream head = *_fragments.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">size_t</span> write_cnt = _output.<span class="built_in">write</span>(head._data);</span><br><span class="line">        _next_assembled_index += write_cnt;</span><br><span class="line">        _unassembled_bytes -= write_cnt;</span><br><span class="line"></span><br><span class="line">        _fragments.<span class="built_in">erase</span>(_fragments.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">judge_eof</span>(eof);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">StreamReassembler::merge_fragments</span><span class="params">(broken_bytestream &amp;t1, <span class="type">const</span> broken_bytestream &amp;t2)</span> </span>&#123;</span><br><span class="line">    broken_bytestream front = <span class="built_in">min</span>(t1, t2);</span><br><span class="line">    broken_bytestream back = ((front == t1) ? t2 : t1);</span><br><span class="line">    <span class="keyword">if</span> (front._begin_index + front._len &lt; back._begin_index)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (front._begin_index + front._len &gt;= back._begin_index + back._len) &#123;</span><br><span class="line">        t1 = front;</span><br><span class="line">        <span class="keyword">return</span> back._len;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// front._begin_index+front.len &lt; back._begin_index+back.len</span></span><br><span class="line">        <span class="type">int</span> merge_num = front._begin_index + front._len - back._begin_index;</span><br><span class="line">        t1._begin_index = front._begin_index;</span><br><span class="line">        t1._data = front._data + back._data.<span class="built_in">substr</span>(merge_num);</span><br><span class="line">        t1._len = t1._data.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">return</span> merge_num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">StreamReassembler::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _unassembled_bytes; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StreamReassembler::empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _unassembled_bytes == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><p>TCP报文：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230105222033664.png" alt="image-20230105222033664"></p>
<p>结构体以及函数的使用可以查看<a target="_blank" rel="noopener" href="https://cs144.github.io/doc/lab2/class_t_c_p_segment.html#details">https://cs144.github.io/doc/lab2/class_t_c_p_segment.html#details</a> 或者源代码</p>
<h3 id="序列号转换"><a href="#序列号转换" class="headerlink" title="序列号转换"></a>序列号转换</h3><ul>
<li>序列号 seqno。<strong>从 ISN 起步</strong>，包含 SYN 和 FIN，<strong>32 位循环</strong>计数</li>
<li>绝对序列号 absolute seqno。<strong>从 0 起步</strong>，包含 SYN 和 FIN，<strong>64 位非循环</strong>计数</li>
<li>流索引 stream index。<strong>从 0 起步</strong>，<strong>排除 SYN 和 FIN</strong>，<strong>64 位非循环</strong>计数。</li>
</ul>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230105191357818.png" alt="image-20230105191357818"></p>
<p>完成 序列号&lt;&#x3D;&#x3D;&gt; 绝对序列号 的相互转换</p>
<p>从序列号转到绝对序号号时， 其实就只需要比较   x ， x+2^32 , x- 2^32  这三个数哪个和checkpoints最接近即可。</p>
<blockquote>
<p><code>checkpoint</code>表示最近一次转换求得的<code>absolute seqno</code>，而本次转换出的<code>absolute seqno</code>应该选择与上次值最为接近的那一个。原理是虽然segment不一定按序到达，但几乎不可能出现相邻到达的两个segment序号差值超过<code>INT32_MAX</code>的情况，除非延迟以年为单位，或者产生了比特差错（后面的LAB可能涉及）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrapping_integers.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy implementation of a 32-bit wrapping integer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For Lab 2, please replace with a real implementation that passes the</span></span><br><span class="line"><span class="comment">// automated checks run by `make check_lab2`.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// template &lt;typename... Targs&gt;</span></span><br><span class="line"><span class="comment">// void DUMMY_CODE(Targs &amp;&amp;... /* unused */) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Transform an &quot;absolute&quot; 64-bit sequence number (zero-indexed) into a WrappingInt32</span></span><br><span class="line"><span class="comment">//! \param n The input absolute 64-bit sequence number</span></span><br><span class="line"><span class="comment">//! \param isn The initial sequence number</span></span><br><span class="line">WrappingInt32 <span class="title function_">wrap</span><span class="params">(<span class="type">uint64_t</span> n, WrappingInt32 isn)</span> &#123; <span class="keyword">return</span> WrappingInt32&#123;static_cast&lt;<span class="type">uint32_t</span>&gt;(n) + isn.raw_value()&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Transform a WrappingInt32 into an &quot;absolute&quot; 64-bit sequence number (zero-indexed)</span></span><br><span class="line"><span class="comment">//! \param n The relative sequence number</span></span><br><span class="line"><span class="comment">//! \param isn The initial sequence number</span></span><br><span class="line"><span class="comment">//! \param checkpoint A recent absolute 64-bit sequence number</span></span><br><span class="line"><span class="comment">//! \returns the 64-bit sequence number that wraps to `n` and is closest to `checkpoint`</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! \note Each of the two streams of the TCP connection has its own ISN. One stream</span></span><br><span class="line"><span class="comment">//! runs from the local TCPSender to the remote TCPReceiver and has one ISN,</span></span><br><span class="line"><span class="comment">//! and the other stream runs from the remote TCPSender to the local TCPReceiver and</span></span><br><span class="line"><span class="comment">//! has a different ISN.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  ( offset  + a * 2^32)mod 2^32 = (offset)mod 2 ^ 32 =  n</span></span><br><span class="line"><span class="comment">// a = checkpoint &gt;&gt; 32</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">unwrap</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="type">uint64_t</span> checkpoint)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> offset = n.raw_value() - isn.raw_value();</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> base = (checkpoint &amp; <span class="number">0xFFFFFFFF00000000</span>) + offset;</span><br><span class="line">    <span class="type">uint64_t</span> max_base = base + <span class="number">0x100000000</span>;</span><br><span class="line">    <span class="type">uint64_t</span> min_base = base &gt; <span class="number">0x100000000</span> ? (base - <span class="number">0x100000000</span>) : base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((base &lt; checkpoint) &amp;&amp; ((max_base - checkpoint) &lt; (checkpoint - base)))</span><br><span class="line">        <span class="keyword">return</span> max_base;</span><br><span class="line">    <span class="keyword">if</span> ((base &gt; checkpoint) &amp;&amp; ((checkpoint - min_base) &lt; (base - checkpoint)))</span><br><span class="line">        <span class="keyword">return</span> min_base;</span><br><span class="line">    <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230105191322368.png" alt="image-20230105191322368"></p>
<h3 id="TCP-接收器"><a href="#TCP-接收器" class="headerlink" title="TCP 接收器"></a>TCP 接收器</h3><p>流程图</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230105222600136.png" alt="image-20230105222600136"></p>
<ul>
<li>listen：等待syn包，ackno为空，其余包很简单地直接丢弃。</li>
<li>syn_recv：已经接收了syn包，正常接收数据报</li>
<li>fin_recv : 已经接收了fin包，终止Bytestream的输入。</li>
</ul>
<p>我对计网仅有的了解来源于我大一随便翻了翻的《自顶向下》那本书，翻完后我基本全忘了。所以写这里的时候我是极其懵逼的 ，一直过不了，最后是参考了一下@<a target="_blank" rel="noopener" href="https://github.com/Kiprey">Kiprey</a>师傅的。</p>
<p>问题主要在于，一开始我把SYN报和FIN报当成普通的报文看待，认为只是带了SYN&#x2F;FIN标志而已。，同时能且也有携带payload。</p>
<p>实际上，每个 SYN&#x2F;FIN 报文 还会额外的占用一个seqno，<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24792770">为什么要这么做？</a></p>
<blockquote>
<p>SYNs and FINs require acknowledgement, thus they increment the stream’s sequence number by one when used.For example, if the connection is closed without sending any more data, then if theFIN did not consume a sequencenumber the closing end couldn’t tell the difference between an ACK for the FIN,and an ACK for the data that was sent prior to the FIN.</p>
</blockquote>
<p>简单来说，就是我们需要ack 确认 收到的SYN&#x2F;FIN 报文，尤其是FIN报文，如果不再消耗一个seqno的话，前一个ACK和FIN的ACK就没有区别了。</p>
<blockquote>
<p>但我对这里误解很深的最大原因是，我把SYN报和FIN报当成普通的报文看待，还以为他们能正常携带数据，但事实上，一般TCP在处理SYN报文的时候都会忽略携带的数据…</p>
<p>关于SYN报文传输数据的问题，在此我看到了一篇文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/468912961%EF%BC%8C%E6%9C%89%E5%85%B4%E8%B6%A3%E7%9A%84%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B%E3%80%82">https://zhuanlan.zhihu.com/p/468912961，有兴趣的可以看看。</a></p>
</blockquote>
<p>这样就很容易理解后面那句，我一开始很疑惑这样岂不是让后面一个报文没法写入了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint64_t index=absolute_seqno -1 + header.syn;</span><br></pre></td></tr></table></figure>

<p>这里要加上header.syn，也就是syn报额外占一个seqno，这样我们就可以包含syn报的payload，index 从0开始到payload长度的字节就都被syn报写了，后面再来  absolute_seqno -1 小于这个长度的数的报文也无所谓了，因为我们在StreamReassembler 结构体中已经对这样有重复字节的报文进行处理了。</p>
<p><del>每次看这个表我都会误解</del></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230105213550652.png" alt="image-20230105213550652"></p>
<p>文档中有提到关于携带数据的：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230105222413892.png" alt="image-20230105222413892"></p>
<p>tcp_receiver.hh</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//! \brief The &quot;receiver&quot; part of a TCP implementation.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! Receives and reassembles segments into a ByteStream, and computes</span></span><br><span class="line"><span class="comment">//! the acknowledgment number and window size to advertise back to the</span></span><br><span class="line"><span class="comment">//! remote TCPSender.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPReceiver</span> &#123;</span><br><span class="line">    <span class="comment">//! Our data structure for re-assembling bytes.</span></span><br><span class="line">    StreamReassembler _reassembler;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//! The maximum number of bytes we&#x27;ll store.</span></span><br><span class="line">    <span class="type">size_t</span> _capacity;</span><br><span class="line">    <span class="type">bool</span> _syn_flag;</span><br><span class="line">    WrappingInt32 _isn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>tcp_receiver.cc</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_receiver.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy implementation of a TCP receiver</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For Lab 2, please replace with a real implementation that passes the</span></span><br><span class="line"><span class="comment">// automated checks run by `make check_lab2`.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// template &lt;typename... Targs&gt;</span></span><br><span class="line"><span class="comment">// void DUMMY_CODE(Targs &amp;&amp;... /* unused */) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPReceiver::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123; </span><br><span class="line">    <span class="type">const</span> TCPHeader &amp;header=seg.<span class="built_in">header</span>();</span><br><span class="line">    <span class="keyword">if</span>(!_syn_flag)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!header.syn) <span class="keyword">return</span> ;</span><br><span class="line">        _isn=header.seqno;</span><br><span class="line">        _syn_flag=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> absolute_seqno=<span class="built_in">unwrap</span>(header.seqno,_isn, _reassembler.<span class="built_in">stream_out</span>().<span class="built_in">bytes_written</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint64_t</span> index=absolute_seqno <span class="number">-1</span> + header.syn;</span><br><span class="line"></span><br><span class="line">    _reassembler.<span class="built_in">push_substring</span>(seg.<span class="built_in">payload</span>().<span class="built_in">copy</span>(),index,header.fin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">optional&lt;WrappingInt32&gt; <span class="title">TCPReceiver::ackno</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_syn_flag) <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">    <span class="type">uint64_t</span> ack_no=_reassembler.<span class="built_in">stream_out</span>().<span class="built_in">bytes_written</span>()+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (_reassembler.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>())</span><br><span class="line">        ++ack_no;</span><br><span class="line">    <span class="keyword">return</span> _isn+ack_no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPReceiver::window_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;_capacity - _reassembler.<span class="built_in">stream_out</span>().<span class="built_in">buffer_size</span>()&#125;; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230105204943898.png" alt="image-20230105204943898"></p>
<h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><h3 id="TCP发送器"><a href="#TCP发送器" class="headerlink" title="TCP发送器"></a>TCP发送器</h3><p>这个lab主要在于理解。。但是文档又很长，各个点又没有总结的特别清楚。</p>
<p>总的来说主要是实现滑动窗口，并且是累计确认的，也就是当接收到一个ackno时，代表该ackno之前的所有段都成功被接收了。</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230106193633801.png" alt="image-20230106193633801"></p>
<ul>
<li><p>内部使用tick() 进行计时</p>
<ul>
<li>仅有在ack_received被调用时，计时器才会移动，也就是说，计时器追踪的是 最近的一次ack_received，而不是追踪某一个seg</li>
<li>如何判断超时？ <ul>
<li>计时器超时</li>
<li>缓冲队列不为空</li>
</ul>
</li>
<li>什么时候要增加超时时间窗口 RTO<ul>
<li>超时，且 <strong>window_size &gt;0</strong> , 这点在文档有说，但是window_size的判断非常容易漏</li>
</ul>
</li>
</ul>
</li>
<li><p>fill windows</p>
<ul>
<li>窗口为0的话，应该把它当成1，否则发送方有可能永远不被允许再次发送。当成1以后，发送方可能会发送一个最终被接收方拒绝的字节，但这会使得接收方发送新的ack报文，传回来window_size 将会有更多的空间。</li>
<li>payload size 与 seg length 并不一样，payload不包括 syn&#x2F;fin，window包括</li>
<li>如果没有数据，则不发送seg</li>
</ul>
</li>
<li><p>ack_received</p>
<ul>
<li>设置RTO为初始值	</li>
<li>连续重传计数重置为0</li>
<li>若缓存队列不为空，则重置计时器</li>
</ul>
</li>
</ul>
<p>最后调试的时候 调了好一会，一直有3个test过不了</p>
<p>问题出在两个地方：</p>
<ol>
<li>计算窗口长度的时候 我一开始用的seg.length_in_sequence_space() ，后面才注意到它与payload.size()是不相等的，如果是syn的话，seg.length_in_sequence_space()会比payload.size() 大 1 。</li>
</ol>
<p>​       于时我改成了 seg_length -seg.header().syn ，结果还是不行。 然后改来改去死活都不行，就只有payload.size()可以，我把它们逐一输出 ，也没发现有什么区别。</p>
<p>​     2. 计时器时间等于超时时间时就算超时了，我一直写的大于， test13的测试样例 刚好就是卡的等于 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! segments if the retransmission timer expires.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPSender</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//! our initial sequence number, the number for our SYN.</span></span><br><span class="line">    WrappingInt32 _isn;</span><br><span class="line">    <span class="type">bool</span> _set_syn_flag&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> _set_fin_flag&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="type">size_t</span> _window_size&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> _timer&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> _bytes_in_flight&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//! outbound queue of segments that the TCPSender wants sent</span></span><br><span class="line">    std::queue&lt;TCPSegment&gt; _segments_out&#123;&#125;;</span><br><span class="line">    std::queue&lt;TCPSegment&gt; _segments_backup&#123;&#125;;</span><br><span class="line">    <span class="comment">//! retransmission timer for the connection</span></span><br><span class="line">    <span class="type">size_t</span> _retransmission_timeout&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">size_t</span> _consecutive_retransmissions_cnt&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _initial_retransmission_timeout&#123;&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_sender.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_config.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// Dummy implementation of a TCP sender</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For Lab 3, please replace with a real implementation that passes the</span></span><br><span class="line"><span class="comment">// automated checks run by `make check_lab3`.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] capacity the capacity of the outgoing byte stream</span></span><br><span class="line"><span class="comment">//! \param[in] retx_timeout the initial amount of time to wait before retransmitting the oldest outstanding segment</span></span><br><span class="line"><span class="comment">//! \param[in] fixed_isn the Initial Sequence Number to use, if set (otherwise uses a random ISN)</span></span><br><span class="line">TCPSender::<span class="built_in">TCPSender</span>(<span class="type">const</span> <span class="type">size_t</span> capacity, <span class="type">const</span> <span class="type">uint16_t</span> retx_timeout, <span class="type">const</span> std::optional&lt;WrappingInt32&gt; fixed_isn)</span><br><span class="line">    : _isn(fixed_isn.<span class="built_in">value_or</span>(WrappingInt32&#123;<span class="built_in">random_device</span>()()&#125;))</span><br><span class="line">    , _initial_retransmission_timeout&#123;retx_timeout&#125;</span><br><span class="line">    , _stream(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">TCPSender::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> &#123;_bytes_in_flight&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> window_size=_window_size&gt;<span class="number">0</span>?_window_size:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(window_size &gt; _bytes_in_flight )&#123;</span><br><span class="line">        TCPSegment seg;</span><br><span class="line">        <span class="type">size_t</span> seg_length;</span><br><span class="line">        <span class="keyword">if</span>(!_set_syn_flag)&#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().syn=<span class="literal">true</span>;</span><br><span class="line">            _set_syn_flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        seg.<span class="built_in">header</span>().seqno=<span class="built_in">next_seqno</span>();</span><br><span class="line">        <span class="type">size_t</span> payload_size=<span class="built_in">min</span>(TCPConfig::MAX_PAYLOAD_SIZE, window_size- _bytes_in_flight -seg.<span class="built_in">header</span>().syn);</span><br><span class="line">        string payload = _stream.<span class="built_in">read</span>(payload_size);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//size_t temp=payload.size();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//cout&lt;&lt;temp.size()&lt;&lt;&quot; &quot;&lt;&lt;seg_length -seg.header().syn&lt;&lt;endl;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">/*        if (temp != (seg_length -seg.header().syn)) &#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;temp &lt;&lt;&quot; &quot;  &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;seg_length -seg.header().syn&lt;&lt;endl&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( _stream.<span class="built_in">eof</span>() &amp;&amp; (  payload.<span class="built_in">size</span>() +_bytes_in_flight  &lt; window_size ) &amp;&amp;  !_set_fin_flag )&#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().fin=<span class="literal">true</span>;</span><br><span class="line">            _set_fin_flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        seg.<span class="built_in">payload</span>()=<span class="built_in">Buffer</span>(<span class="built_in">move</span>(payload));</span><br><span class="line">        seg_length=seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!seg_length)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(_segments_backup.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            _retransmission_timeout=_initial_retransmission_timeout;</span><br><span class="line">            _timer=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">        _segments_backup.<span class="built_in">push</span>(seg);</span><br><span class="line"></span><br><span class="line">        _bytes_in_flight+=seg_length;</span><br><span class="line">        _next_seqno+=seg_length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(seg.<span class="built_in">header</span>().fin)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span></span><br><span class="line"><span class="comment">//! \param window_size The remote receiver&#x27;s advertised window size</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="type">const</span> WrappingInt32 ackno, <span class="type">const</span> <span class="type">uint16_t</span> window_size)</span> </span>&#123; </span><br><span class="line">    <span class="type">size_t</span>  absolute_seqno=<span class="built_in">unwrap</span>(ackno,_isn,_next_seqno);</span><br><span class="line">    <span class="keyword">if</span>(absolute_seqno &gt; _next_seqno) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!_segments_backup.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TCPSegment seg=_segments_backup.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">unwrap</span>(seg.<span class="built_in">header</span>().seqno,_isn,_next_seqno) +seg.<span class="built_in">length_in_sequence_space</span>()&lt;= absolute_seqno )&#123;</span><br><span class="line">            _bytes_in_flight-=seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">            _segments_backup.<span class="built_in">pop</span>();</span><br><span class="line">            _retransmission_timeout=_initial_retransmission_timeout;</span><br><span class="line">            _timer=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _consecutive_retransmissions_cnt=<span class="number">0</span>;</span><br><span class="line">    _window_size=window_size;</span><br><span class="line">    <span class="built_in">fill_window</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123; </span><br><span class="line">    _timer+=ms_since_last_tick;</span><br><span class="line">    <span class="keyword">if</span>(!_segments_backup.<span class="built_in">empty</span>() &amp;&amp; (_timer &gt;= _retransmission_timeout))&#123;</span><br><span class="line">        <span class="keyword">if</span>(_window_size)</span><br><span class="line">            _retransmission_timeout*=<span class="number">2</span>;</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(_segments_backup.<span class="built_in">front</span>());</span><br><span class="line">        _consecutive_retransmissions_cnt++;</span><br><span class="line">        _timer=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">TCPSender::consecutive_retransmissions</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _consecutive_retransmissions_cnt; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::send_empty_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TCPSegment seg;</span><br><span class="line">    seg.<span class="built_in">header</span>().seqno=<span class="built_in">next_seqno</span>();</span><br><span class="line">    _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h2><p>最折磨的lab，test样例也没有全过</p>
<p>FSM状态图：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/1608954-20200914214827124-2104730079.png" alt="img"></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/816045-20161105220355065-482198403.png" alt="img"></p>
<p>先建立链接，也就是常说的 三次握手：</p>
<p>起点均为 CLOSED</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/20191108063259623.png" alt="img"></p>
<p>涉及4种状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 未发送SYN ，服务器处于监听状态 </span><br><span class="line">FSM_LISTEN = SENDER_CLOSED &amp;&amp; RECEIVER_LISTEN </span><br><span class="line">// 客户端发送了SYN，但还没有接收到服务器的ack</span><br><span class="line">FSM_SYN_SENT = SENDER_SYN_SENT &amp;&amp; RECEIVER_LISTEN</span><br><span class="line">// 服务器接收到了SYN ，发送了SYN</span><br><span class="line">FSM_SYN_RCVD = RECEIVER_SYN_RECV &amp;&amp; SENDER_SYN_SENT;</span><br><span class="line">// 客户端确认接收到了服务器 SYN，发送了SYN_ack</span><br><span class="line">FSM_ESTABLISHED = RECEIVER_SYN_RECV &amp;&amp; SENDER_SYN_ACKED</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有了这样三次握手，才可以确保两个事实：</p>
<ol>
<li><p>客户端 确认 ：服务器 可以接受到消息 ，客户端也可以收到消息</p>
</li>
<li><p>服务器 确认 ：客户端 可以接收到消息 ， 服务器也可以收到消息</p>
<p>（如果是两次的话 ，就服务器无法确保客户端可以收到消息）</p>
</li>
</ol>
<p>这样可以防止失效的连接请求到达服器，让服务器错误打开连接。客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
</blockquote>
<p>结束链接， 也就是常说的 四次挥手 ：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzMwLmpwZw" alt="客户端主动关闭连接 —— TCP 四次挥手"></p>
<p>涉及六种状态：</p>
<p>_linger_after_streams_finish 代表数据传输完毕后是否保持tcp连接状态（stay active &amp;&amp; keep ACKing）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端发送 FIN 报文 ，此时客户端所有数据发送完毕 ,等待该FIN的ack报文</span></span><br><span class="line">FSM_FIN_WAIT_1 = RECEIVER_SYN_RECV &amp;&amp; SENDER_FIN_SENT</span><br><span class="line"><span class="comment">// 服务器接收客户端 FIN 报文， 返回FIN_ack报文 ，此时服务端仍然可以发送数据</span></span><br><span class="line">FSM_CLOSE_WAIT = RECEIVER_FIN_RECV &amp;&amp; SENDER_SYN_ACKED &amp;&amp; (_linger_after_streams_finish = <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// 客户端接收到 FIN_ack 报文，此时代表 客户端知道服务端已经接收了客户端所有数据，等待接受服务端所有数据</span></span><br><span class="line">FSM_FIN_WAIT_2 = RECEIVER_SYN_RECV &amp;&amp; SENDER_FIN_ACKED</span><br><span class="line"><span class="comment">// 服务端数据发送完毕，发送 FIN 报文， 此时服务端所有数据发送完毕，等待该FIN的ack报文</span></span><br><span class="line">FSM_LAST_ACK = RECEIVER_FIN_RECV &amp;&amp; SENDER_FIN_SENT &amp;&amp; (_linger_after_streams_finish = <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// 客户端接收到了服务端的FIN报文，返回FIN_ack报文 </span></span><br><span class="line">FSM_TIME_WAIT = SENDER_FIN_ACKED &amp;&amp; RECEIVER_FIN_RECV</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对服务端而言： 接收到了 FIN_ack 报文，代表此时 服务端知道客户端已经接收了服务端的所有数据， 服务端关闭</span></span><br><span class="line"><span class="comment">// 对客户端而言： 等待2MSL（一个片段在网络中最大的存活时间），若没有收到回复，则代表服务端已关闭，客户端可以关闭了；如果收到回复，则说明服务器未正常关闭，有可能是服务端重发的FIN报文，这也代表客户端需要重发FIN_ack报文</span></span><br><span class="line">FSM_CLOSED = RECEIVER_FIN_RECV &amp;&amp; SENDER_FIN_ACKED &amp;&amp; (_linger_after_streams_finish = <span class="literal">false</span>) &amp;&amp; (_active = <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较特殊 ，少见的 closing状态：双方都发送了FIN报文，且也接收到了对方的报文FIN报文，也就是 “同时发送” 了  FIN报文，这样就会进入closing状态，两边都等待FIN_ack报文</span></span><br><span class="line">FSM_CLOSING = RECEIVER_FIN_RECV &amp;&amp; SENDER_FIN_SENT </span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样的四次挥手，也是确认两个事实：</p>
<p>服务端确认 ： 服务端已发送所有数据，客户端已接受所有数据。 </p>
<p>客户端确认： 客户端已发送所有数据，服务端已接受所有数据。</p>
<p>（如果少最后一次ack，服务端就不知道客户端已经接受所有数据）</p>
<p>为什么握手是三次，挥手是四次呢？ </p>
<p>原因很简单，第二次握手的报文 同时充当了 SYN报文和ack报文，所以会少一次。</p>
</blockquote>
<p>重置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FSM_RESET = RECEIVER_ERROR &amp;&amp; SENDER_ERROR &amp;&amp; (_linger_after_streams_finish = <span class="literal">false</span>) &amp;&amp;</span><br><span class="line">(_active = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>实验要求实现TPC connection：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230110222657916.png" alt="image-20230110222657916"></p>
<p>两方任意一方都同时充当 sender和 receiver，负责对输入输出流的分别处理</p>
<p>对segment_received 函数而言 ：</p>
<ul>
<li>了解自己写的 receiver，前面lab写的过了check，但不一定过得了这次的check…（对syn之类的考虑应该在里面实现了）</li>
<li>每次接收到报文时，除了给 receiver处理，同时还要考虑sender是否需要返回ack报文（注意，不应该有回应 ack的ack报文），一般返回长度为0的空报文 附加上ack 作为ack报文即可。</li>
<li>如果接收到了rst 就需要停止，具体看文档。</li>
<li>对ack报文，receiver不进行处理，但sender需要其window_size和ackno</li>
</ul>
<p>对 sender：</p>
<p>没什么好说的，把自己写的_sender.fill_window() 写好些，同理，对syn之类的考虑也应该在之前实现了</p>
<p>至于各变量什么时候改变，参照上面的状态变量对应的值即可：</p>
<p>FSM_CLOSE_WAIT 和 FSM_RESET 均使得 _linger_after_streams_finish &#x3D; false</p>
<p>FSM_CLOSED  和 FSM_RESET 均使得 _active &#x3D; false</p>
<p>FSM_TIME_WAIT 超时以后 也可以使得 _active &#x3D; false ，_linger_after_streams_finish &#x3D; false</p>
<p>了解状态图以后 写起来就容易不少了，不然会一直debug</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_connection.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy implementation of a TCP connection</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For Lab 4, please replace with a real implementation that passes the</span></span><br><span class="line"><span class="comment">// automated checks run by `make check`.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">unassembled_bytes</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _time_since_last_segment_received; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    _time_since_last_segment_received = <span class="number">0</span>;</span><br><span class="line">    _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">    <span class="type">bool</span> _send_empty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// don&#x27;t ack the ack</span></span><br><span class="line">    <span class="keyword">if</span> (!seg.<span class="built_in">length_in_sequence_space</span>()) &#123;</span><br><span class="line">        _send_empty = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">        <span class="built_in">unclean</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().ack) &#123;</span><br><span class="line">        _sender.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win);</span><br><span class="line">        <span class="keyword">if</span> (_send_empty &amp;&amp; !_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>())</span><br><span class="line">            _send_empty = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TCPState::<span class="built_in">state_summary</span>(_receiver) == TCPReceiverStateSummary::SYN_RECV &amp;&amp;</span><br><span class="line">        TCPState::<span class="built_in">state_summary</span>(_sender) == TCPSenderStateSummary::CLOSED) &#123;</span><br><span class="line">        <span class="built_in">connect</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TCPState::<span class="built_in">state_summary</span>(_receiver) == TCPReceiverStateSummary::FIN_RECV &amp;&amp;</span><br><span class="line">        TCPState::<span class="built_in">state_summary</span>(_sender) == TCPSenderStateSummary::SYN_ACKED)</span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TCPState::<span class="built_in">state_summary</span>(_receiver) == TCPReceiverStateSummary::FIN_RECV &amp;&amp;</span><br><span class="line">        TCPState::<span class="built_in">state_summary</span>(_sender) == TCPSenderStateSummary::FIN_ACKED &amp;&amp; !_linger_after_streams_finish) &#123;</span><br><span class="line">        _active = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_send_empty)</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">push_segments_out</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _active; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> write_cnt = _sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">push_segments_out</span>();</span><br><span class="line">    <span class="keyword">return</span> write_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::push_segments_out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();  <span class="comment">// raw_value</span></span><br><span class="line">            seg.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if(!_active)</span></span><br><span class="line">    <span class="comment">//     return;</span></span><br><span class="line">    _time_since_last_segment_received += ms_since_last_tick;</span><br><span class="line">    _sender.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">consecutive_retransmissions</span>() &gt; _cfg.MAX_RETX_ATTEMPTS) &#123;</span><br><span class="line">        <span class="comment">// pop</span></span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">unclean</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//_sender.fill_window();</span></span><br><span class="line">    <span class="built_in">push_segments_out</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TCPState::<span class="built_in">state_summary</span>(_receiver) == TCPReceiverStateSummary::FIN_RECV &amp;&amp;</span><br><span class="line">        TCPState::<span class="built_in">state_summary</span>(_sender) == TCPSenderStateSummary::FIN_ACKED &amp;&amp; _linger_after_streams_finish &amp;&amp;</span><br><span class="line">        _time_since_last_segment_received &gt;= <span class="number">10</span> * _cfg.rt_timeout) &#123;</span><br><span class="line">        _active = <span class="literal">false</span>;</span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">push_segments_out</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _active = <span class="literal">true</span>;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">push_segments_out</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::unclean</span><span class="params">(<span class="type">bool</span> rst)</span> </span>&#123;</span><br><span class="line">    _active = <span class="literal">false</span>;</span><br><span class="line">    _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (rst) &#123;</span><br><span class="line">        TCPSegment seg;</span><br><span class="line">        seg.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCPConnection::~<span class="built_in">TCPConnection</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">active</span>()) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Warning: Unclean shutdown of TCPConnection\n&quot;</span>;</span><br><span class="line">            <span class="built_in">unclean</span>(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// Your code here: need to send a RST segment to the peer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception destructing TCP FSM: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230110204008050.png" alt="image-20230110204008050"></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230110211702250.png" alt="image-20230110211702250"></p>
<p>一直都有随机几个是timeout，，，调不出来是什么问题  <del>就当没看见吧</del></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230110225048877.png" alt="image-20230110225048877"></p>
<p>修改webget为自己的TCPSocket：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230110231851279.png" alt="image-20230110231851279"></p>
<p>至此，TCP部分的实验就完结了，哪天有空我可能会再回头看进行改进(?)</p>
<h2 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h2><p>实现ARP协议</p>
<p>整体不算很难，比较需要注意的点是，并非只能从ARP_reply中获取对方的mac，从ARP_request中也可以获取对方的mac。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkInterface</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//! Ethernet (known as hardware, network-access-layer, or link-layer) address of the interface</span></span><br><span class="line">    EthernetAddress _ethernet_address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! IP (known as internet-layer or network-layer) address of the interface</span></span><br><span class="line">    Address _ip_address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! outbound queue of Ethernet frames that the NetworkInterface wants sent</span></span><br><span class="line">    std::queue&lt;EthernetFrame&gt; _frames_out&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> _arp_stay_ttl = <span class="number">30000</span>;  <span class="comment">// 30 s</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> _arp_wait_ttl = <span class="number">5000</span>;   <span class="comment">// 5  s</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ARP_item</span> &#123;</span><br><span class="line">        EthernetAddress mac;</span><br><span class="line">        <span class="type">size_t</span> ttl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">frame_item</span> &#123;</span><br><span class="line">        Address ip_address;</span><br><span class="line">        InternetDatagram dgram;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::map&lt;<span class="type">uint32_t</span>, ARP_item&gt; _arp_table&#123;&#125;;</span><br><span class="line">    std::map&lt;<span class="type">uint32_t</span>, <span class="type">size_t</span>&gt; _arp_searching_list&#123;&#125;;</span><br><span class="line">    std::list&lt;frame_item&gt; _arp_waiting_list&#123;&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;network_interface.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;arp_message.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ethernet_frame.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy implementation of a network interface</span></span><br><span class="line"><span class="comment">// Translates from &#123;IP datagram, next hop address&#125; to link-layer frame, and from link-layer frame to IP datagram</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For Lab 5, please replace with a real implementation that passes the</span></span><br><span class="line"><span class="comment">// automated checks run by `make check_lab5`.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You will need to add private members to the class declaration in `network_interface.hh`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// template &lt;typename... Targs&gt;</span></span><br><span class="line"><span class="comment">// void DUMMY_CODE(Targs &amp;&amp;... /* unused */) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ethernet_address Ethernet (what ARP calls &quot;hardware&quot;) address of the interface</span></span><br><span class="line"><span class="comment">//! \param[in] ip_address IP (what ARP calls &quot;protocol&quot;) address of the interface</span></span><br><span class="line">NetworkInterface::<span class="built_in">NetworkInterface</span>(<span class="type">const</span> EthernetAddress &amp;ethernet_address, <span class="type">const</span> Address &amp;ip_address)</span><br><span class="line">    : _ethernet_address(ethernet_address), _ip_address(ip_address) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;DEBUG: Network interface has Ethernet address &quot;</span> &lt;&lt; <span class="built_in">to_string</span>(_ethernet_address) &lt;&lt; <span class="string">&quot; and IP address &quot;</span></span><br><span class="line">         &lt;&lt; ip_address.<span class="built_in">ip</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] dgram the IPv4 datagram to be sent</span></span><br><span class="line"><span class="comment">//! \param[in] next_hop the IP address of the interface to send it to (typically a router or default gateway, but may also be another host if directly connected to the same network as the destination)</span></span><br><span class="line"><span class="comment">//! (Note: the Address type can be converted to a uint32_t (raw 32-bit IP address) with the Address::ipv4_numeric() method.)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetworkInterface::send_datagram</span><span class="params">(<span class="type">const</span> InternetDatagram &amp;dgram, <span class="type">const</span> Address &amp;next_hop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// convert IP address of next hop to raw 32-bit representation (used in ARP header)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> next_hop_ip = next_hop.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">    <span class="comment">// search in table</span></span><br><span class="line">    <span class="keyword">auto</span> iter = _arp_table.<span class="built_in">find</span>(next_hop_ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iter == _arp_table.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="comment">// not found in table</span></span><br><span class="line">        <span class="keyword">if</span> (_arp_searching_list.<span class="built_in">find</span>(next_hop_ip) == _arp_searching_list.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// havedn&#x27;t send arp</span></span><br><span class="line">            ARPMessage arp_msg;</span><br><span class="line">            arp_msg.sender_ethernet_address = _ethernet_address;</span><br><span class="line">            arp_msg.sender_ip_address = _ip_address.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">            arp_msg.target_ethernet_address = &#123;&#125;;</span><br><span class="line">            arp_msg.target_ip_address = next_hop_ip;</span><br><span class="line">            arp_msg.opcode = ARPMessage::OPCODE_REQUEST;</span><br><span class="line"></span><br><span class="line">            EthernetFrame frame;</span><br><span class="line">            frame.<span class="built_in">header</span>().dst = ETHERNET_BROADCAST;</span><br><span class="line">            frame.<span class="built_in">header</span>().src = _ethernet_address;</span><br><span class="line">            frame.<span class="built_in">header</span>().type = EthernetHeader::TYPE_ARP;</span><br><span class="line">            frame.<span class="built_in">payload</span>() = arp_msg.<span class="built_in">serialize</span>();</span><br><span class="line">            _frames_out.<span class="built_in">push</span>(frame);</span><br><span class="line"></span><br><span class="line">            _arp_searching_list[next_hop_ip] = _arp_wait_ttl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">frame_item</span> item &#123;</span><br><span class="line">            next_hop, dgram</span><br><span class="line">        &#125;;</span><br><span class="line">        _arp_waiting_list.<span class="built_in">push_back</span>(item);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// found in table</span></span><br><span class="line">        EthernetFrame frame;</span><br><span class="line">        frame.<span class="built_in">header</span>().dst = iter-&gt;second.mac;</span><br><span class="line">        frame.<span class="built_in">header</span>().src = _ethernet_address;</span><br><span class="line">        frame.<span class="built_in">header</span>().type = EthernetHeader::TYPE_IPv4;</span><br><span class="line">        frame.<span class="built_in">payload</span>() = dgram.<span class="built_in">serialize</span>();</span><br><span class="line">        _frames_out.<span class="built_in">push</span>(frame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] frame the incoming Ethernet frame</span></span><br><span class="line"><span class="function">optional&lt;InternetDatagram&gt; <span class="title">NetworkInterface::recv_frame</span><span class="params">(<span class="type">const</span> EthernetFrame &amp;frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (frame.<span class="built_in">header</span>().dst != _ethernet_address &amp;&amp; frame.<span class="built_in">header</span>().dst != ETHERNET_BROADCAST)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">    <span class="keyword">if</span> (frame.<span class="built_in">header</span>().type == EthernetHeader::TYPE_IPv4) &#123;</span><br><span class="line">        InternetDatagram dgram;</span><br><span class="line">        <span class="keyword">if</span> (dgram.<span class="built_in">parse</span>(frame.<span class="built_in">payload</span>()) == ParseResult::NoError)</span><br><span class="line">            <span class="keyword">return</span> dgram;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frame.<span class="built_in">header</span>().type == EthernetHeader::TYPE_ARP) &#123;</span><br><span class="line">        ARPMessage arp_msg;</span><br><span class="line">        <span class="keyword">if</span> (arp_msg.<span class="built_in">parse</span>(frame.<span class="built_in">payload</span>()) != ParseResult::NoError)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arp_msg.opcode == ARPMessage::OPCODE_REQUEST &amp;&amp; arp_msg.target_ip_address == _ip_address.<span class="built_in">ipv4_numeric</span>()) &#123;</span><br><span class="line">            <span class="comment">// arp request</span></span><br><span class="line">            ARPMessage arp_reply;</span><br><span class="line">            arp_reply.opcode = ARPMessage::OPCODE_REPLY;</span><br><span class="line">            arp_reply.sender_ethernet_address = _ethernet_address;</span><br><span class="line">            arp_reply.sender_ip_address = _ip_address.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">            arp_reply.target_ethernet_address = arp_msg.sender_ethernet_address;</span><br><span class="line">            arp_reply.target_ip_address = arp_msg.sender_ip_address;</span><br><span class="line"></span><br><span class="line">            EthernetFrame <span class="type">frame_t</span>;</span><br><span class="line">            <span class="type">frame_t</span>.<span class="built_in">header</span>().dst = arp_msg.sender_ethernet_address;</span><br><span class="line">            <span class="type">frame_t</span>.<span class="built_in">header</span>().src = _ethernet_address;</span><br><span class="line">            <span class="type">frame_t</span>.<span class="built_in">header</span>().type = EthernetHeader::TYPE_ARP;</span><br><span class="line">            <span class="type">frame_t</span>.<span class="built_in">payload</span>() = arp_reply.<span class="built_in">serialize</span>();</span><br><span class="line">            _frames_out.<span class="built_in">push</span>(<span class="type">frame_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((arp_msg.opcode == ARPMessage::OPCODE_REQUEST &amp;&amp; arp_msg.target_ip_address == _ip_address.<span class="built_in">ipv4_numeric</span>()) ||</span><br><span class="line">            (arp_msg.opcode == ARPMessage::OPCODE_REPLY &amp;&amp; arp_msg.target_ethernet_address == _ethernet_address)) &#123;</span><br><span class="line">            <span class="comment">// arp reply</span></span><br><span class="line"></span><br><span class="line">            ARP_item item;</span><br><span class="line">            item.mac = arp_msg.sender_ethernet_address;</span><br><span class="line">            item.ttl = _arp_stay_ttl;</span><br><span class="line">            _arp_table[arp_msg.sender_ip_address] = item;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> iter = _arp_waiting_list.<span class="built_in">begin</span>(); iter != _arp_waiting_list.<span class="built_in">end</span>();) &#123;</span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;ip_address.<span class="built_in">ipv4_numeric</span>() == arp_msg.sender_ip_address) &#123;</span><br><span class="line">                    <span class="built_in">send_datagram</span>(iter-&gt;dgram, iter-&gt;ip_address);</span><br><span class="line">                    iter = _arp_waiting_list.<span class="built_in">erase</span>(iter);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    iter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _arp_searching_list.<span class="built_in">erase</span>(arp_msg.sender_ip_address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetworkInterface::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = _arp_table.<span class="built_in">begin</span>(); iter != _arp_table.<span class="built_in">end</span>();) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;second.ttl &lt;= ms_since_last_tick) &#123;</span><br><span class="line">            iter = _arp_table.<span class="built_in">erase</span>(iter);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            iter-&gt;second.ttl -= ms_since_last_tick;</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = _arp_searching_list.<span class="built_in">begin</span>(); iter != _arp_searching_list.<span class="built_in">end</span>();) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;second &lt;= ms_since_last_tick) &#123;</span><br><span class="line">            ARPMessage arp_msg;</span><br><span class="line">            arp_msg.sender_ethernet_address = _ethernet_address;</span><br><span class="line">            arp_msg.sender_ip_address = _ip_address.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">            arp_msg.target_ethernet_address = &#123;&#125;;</span><br><span class="line">            arp_msg.target_ip_address = iter-&gt;first;</span><br><span class="line">            arp_msg.opcode = ARPMessage::OPCODE_REQUEST;</span><br><span class="line"></span><br><span class="line">            EthernetFrame frame;</span><br><span class="line">            frame.<span class="built_in">header</span>().dst = ETHERNET_BROADCAST;</span><br><span class="line">            frame.<span class="built_in">header</span>().src = _ethernet_address;</span><br><span class="line">            frame.<span class="built_in">header</span>().type = EthernetHeader::TYPE_ARP;</span><br><span class="line">            frame.<span class="built_in">payload</span>() = arp_msg.<span class="built_in">serialize</span>();</span><br><span class="line">            _frames_out.<span class="built_in">push</span>(frame);</span><br><span class="line"></span><br><span class="line">            iter-&gt;second = _arp_wait_ttl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            iter-&gt;second -= ms_since_last_tick;</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230111170241462.png" alt="image-20230111170241462"></p>
<h2 id="lab6"><a href="#lab6" class="headerlink" title="lab6"></a>lab6</h2><p>实现简单的路由转发，代码就不贴了</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230112154149848.png" alt="image-20230112154149848"></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>7r1p13J</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/kernel-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"># kernel 内存管理</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/11/19/Buddy%20System/">Buddy System源码阅读</a>
            
            
            <a class="next" rel="next" href="/2022/11/17/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Linux内存管理分析</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 7r1p13J | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>