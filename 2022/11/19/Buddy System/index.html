<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="7r1p13J">





<title>Buddy System源码阅读 | Hexo</title>



    <link rel="icon" href="/github-11-48.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">7r1pl3J&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">7r1pl3J&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Buddy System源码阅读</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">7r1p13J</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">November 19, 2022&nbsp;&nbsp;10:28:05</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/kernel/">kernel</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="在一切开始之前"><a href="#在一切开始之前" class="headerlink" title="在一切开始之前"></a>在一切开始之前</h2><p>一个总览图：</p>
<p>malloc，brk，mmap返回的都是线性地址（虚拟地址）</p>
<p>kmalloc从slab中申请到的是物理内存，位于物理内存的映射区，且地址连续，但返回的是线性地址（虚拟地址），该线性地址与真实地址仅相差一个固定的偏移，通过内核提供的virt_to_phys()可以实现该虚拟地址到真实的内核物理地址之间的转换:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline phys_addr_t virt_to_phys(volatile void *address)</span><br><span class="line">&#123;</span><br><span class="line">	return __pa(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/system_memory.jpg" alt="buddy_system"></p>
<p>进程地址空间与虚拟地址空间：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/270929306664122.jpg" alt="img"></p>
<h2 id="buddy-system"><a href="#buddy-system" class="headerlink" title="buddy system"></a>buddy system</h2><p>上文说到，zone的空闲页帧由buddy system管理，具体的,管理的是zone结构体中的<code>struct free_area	free_area[MAX_ORDER];</code>在代码中可以找到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ORDER 11</span></span><br></pre></td></tr></table></figure>

<p>也就是管理着11个free_area结构体</p>
<p>我们可以在 <code>/include/linux/mmzone.h</code> 中找到其定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct list_head</code> 是内核通用链表，而 <code>MIGRATE_TYPES</code> 代表了迁移的种类数目，nr_free代表链表上所有空闲页帧的数目（以内存块为单位，只有第0个数组才是单个页）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span></span><br><span class="line">	MIGRATE_UNMOVABLE,  <span class="comment">//不可迁移页</span></span><br><span class="line">	MIGRATE_MOVABLE,	<span class="comment">//可迁移页</span></span><br><span class="line">	MIGRATE_RECLAIMABLE,<span class="comment">//可回收页</span></span><br><span class="line">	MIGRATE_PCPTYPES,	<span class="comment">/* the number of types on the pcp lists */</span></span><br><span class="line">	MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * MIGRATE_CMA migration type is designed to mimic the way</span></span><br><span class="line"><span class="comment">	 * ZONE_MOVABLE works.  Only movable pages can be allocated</span></span><br><span class="line"><span class="comment">	 * from MIGRATE_CMA pageblocks and page allocator never</span></span><br><span class="line"><span class="comment">	 * implicitly change migration type of MIGRATE_CMA pageblock.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The way to use it is to change migratetype of a range of</span></span><br><span class="line"><span class="comment">	 * pageblocks to MIGRATE_CMA which can be done by</span></span><br><span class="line"><span class="comment">	 * __free_pageblock_cma() function.  What is important though</span></span><br><span class="line"><span class="comment">	 * is that a range of pageblocks must be aligned to</span></span><br><span class="line"><span class="comment">	 * MAX_ORDER_NR_PAGES should biggest page be bigger than</span></span><br><span class="line"><span class="comment">	 * a single pageblock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	MIGRATE_CMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">	MIGRATE_ISOLATE,	<span class="comment">/* can&#x27;t allocate from here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	MIGRATE_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里讲一下页面迁移的知识</p>
<p><img src="http://blog.chinaunix.net/attachment/201301/21/20321537_1358739135aNjB.png" alt="img"></p>
<p>假如上图中大部分页都是可移动页，而分配出去的四个页都是不可移动页，由于不可移动页插在了其他类型页的中间，就导致了无法从原本空闲的连续内存区中分配较大的内存块。</p>
<p>将可回收页和不可移动页分开，这样虽然在不可移动页的区域当中无法分配大块的连续内存，但是可回收页的区域却没有受其影响，可以分配大块的连续内存</p>
</blockquote>
<p>故free_area 结构并非只有一个链表，而是多个链表，主要以页的迁移种类来分类，而不同的free_area所存储的页面大小也是不同的</p>
<ul>
<li>free_area[0] 中存储了2^0大小的页面组成的list（即一个page大小）</li>
<li>free_area[1] 中存储了2^1大小的页面组成的list（即两个page大小）</li>
<li>……</li>
<li>free_area[10] 中存储了2^10大小的页面组成的list（即十个page大小）</li>
</ul>
<p>结构大致如下图所示：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221105005845503.png" alt="image-20221105005845503"></p>
<blockquote>
<p>结合上面的page结构体分析，链表是利用空闲区间第一个物理页page结构的lru成员构成的双向链表。</p>
</blockquote>
<p>在linux上可以利用 cat &#x2F;proc&#x2F;buddyinfo 查看相关信息</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221105010718360.png" alt="image-20221105010718360"></p>
<p>右侧各列数字代表0~10order 空闲区间页帧的数量。</p>
<h2 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h2><p>一个总览图：</p>
<blockquote>
<p>我现在审计的版本核心函数应该是__alloc_pages。好奇去翻了下commit，不过 没找到到底是啥时候改的</p>
</blockquote>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/db0d5ab87d01489385d0139f95c85ab7.png" alt="在这里插入图片描述"></p>
<p>alloc_pages 函数返回内存块的首个页帧page结构体指针，实现于 <code>/include/linux/gfp.h</code> </p>
<p>函数调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alloc_pages</span><br><span class="line">  alloc_pages_node</span><br><span class="line">      __alloc_pages_node(nid, gfp_mask, order) </span><br><span class="line">          __alloc_pages(gfp_mask, order, nid, NULL) </span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page *<span class="title function_">alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> alloc_pages_node(numa_node_id(), gfp_mask, order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gfp_mask为分配修饰符，在<code>/include/linux/gfp.h</code> 中都可以找到，例如行为修饰符：</p>
<blockquote>
<p>这里书上或者源码里都有较详细的注释，我直接copy arttnba3师傅的表格了（</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">flag</th>
<th align="left">description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__GFP_IO</td>
<td align="left">启动物理I&#x2F;O传输</td>
</tr>
<tr>
<td align="left">__GFP_FS</td>
<td align="left">允许调用底层FS文件系统。可避免分配器递归到可能已经持有锁的文件系统中， 避免死锁</td>
</tr>
<tr>
<td align="left">__GFP_DIRECT_RECLAIM</td>
<td align="left">分配内存过程中可以使用直接内存回收</td>
</tr>
<tr>
<td align="left">__GFP_KSWAPD_RECLAIM</td>
<td align="left">内存到达低水位时唤醒kswapd线程异步回收内存</td>
</tr>
<tr>
<td align="left">__GFP_RECLAIM</td>
<td align="left">表示是否可以直接内存回收或者使用kswapd线程进行回收</td>
</tr>
<tr>
<td align="left">__GFP_RETRY_MAYFAIL</td>
<td align="left">分配内存可以可能会失败，但是在申请过程中会回收一些不必要的内存，是整个系统受益</td>
</tr>
<tr>
<td align="left">__GFP_NOFAIL</td>
<td align="left">内存分配失败后无限制的重复尝试，知道分配成功</td>
</tr>
<tr>
<td align="left">__GFP_NORETRY</td>
<td align="left">直接页面回收或者内存规整后还是无法分配内存时，不启用retry反复尝试分配内存，直接返回NULL</td>
</tr>
</tbody></table>
<p>除此之外还有区修饰符，以及类型标志（各种修饰符的组合）</p>
<p>order也就是要分配的空间大小的阶数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page *<span class="title function_">alloc_pages_node</span><span class="params">(<span class="type">int</span> nid, <span class="type">gfp_t</span> gfp_mask,</span></span><br><span class="line"><span class="params">						<span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (nid == NUMA_NO_NODE)</span><br><span class="line">		nid = numa_mem_id();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __alloc_pages_node(nid, gfp_mask, order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nid就是node节点的id，一般是离cpu最近的那个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__alloc_pages_node(<span class="type">int</span> nid, <span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span><br><span class="line">&#123;</span><br><span class="line">	VM_BUG_ON(nid &lt; <span class="number">0</span> || nid &gt;= MAX_NUMNODES);</span><br><span class="line">	VM_WARN_ON((gfp_mask &amp; __GFP_THISNODE) &amp;&amp; !node_online(nid));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __alloc_pages(gfp_mask, order, nid, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="alloc-pages"><a href="#alloc-pages" class="headerlink" title="__alloc_pages()"></a>__alloc_pages()</h3><p>核心函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">alloc_pages</span>(<span class="title">gfp_t</span> <span class="title">gfp</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class">							<span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line">	<span class="type">gfp_t</span> alloc_gfp; <span class="comment">/* The gfp_t that was actually used for allocation */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> =</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There are several places where we assume that the order value is sane</span></span><br><span class="line"><span class="comment">	 * so bail out early if the request is out of bound.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(order &gt;= MAX_ORDER)) &#123;</span><br><span class="line">		WARN_ON_ONCE(!(gfp &amp; __GFP_NOWARN));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gfp &amp;= gfp_allowed_mask;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Apply scoped allocation constraints. This is mainly about GFP_NOFS</span></span><br><span class="line"><span class="comment">	 * resp. GFP_NOIO which has to be inherited for all allocation requests</span></span><br><span class="line"><span class="comment">	 * from a particular context which has been marked by</span></span><br><span class="line"><span class="comment">	 * memalloc_no&#123;fs,io&#125;_&#123;save,restore&#125;. And PF_MEMALLOC_PIN which ensures</span></span><br><span class="line"><span class="comment">	 * movable zones are not used during allocation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gfp = current_gfp_context(gfp);</span><br><span class="line">	alloc_gfp = gfp;</span><br><span class="line">	<span class="keyword">if</span> (!prepare_alloc_pages(gfp, order, preferred_nid, nodemask, &amp;ac,</span><br><span class="line">			&amp;alloc_gfp, &amp;alloc_flags))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Forbid the first pass from falling back to types that fragment</span></span><br><span class="line"><span class="comment">	 * memory until all local zones are considered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* First allocation attempt */</span></span><br><span class="line">	page = get_page_from_freelist(alloc_gfp, order, alloc_flags, &amp;ac);</span><br><span class="line">	<span class="keyword">if</span> (likely(page))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	alloc_gfp = gfp;</span><br><span class="line">	ac.spread_dirty_pages = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Restore the original nodemask if it was potentially replaced with</span></span><br><span class="line"><span class="comment">	 * &amp;cpuset_current_mems_allowed to optimize the fast-path attempt.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ac.nodemask = nodemask;</span><br><span class="line"></span><br><span class="line">	page = __alloc_pages_slowpath(alloc_gfp, order, &amp;ac);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (memcg_kmem_enabled() &amp;&amp; (gfp &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;</span><br><span class="line">	    unlikely(__memcg_kmem_charge_page(page, gfp, order) != <span class="number">0</span>)) &#123;</span><br><span class="line">		__free_pages(page, order);</span><br><span class="line">		page = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_mm_page_alloc(page, order, alloc_gfp, ac.migratetype);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里分配了个 <code>alloc_context</code> 结构体，定义于 <code>/mm/internal.h</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用以保存在分配时涉及到的函数间传递的</span></span><br><span class="line"><span class="comment"> * 绝大部分的不可变的分配参数的结构体，</span></span><br><span class="line"><span class="comment"> * 包括 alloc_pages 函数族</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * nodemask, migratetype 与 highest_zoneidx 仅在</span></span><br><span class="line"><span class="comment"> * __alloc_pages_nodemask() 中被初始化一次，之后不再改变.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zonelist, preferred_zone 与 highest_zoneidx 最初在</span></span><br><span class="line"><span class="comment"> * __alloc_pages_nodemask() 中为快速路径设置, 之后可能会在</span></span><br><span class="line"><span class="comment"> * __alloc_pages_slowpath() 中被改变. 其他所有的函数通过</span></span><br><span class="line"><span class="comment"> * 常量指针传递该结构体。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zonelist</span>;</span></span><br><span class="line">	<span class="type">nodemask_t</span> *nodemask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">preferred_zoneref</span>;</span></span><br><span class="line">	<span class="type">int</span> migratetype;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    highest_zoneidx 表示分配请求的最高可用区域索引。 由于 zone 的性质，低于最高 zoneidx 的 zone 上的内存将受到 lowmem_reserve[highest_zoneidx] 的保护。</span></span><br><span class="line"><span class="comment">    highest_zoneidx 也被回收/压缩用于限制目标区域，因为高于此索引的区域不能用于此分配请求。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">highest_zoneidx</span>;</span>  </span><br><span class="line">    </span><br><span class="line">	<span class="type">bool</span> spread_dirty_pages;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>zonelist结构体定于如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一个分配请求在 zonelist 上运行。 zonelist 是区域列表，第一个是分配的“目标”，其他区域是后备区域，优先级递减。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 为了加快 zonelist 的读取速度，zonerefs 包含正在读取的条目的区域索引。 在给定结构 zoneref 的情况下访问信息的辅助函数是</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * zonelist_zone() - 返回结构区域 * 用于 _zonerefs 中的条目</span></span><br><span class="line"><span class="comment">  * zonelist_zone_idx() - 返回一个条目的区域索引</span></span><br><span class="line"><span class="comment">  * zonelist_node_idx() - 返回条目的节点索引</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> _<span class="title">zonerefs</span>[<span class="title">MAX_ZONES_PER_ZONELIST</span> + 1];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>zoneref</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该结构包含了 zonelist 中一个 zone 的信息。 </span></span><br><span class="line"><span class="comment"> * 其被储存在这里以预防对大结构体的解引用与对表的查询。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span>	<span class="comment">/* 指向实际上的 zone 的指针 */</span></span><br><span class="line">	<span class="type">int</span> zone_idx;		<span class="comment">/* zone_idx(zoneref-&gt;zone) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也就是记录了本次分配上下文中，我们将要操作的zone列表</p>
<p><code>struct zoneref *preferred_zoneref;</code> 如字面意思，就是分配优先级较高的zone</p>
<p>而NODEMASK 作为内核基础数据结构，常用于统计当前 Online&#x2F;Possible Online NUMA NODE 的数量、判断 NUMA NODE 是否包含内存、判断 NUMA NODE 是否与 CPU 进行绑定等，NODEMASK 作为 NUMA 子系统不可或缺的一部分，为内核和其他子系统提供了 NUMA NODE 的多种信息，首先来看一下 NODEMASK 定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> DECLARE_BITMAP(bits, MAX_NUMNODES); &#125; <span class="type">nodemask_t</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">nodemask_t</span> _unused_nodemask_arg_;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在支持多 NUMA NODE 的架构体系中，内核可以最多支持 MAX_NUMNODES 个 NUMA NODE, NODEMASK 基于 Bitmap 机制，将每个 NUMA NODE 通过 bitmap 中的一个 bit 进行维护，因此定义了 NODEMASK 逻辑结构，每个 NUMA NODE 对应了 NODEMASK 中的一个 bit，也可以称为 node，通过 node 的置位或清零来维护指定信息。</p>
<p>可以理解为于NUMA 有关的node信息</p>
</blockquote>
<p>migratetype就是页面迁移种类，现在重新审视__alloc_pages（）函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">alloc_pages</span>(<span class="title">gfp_t</span> <span class="title">gfp</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class">							<span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line">	<span class="type">gfp_t</span> alloc_gfp; <span class="comment">/* The gfp_t that was actually used for allocation */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> =</span> &#123; &#125;; <span class="comment">//存放上下文信息的结构体</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 有几个地方我们假设请求值是合理的，所以如果请求超出范围，请尽早退出。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(order &gt;= MAX_ORDER)) &#123;</span><br><span class="line">		WARN_ON_ONCE(!(gfp &amp; __GFP_NOWARN));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gfp &amp;= gfp_allowed_mask;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 应用范围分配约束。 这主要是关于 GFP_NOFS resp。 GFP_NOIO 必须为来自特定上下文的所有分配请求继承，该上下文已由 memalloc_no&#123;fs,io&#125;_&#123;save,restore&#125; 标记  ，PF_MEMALLOC_PIN 确保在分配期间不使用可移动区域。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gfp = current_gfp_context(gfp);<span class="comment">////根据当前进程的flags（current-&gt;flags）调整gfp</span></span><br><span class="line">	alloc_gfp = gfp;</span><br><span class="line">	<span class="keyword">if</span> (!prepare_alloc_pages(gfp, order, preferred_nid, nodemask, &amp;ac,</span><br><span class="line">			&amp;alloc_gfp, &amp;alloc_flags))</span><br><span class="line">        <span class="comment">// 对alloc_context 结构体进行赋值,以及一些分配浅浅的准备操作</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 在考虑所有本地区域之前，禁止第一次回退到碎片内存的类型。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 第一次尝试分配  快速路径*/</span></span><br><span class="line">	page = get_page_from_freelist(alloc_gfp, order, alloc_flags, &amp;ac);</span><br><span class="line">	<span class="keyword">if</span> (likely(page))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	alloc_gfp = gfp;</span><br><span class="line">	ac.spread_dirty_pages = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 如果它可能被 &amp;cpuset_current_mems_allowed 替换，则恢复原始节点掩码以优化快速路径尝试。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ac.nodemask = nodemask;</span><br><span class="line">	<span class="comment">//第一次失败 尝试第二次分配 慢速路径</span></span><br><span class="line">	page = __alloc_pages_slowpath(alloc_gfp, order, &amp;ac);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (memcg_kmem_enabled() &amp;&amp; (gfp &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;</span><br><span class="line">	    unlikely(__memcg_kmem_charge_page(page, gfp, order) != <span class="number">0</span>)) &#123;</span><br><span class="line">		__free_pages(page, order);</span><br><span class="line">		page = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_mm_page_alloc(page, order, alloc_gfp, ac.migratetype);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-page-from-freelist"><a href="#get-page-from-freelist" class="headerlink" title="get_page_from_freelist()"></a>get_page_from_freelist()</h3><p>快分配路径，由zone中的freelist直接分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *</span><br><span class="line"><span class="title function_">get_page_from_freelist</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order, <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params">						<span class="type">const</span> <span class="keyword">struct</span> alloc_context *ac)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">z</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">last_pgdat_dirty_limit</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">bool</span> no_fallback;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 扫描zonelist ，尝试找一个拥有足够free pages的zone</span></span><br><span class="line"><span class="comment">	 * See also __cpuset_node_allowed() comment in kernel/cpuset.c.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT; <span class="comment">//避免内存碎片</span></span><br><span class="line">	z = ac-&gt;preferred_zoneref;<span class="comment">//尝试从优先的zone开始分配</span></span><br><span class="line">    <span class="comment">//从优先zone z开始遍历zonelist中的zoneref数组</span></span><br><span class="line">    <span class="comment">//此函数返回以z为起点，遍历到小于等于高水位zone的下一个zone</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    宏定义如下</span></span><br><span class="line"><span class="comment">    #define for_next_zone_zonelist_nodemask(zone, z, highidx, nodemask) \</span></span><br><span class="line"><span class="comment">	for (zone = z-&gt;zone;	\</span></span><br><span class="line"><span class="comment">		zone;							\</span></span><br><span class="line"><span class="comment">		z = next_zones_zonelist(++z, highidx, nodemask),	\</span></span><br><span class="line"><span class="comment">			zone = zonelist_zone(z))</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,</span><br><span class="line">					ac-&gt;nodemask) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> mark;</span><br><span class="line">		<span class="comment">//开启了cpuset的情况，判断gfp和flag</span></span><br><span class="line">		<span class="keyword">if</span> (cpusets_enabled() &amp;&amp;</span><br><span class="line">			(alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;</span><br><span class="line">			!__cpuset_zone_allowed(zone, gfp_mask))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 在分配页缓存（page cache）页以进行写入时, 我们想要</span></span><br><span class="line"><span class="comment">		 * 在一个节点的“脏限制”（dirty limit）内获得他, </span></span><br><span class="line"><span class="comment">         * 由此，没有一个节点有着超过全局允许的脏页比例。</span></span><br><span class="line"><span class="comment">		 * 脏限制考虑了节点的低端内存保留和高水位线，</span></span><br><span class="line"><span class="comment">		 * 以便于 kswapd 能平衡它，而不必从其 LRU 列表中写入页面。</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">XXX:</span> 现在, 在进入回收之前，</span></span><br><span class="line"><span class="comment">		 * 允许分配可能超过 慢速路径中 (spread_dirty_pages unset)</span></span><br><span class="line"><span class="comment">		 * 单节点的 dirty limit，这在一个允许节点们在一起都未够大以达到全局限制</span></span><br><span class="line"><span class="comment">         * 的 NUMA 设置中是很重要的。对于这些情况的合适的修补将需要对</span></span><br><span class="line"><span class="comment">		 * dirty-throttling 与 flusher threads 中节点的意识.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ac-&gt;spread_dirty_pages) &#123;</span><br><span class="line">			<span class="keyword">if</span> (last_pgdat_dirty_limit == zone-&gt;zone_pgdat)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!node_dirty_ok(zone-&gt;zone_pgdat)) &#123;</span><br><span class="line">				last_pgdat_dirty_limit = zone-&gt;zone_pgdat;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (no_fallback &amp;&amp; nr_online_nodes &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">		    zone != ac-&gt;preferred_zoneref-&gt;zone) &#123; <span class="comment">//当前zone不是优先zone&amp;&amp;node数量&gt;1</span></span><br><span class="line">			<span class="type">int</span> local_nid;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 若移动到了 remote node（译注：非当前node？）, 则重试，</span></span><br><span class="line"><span class="comment">			 * 但允许 fragmenting fallbacks. 局部性比避免碎片更加重要。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);</span><br><span class="line">            <span class="comment">//判断node是否是local node，不是的话去除ALLOC_NOFRAGMENT位，优先分配local node中的zone</span></span><br><span class="line">			<span class="keyword">if</span> (zone_to_nid(zone) != local_nid) &#123;</span><br><span class="line">				alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">				<span class="keyword">goto</span> retry;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取水位线 并判断是否充足 </span></span><br><span class="line">		mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);</span><br><span class="line">		<span class="keyword">if</span> (!zone_watermark_fast(zone, order, mark,</span><br><span class="line">				       ac-&gt;highest_zoneidx, alloc_flags,</span><br><span class="line">				       gfp_mask)) &#123;</span><br><span class="line">			<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 该 zone 的水位线失败, 但若其包含了 deferred pages，</span></span><br><span class="line"><span class="comment">			 * 则我们会看该 zone 是否还能再进行扩展</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="comment">/* Checked here to keep the fast path fast */</span></span><br><span class="line">			BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);</span><br><span class="line">			<span class="keyword">if</span> (alloc_flags &amp; ALLOC_NO_WATERMARKS)<span class="comment">//不需要检查水位线的话 直接从该zone分配</span></span><br><span class="line">				<span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!node_reclaim_enabled() ||</span><br><span class="line">			    !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//进行页面回收</span></span><br><span class="line">			ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);</span><br><span class="line">			<span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">			<span class="keyword">case</span> NODE_RECLAIM_NOSCAN:</span><br><span class="line">				<span class="comment">/* 不做扫描 */</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">case</span> NODE_RECLAIM_FULL:</span><br><span class="line">				<span class="comment">/* 扫描了但不可回收 */</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">/* 是否回收足够的页 */</span></span><br><span class="line">				<span class="keyword">if</span> (zone_watermark_ok(zone, order, mark,</span><br><span class="line">					ac-&gt;highest_zoneidx, alloc_flags))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">try_this_zone:</span><br><span class="line">        <span class="comment">//rmqueue函数内部即buddy算法的实现</span></span><br><span class="line">		page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">				gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line">		<span class="keyword">if</span> (page) &#123;</span><br><span class="line">			prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 若这是一个高阶的原子分配，</span></span><br><span class="line"><span class="comment">			 * 检查我们是否该为将来保留 pageblock</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))</span><br><span class="line">				reserve_highatomic_pageblock(page, zone, order);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> page; <span class="comment">//成功 </span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">			<span class="comment">/* 若该 zone 有 deferred pages，再试一遍 */</span></span><br><span class="line">			<span class="keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在一台 UMA 机器上可能所以的 zone 都是破碎的，</span></span><br><span class="line"><span class="comment">	 * 若避免碎片, 重置并重试.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (no_fallback) &#123;</span><br><span class="line">		alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;c</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总流程如下：</p>
<blockquote>
<p>偷，侵删</p>
</blockquote>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/SJMKys31ofnTPXc.png" alt="偷的图.png"></p>
<h3 id="rmqueue"><a href="#rmqueue" class="headerlink" title="rmqueue()"></a>rmqueue()</h3><p>在这之前先简单梳理一下伙伴算法，以便于理解函数流程</p>
<p><strong>伙伴的定义</strong>：</p>
<ol>
<li><strong>两个块大小相同；</strong></li>
<li><strong>两个块地址连续；</strong></li>
<li><strong>两个块必须是同一个大块中分离出来的；</strong></li>
</ol>
<blockquote>
<p>对于分配和回收算法的概述，维基上有非常详细的例子:<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Buddy_memory_allocation">https://en.wikipedia.org/wiki/Buddy_memory_allocation</a></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221124161451211.png" alt="image-20221124161451211"></p>
</blockquote>
<h4 id="分配："><a href="#分配：" class="headerlink" title="分配："></a>分配：</h4><p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221105005845503.png" alt="image-20221105005845503"></p>
<p>对于这样一个free_area链表，假设系统需要分配16k大小 (4个4k page)的块，则会执行以下步骤</p>
<ul>
<li>寻找free_area[2],<ul>
<li>有空闲块,则直接取出并退出</li>
<li>无空闲块<ul>
<li>继续顺着数组向上寻找至有空闲块的链表free_area[k]<ul>
<li>k为数组的最后，则说明没有空闲块，放弃</li>
<li>k不为数组的最后，则将free_area[k]的一个空闲块先平均分割，分割出来的一半放在 free_area[k-1]处继续作为内存块<ul>
<li>另一半也是如此继续分割，直至分割出来的大小刚好满足系统申请的大小（即刚好大于或等于，在这里即刚好大于等于16k）分配给系统，而其余分割出来的作为内存块挂在相应的free_area链表上</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>一个更形象的实例：</p>
<p>我们想分配70K的块空间</p>
<p>1.70K向上取整到2的倍数：128K</p>
<p>2.查询有128K空闲块吗？</p>
<p>3.没有，分配256K块。</p>
<p>　　a.有256K的空闲块吗？</p>
<p>　　b.没有，分配512K的块。</p>
<p>　　　　i.有512K空闲块吗？</p>
<p>　　　　ii.没有，分配1M的空闲块</p>
<p>　　　　　　i.有1M的空闲块吗？</p>
<p>　　　　　　ii.有，从1M的那个空闲链表中摘下，分配出去</p>
<p>​     		  iii.拆开一半挂在512k空闲链表上</p>
<pre><code>           iv.返回另一半512K块
</code></pre>
<p>　　c.拆开一半挂在256k空闲链表上</p>
<p>　　d.返回另一半256k块</p>
<p>4.将获得的256K的块拆两半，一半挂在128K空闲链表中</p>
<p>5.另一半128K块返回用户。</p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15351135/3726710">https://blog.51cto.com/u_15351135/3726710</a></p>
</blockquote>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rmqueue</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">			<span class="type">gfp_t</span> gfp_flags, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params">			<span class="type">int</span> migratetype)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(pcp_allowed_order(order))) &#123;</span><br><span class="line">        <span class="comment">// 检查是否需要通过PCP进行分配，所谓PCP即Per_CPU方式，即内核将变量缓存给每一个CPU上，不同的CPU都保留有自己的副本，这样不同的CPU可以并发的访问自己的这部分变量而无需上锁。</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		  * MIGRATE_MOVABLE 的 pcplist 可能在 CMA 区域有着页面，</span></span><br><span class="line"><span class="comment">		 * 当从 CMA 的分配不被允许时我们需要略过它</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (!IS_ENABLED(CONFIG_CMA) || alloc_flags &amp; ALLOC_CMA ||</span><br><span class="line">				migratetype != MIGRATE_MOVABLE) &#123;</span><br><span class="line">			page = rmqueue_pcplist(preferred_zone, zone, order,</span><br><span class="line">					gfp_flags, migratetype, alloc_flags);</span><br><span class="line">            <span class="comment">//直接使用 per_cpu_lists 分配</span></span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 我们绝不希望 callers 尝试</span></span><br><span class="line"><span class="comment">	 * 在带有 __GFP_NOFAIL 时分配大于 order-1 的页</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; <span class="number">1</span>));</span><br><span class="line">	spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		page = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 若由于非CMA的分配上下文导致略过了 pcplist，则order-0 的请求可以到达此处.</span></span><br><span class="line"><span class="comment">		 * HIGHATOMIC 区域为更高 order 的原子分配所保留，</span></span><br><span class="line"><span class="comment">		 * 故 order-0 的请求应略过它。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (order &gt; <span class="number">0</span> &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123;<span class="comment">//尽力分配,则从MIGRATE_HIGHATOMIC所预留的空间分配</span></span><br><span class="line">			page = __rmqueue_smallest(zone, order, 	MIGRATE_HIGHATOMIC);</span><br><span class="line">			<span class="keyword">if</span> (page)</span><br><span class="line">				trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!page)</span><br><span class="line">			page = __rmqueue(zone, order, migratetype, alloc_flags);<span class="comment">//核心分配函数</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (page &amp;&amp; check_new_pages(page, order));</span><br><span class="line">	<span class="keyword">if</span> (!page)</span><br><span class="line">		<span class="keyword">goto</span> failed;</span><br><span class="line">	<span class="comment">//更新zone freepage状态</span></span><br><span class="line">	__mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">				  get_pcppage_migratetype(page));</span><br><span class="line">	spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span> &lt;&lt; order);</span><br><span class="line">	zone_statistics(preferred_zone, zone, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/* Separate test+clear to avoid unnecessary atomics */</span></span><br><span class="line">	<span class="keyword">if</span> (test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags)) &#123;</span><br><span class="line">		clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);</span><br><span class="line">		wakeup_kswapd(zone, <span class="number">0</span>, <span class="number">0</span>, zone_idx(zone));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">	spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在较早期的版本中是   <code>likely(order ==0)</code> ，直接判断当前阶是否是0来选择是否由per cpu lists 分配</p>
<p>而在此版本中已经是 <code>if (likely(pcp_allowed_order(order)))</code>，per cpu list分配已经支持更多order的链表了，具体的</p>
<p>，order&lt;&#x3D;3 时都会用pcp的方式分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_ALLOC_COSTLY_ORDER 3</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">pcp_allowed_order</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (order &lt;= PAGE_ALLOC_COSTLY_ORDER)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">	<span class="keyword">if</span> (order == pageblock_order)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数流程图 偷的</p>
</blockquote>
<p><img src="https://pic3.zhimg.com/80/v2-eaebb1833771f7b18bc16f7569b88bb6_720w.webp" alt="img"></p>
<h5 id="rmqueue-pcplist"><a href="#rmqueue-pcplist" class="headerlink" title="rmqueue_pcplist"></a>rmqueue_pcplist</h5><p>使用 per_cpu_lists 分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">rmqueue_pcplist</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">			<span class="type">gfp_t</span> gfp_flags, <span class="type">int</span> migratetype,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	local_lock_irqsave(&amp;pagesets.lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On allocation, reduce the number of pages that are batch freed.</span></span><br><span class="line"><span class="comment">	 * See nr_pcp_free() where free_factor is increased for subsequent</span></span><br><span class="line"><span class="comment">	 * frees.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	pcp = this_cpu_ptr(zone-&gt;per_cpu_pageset);</span><br><span class="line">	pcp-&gt;free_factor &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">list</span> = &amp;pcp-&gt;lists[order_to_pindex(migratetype, order)];<span class="comment">//选择list</span></span><br><span class="line">	page = __rmqueue_pcplist(zone, order, migratetype, alloc_flags, pcp, <span class="built_in">list</span>);</span><br><span class="line">	local_unlock_irqrestore(&amp;pagesets.lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (page) &#123;</span><br><span class="line">		__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span>);</span><br><span class="line">		zone_statistics(preferred_zone, zone, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要就是为调用__rmqueue_pcplist做准备，即根据order来选择相应的pcp_list</p>
<h5 id="rmqueue-pcplist-1"><a href="#rmqueue-pcplist-1" class="headerlink" title="__rmqueue_pcplist()"></a>__rmqueue_pcplist()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_pcplist</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">			<span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class">			<span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class">			<span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>,</span></span><br><span class="line"><span class="class">			<span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;<span class="comment">//大循环寻找内存块</span></span><br><span class="line">		<span class="keyword">if</span> (list_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">			<span class="type">int</span> batch = READ_ONCE(pcp-&gt;batch);</span><br><span class="line">			<span class="type">int</span> alloced;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 如果请求意味着空闲页面可以存储在 PCP 上，则相对于请求缩放批次。 对于小区域或引导页面集，Batch 可以是 1，因为这些页面可能属于任意区域，所以它们不应该存储空闲页面。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (batch &gt; <span class="number">1</span>)</span><br><span class="line">				batch = max(batch &gt;&gt; order, <span class="number">2</span>);</span><br><span class="line">			alloced = rmqueue_bulk(zone, order,</span><br><span class="line">					batch, <span class="built_in">list</span>,</span><br><span class="line">					migratetype, alloc_flags);</span><br><span class="line"></span><br><span class="line">			pcp-&gt;count += alloced &lt;&lt; order;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(list_empty(<span class="built_in">list</span>)))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		page = list_first_entry(<span class="built_in">list</span>, <span class="keyword">struct</span> page, lru);<span class="comment">//unlink 脱链</span></span><br><span class="line">		list_del(&amp;page-&gt;lru);</span><br><span class="line">		pcp-&gt;count -= <span class="number">1</span> &lt;&lt; order;<span class="comment">//减小的是空闲页数 而不是块</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (check_new_pcp(page));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果list为空，则会调用rmqueue_bulk() 来申请page填充到list</p>
<h5 id="rmqueue-bulk-："><a href="#rmqueue-bulk-：" class="headerlink" title="rmqueue_bulk()："></a>rmqueue_bulk()：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为了高效率，从 buddy 分配器获得指定数量的元素, </span></span><br><span class="line"><span class="comment"> * 所有的单个元素都在持有锁的情况下进行.  将其添加到提供的链表中.</span></span><br><span class="line"><span class="comment"> * 返回放置在 *list 链表上的 pages 数量.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rmqueue_bulk</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> count, <span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span><br><span class="line"><span class="params">			<span class="type">int</span> migratetype, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, allocated = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * local_lock_irq held so equivalent to spin_lock_irqsave for</span></span><br><span class="line"><span class="comment">	 * both PREEMPT_RT and non-PREEMPT_RT configurations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	spin_lock(&amp;zone-&gt;lock);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> __rmqueue(zone, order, migratetype,</span><br><span class="line">								alloc_flags);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(page == <span class="literal">NULL</span>))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(check_pcp_refill(page)))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 由 expand() 返回的分割 buddy 页面在此处以物理页框顺序接收。</span></span><br><span class="line"><span class="comment">		 * 页面被添加到 caller 的链表尾部。从 caller 的角度看，链表在</span></span><br><span class="line"><span class="comment">		 * 某些情况下是按照页码排序的。这对一些可以从头部前向的IO设备是有用的，</span></span><br><span class="line"><span class="comment">		 * 因为链表也是在物理页的顺序上的。这对于可以在物理页合理排序的情况下</span></span><br><span class="line"><span class="comment">		 * 合并IO请求的IO设备是有用的。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		list_add_tail(&amp;page-&gt;lru, <span class="built_in">list</span>);</span><br><span class="line">		allocated++;</span><br><span class="line">		<span class="keyword">if</span> (is_migrate_cma(get_pcppage_migratetype(page)))</span><br><span class="line">			__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,</span><br><span class="line">					      -(<span class="number">1</span> &lt;&lt; order));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* i 页面已从好友列表中删除，即使由于一些泄漏</span></span><br><span class="line"><span class="comment">	* 到 check_pcp_refill 失败所以调整基于 NR_FREE_PAGES</span></span><br><span class="line"><span class="comment">	* 在 i 上。 不要与 &#x27;allocated&#x27; 混淆，后者是</span></span><br><span class="line"><span class="comment">	* 添加到 pcp 列表的页面。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__mod_zone_page_state(zone, NR_FREE_PAGES, -(i &lt;&lt; order));</span><br><span class="line">	spin_unlock(&amp;zone-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span> allocated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是申请page，内部也调用了__rmqueue()</p>
<h5 id="rmqueue-smallest"><a href="#rmqueue-smallest" class="headerlink" title="__rmqueue_smallest()"></a>__rmqueue_smallest()</h5><p>这个函数就是伙伴算法的核心实现了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_smallest</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">						<span class="title">int</span> <span class="title">migratetype</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> current_order;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find a page of the appropriate size in the preferred list */</span></span><br><span class="line">	<span class="keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;</span><br><span class="line">		area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">		page = get_page_from_free_area(area, migratetype);<span class="comment">//从指定迁移类型的list中找到page，如果失败，则寻找的order++;</span></span><br><span class="line">		<span class="keyword">if</span> (!page)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		del_page_from_free_list(page, zone, current_order);<span class="comment">//负责将其list中拿走，操作包括list_del，list的计数--等;</span></span><br><span class="line">		expand(zone, page, order, current_order, migratetype);<span class="comment">//负责拆分的函数，即如果从odrer较大的list中选择了一一组page进行拆分，那么拆分后剩余的page将被添加到较低order的list中</span></span><br><span class="line">		set_pcppage_migratetype(page, migratetype);</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>十分精简的函数，就是遍历所有order链表，直至找到合适的page,由于上面讲过算法思想了，所以此函数十分好理解</p>
<p>最后此函数返回合适的page，这就是整个分配流程了（其实还有个慢分配路径没看，先坑了…</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static inline struct page *</span><br><span class="line">__alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,</span><br><span class="line">						struct alloc_context *ac)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>待补</p>
</blockquote>
<h4 id="回收："><a href="#回收：" class="headerlink" title="回收："></a>回收：</h4><ul>
<li>当我们释放内存块时把它挂到相应的空闲链表上，查询其伙伴是否在其空闲链表上(1)<ul>
<li>不在，退出</li>
<li>在，合并成两倍大小的块，挂在下一个链表上<ul>
<li>对该两倍大小的块进行递归查询，即重复执行(1)，直至没有伙伴为止</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>类似这样的图例</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/20140614202745343" alt="img"></p>
<blockquote>
<p>from <a target="_blank" rel="noopener" href="https://www.cnblogs.com/alantu2018/p/8527821.html">https://www.cnblogs.com/alantu2018/p/8527821.html</a></p>
<p>1.此时，如果有一个程序A想要申请一块45K大小的内存，则系统会将第一块64K的内存块分配给该程序（产生内部碎片为代价），如图b所示；</p>
<p>2.然后程序B向系统申请一块68K大小的内存，系统会将128K内存分配给该程序，如图c所示；</p>
<p>3.接下来，程序C要申请一块大小为35K的内存。系统将空闲的64K内存分配给该程序，如图d所示；</p>
<p>4.之后程序D需要一块大小为90K的内存。当程序提出申请时，系统本该分配给程序D一块128K大小的内存，但此时内存中已经没有空闲的128K内存块了，于是根据伙伴算法的原理，系统会将256K大小的内存块平分，将其中一块分配给程序D，另一块作为空闲内存块保留，等待以后使用，如图e所示；</p>
<p>5.紧接着，程序C释放了它申请的64K内存。在内存释放的同时，系统还负责检查与之相邻并且同样大小的内存是否也空闲，由于此时程序A并没有释放它的内存，所以系统只会将程序C的64K内存回收，如图f所示；</p>
<p>6.然后程序A也释放掉由它申请的64K内存，系统随机发现与之相邻且大小相同的一段内存块恰好也处于空闲状态。于是，将两者合并成128K内存，如图g所示；</p>
<p>7.之后程序B释放掉它的128k，系统也将这块内存与相邻的128K内存合并成256K的空闲内存，如图h所示；</p>
<p>8.最后程序D也释放掉它的内存，经过三次合并后，系统得到了一块1024K的完整内存。</p>
</blockquote>
<p>回收函数相对就简单很多</p>
<p>主要流程</p>
<ul>
<li><p>free_pages</p>
<ul>
<li><p>__free_pages</p>
<ul>
<li><p>free_the_page</p>
<ul>
<li><p>__free_pages_ok</p>
</li>
<li><p>free_one_page</p>
</li>
<li><p>free_unref_page</p>
<ul>
<li><p>free_one_page</p>
<ul>
<li>free_one_page</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="free-pages"><a href="#free-pages" class="headerlink" title="__free_pages"></a>__free_pages</h5><p>主函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __free_pages(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">int</span> order)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (put_page_testzero(page))</span><br><span class="line">		free_the_page(page, order);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!PageHead(page))</span><br><span class="line">		<span class="keyword">while</span> (order-- &gt; <span class="number">0</span>)</span><br><span class="line">			free_the_page(page + (<span class="number">1</span> &lt;&lt; order), order);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__free_pages);</span><br></pre></td></tr></table></figure>

<h5 id="free-the-page"><a href="#free-the-page" class="headerlink" title="free_the_page"></a>free_the_page</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">free_the_page</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pcp_allowed_order(order))		<span class="comment">/* 通过pcp 分配 */</span></span><br><span class="line">		free_unref_page(page, order);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__free_pages_ok(page, order, FPI_NONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="free-unref-page"><a href="#free-unref-page" class="headerlink" title="free_unref_page"></a>free_unref_page</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_unref_page</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pfn = page_to_pfn(page);</span><br><span class="line">	<span class="type">int</span> migratetype;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!free_unref_page_prepare(page, pfn, order))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 我们只跟踪 pcp 列表上的不可移动、可回收和可移动。</span></span><br><span class="line"><span class="comment">	* 将 ISOLATE 页面放在隔离列表中，因为它们正在</span></span><br><span class="line"><span class="comment">	* 已离线，但将 HIGHATOMIC 视为可移动页面，以便我们可以获取这些页面</span></span><br><span class="line"><span class="comment">	* 必要时返回区域。 否则，我们可能不得不释放</span></span><br><span class="line"><span class="comment">	* 过度进入页面分配器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	migratetype = get_pcppage_migratetype(page);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(migratetype &gt;= MIGRATE_PCPTYPES)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(is_migrate_isolate(migratetype))) &#123;</span><br><span class="line">			free_one_page(page_zone(page), page, pfn, order, migratetype, FPI_NONE);</span><br><span class="line">            <span class="comment">//核心free函数</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		migratetype = MIGRATE_MOVABLE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//free 后的处理</span></span><br><span class="line">	local_lock_irqsave(&amp;pagesets.lock, flags);</span><br><span class="line">	free_unref_page_commit(page, pfn, migratetype, order);</span><br><span class="line">	local_unlock_irqrestore(&amp;pagesets.lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="free-unref-page-commit"><a href="#free-unref-page-commit" class="headerlink" title="free_unref_page_commit"></a>free_unref_page_commit</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_unref_page_commit</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">long</span> pfn,</span></span><br><span class="line"><span class="params">				   <span class="type">int</span> migratetype, <span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span> =</span> page_zone(page);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>;</span></span><br><span class="line">	<span class="type">int</span> high;</span><br><span class="line">	<span class="type">int</span> pindex;</span><br><span class="line"></span><br><span class="line">	__count_vm_event(PGFREE);</span><br><span class="line">	pcp = this_cpu_ptr(zone-&gt;per_cpu_pageset);</span><br><span class="line">	pindex = order_to_pindex(migratetype, order);</span><br><span class="line">	list_add(&amp;page-&gt;lru, &amp;pcp-&gt;lists[pindex]); <span class="comment">//将page插入pcp链表头</span></span><br><span class="line">	pcp-&gt;count += <span class="number">1</span> &lt;&lt; order;</span><br><span class="line">	high = nr_pcp_high(pcp, zone);</span><br><span class="line">	<span class="keyword">if</span> (pcp-&gt;count &gt;= high) &#123;</span><br><span class="line">		<span class="type">int</span> batch = READ_ONCE(pcp-&gt;batch);</span><br><span class="line">		free_pcppages_bulk(zone, nr_pcp_free(pcp, high, batch), pcp);</span><br><span class="line">        <span class="comment">//如果pcp中page的数量大于了node中pcp page最大数量，则将多余的page放入buddy system中</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在早期的版本中，是在本函数调用的free_one_page</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free_one_page(zone, page, pfn, 0, migratetype, FPI_NONE);</span><br></pre></td></tr></table></figure>

<h5 id="free-one-page"><a href="#free-one-page" class="headerlink" title="free_one_page"></a>free_one_page</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_one_page</span><span class="params">(<span class="keyword">struct</span> zone *zone,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">long</span> pfn,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">				<span class="type">int</span> migratetype, <span class="type">fpi_t</span> fpi_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(has_isolate_pageblock(zone) ||</span><br><span class="line">		is_migrate_isolate(migratetype))) &#123;</span><br><span class="line">		migratetype = get_pfnblock_migratetype(page, pfn);</span><br><span class="line">	&#125;</span><br><span class="line">	__free_one_page(page, pfn, zone, order, migratetype, fpi_flags);</span><br><span class="line">	spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>封装了__free_one_page,主要是判断迁移类型等</p>
<h5 id="free-one-page-1"><a href="#free-one-page-1" class="headerlink" title="__free_one_page"></a>__free_one_page</h5><p>核心处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放伙伴系统分配器的功能。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * buddy system 的想法是为多种“orders”的内存块</span></span><br><span class="line"><span class="comment"> * 维护一个直接映射表（包含位值）. 底部级别的表包含</span></span><br><span class="line"><span class="comment"> * 对最小的可分配内存单元（这里便是页面）的映射,</span></span><br><span class="line"><span class="comment"> * 而往上每更高一级则描述了从其下的一级的一对单元，因此是&quot;buddies&quot;.</span></span><br><span class="line"><span class="comment"> * 从高层看，这里所做的仅是在标记底层可用的表项，</span></span><br><span class="line"><span class="comment"> * 并根据需要向上传播更改，再加上一些与 VM 系统的其他部分</span></span><br><span class="line"><span class="comment"> * 良好协作所需要的计数。</span></span><br><span class="line"><span class="comment"> * 在每个级别, 我们都保持一个 pages 的 list, 作为连续的</span></span><br><span class="line"><span class="comment"> * 长度为(1 &lt;&lt; order)的空闲页的头节点并标记上 PageBuddy.</span></span><br><span class="line"><span class="comment"> * Page&#x27;s order 被记录在 page_private(page) 域.</span></span><br><span class="line"><span class="comment"> * 故当我们在分配或释放其一时, 我们可以得到另一个的状态。</span></span><br><span class="line"><span class="comment"> * 也就是说，若我们分配一个小的块，而两个都是空闲的，</span></span><br><span class="line"><span class="comment"> * 区域的剩余部分必须被分割成块. 若一个块被释放了，</span></span><br><span class="line"><span class="comment"> * 而他的 buddy 也是闲置的, 那么这将触发合并成一个更大的块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -- nyc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __free_one_page(<span class="keyword">struct</span> page *page,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> pfn,</span><br><span class="line">		<span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span><br><span class="line">		<span class="type">int</span> migratetype, <span class="type">fpi_t</span> fpi_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capture_control</span> *<span class="title">capc</span> =</span> task_capc(zone);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> buddy_pfn;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> combined_pfn;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_order;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">buddy</span>;</span></span><br><span class="line">	<span class="type">bool</span> to_tail;</span><br><span class="line">	<span class="comment">//获取最大order</span></span><br><span class="line">	max_order = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>, MAX_ORDER - <span class="number">1</span>, pageblock_order);</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(!zone_is_initialized(zone));</span><br><span class="line">	VM_BUG_ON_PAGE(page-&gt;flags &amp; PAGE_FLAGS_CHECK_AT_PREP, page);</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(migratetype == <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (likely(!is_migrate_isolate(migratetype)))</span><br><span class="line">		__mod_zone_freepage_state(zone, <span class="number">1</span> &lt;&lt; order, migratetype);</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON_PAGE(pfn &amp; ((<span class="number">1</span> &lt;&lt; order) - <span class="number">1</span>), page);</span><br><span class="line">	VM_BUG_ON_PAGE(bad_range(zone, page), page);</span><br><span class="line"></span><br><span class="line">continue_merging:</span><br><span class="line">	<span class="keyword">while</span> (order &lt; max_order) &#123;</span><br><span class="line">		<span class="keyword">if</span> (compaction_capture(capc, page, order, migratetype)) &#123;</span><br><span class="line">			__mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">								migratetype);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		buddy_pfn = __find_buddy_pfn(pfn, order);<span class="comment">//页框号</span></span><br><span class="line">		buddy = page + (buddy_pfn - pfn);<span class="comment">//page结构体</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!page_is_buddy(page, buddy, order))<span class="comment">//判断是否是伙伴</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1.page与buddy在同一个zone</span></span><br><span class="line"><span class="comment">            2.page与buddy在同一个order</span></span><br><span class="line"><span class="comment">            3.page与buddy都在buddy system中</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">			<span class="keyword">goto</span> done_merging;<span class="comment">//是伙伴的话就去合并，不是的话就不需要merge</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		buddy(被释放页的伙伴)是空闲的或是 CONFIG_DEBUG_PAGEALLOC 保护的页,</span></span><br><span class="line"><span class="comment">		合并它，并放在更大的order链表中</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (page_is_guard(buddy))</span><br><span class="line">			clear_page_guard(zone, buddy, order, migratetype);<span class="comment">//清除保护</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			del_page_from_free_list(buddy, zone, order);<span class="comment">//unlink buddy</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//合并 重置新的pfn</span></span><br><span class="line">		combined_pfn = buddy_pfn &amp; pfn;</span><br><span class="line">		page = page + (combined_pfn - pfn);</span><br><span class="line">		pfn = combined_pfn;</span><br><span class="line">		order++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (order &lt; MAX_ORDER - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		如果我们在这里，则意味着 order &gt;= pageblock_order。</span></span><br><span class="line"><span class="comment">		我们希望防止隔离页块和普通页块上的空闲页合并。 如果没有这个，页块隔离可能会导致不正确的 freepage 或 CMA 记数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		我们不想为更频繁的低阶合并而点击此代码。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(has_isolate_pageblock(zone))) &#123;</span><br><span class="line">			<span class="type">int</span> buddy_mt;</span><br><span class="line"></span><br><span class="line">			buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line">			buddy = page + (buddy_pfn - pfn);</span><br><span class="line">			buddy_mt = get_pageblock_migratetype(buddy);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (migratetype != buddy_mt</span><br><span class="line">					&amp;&amp; (is_migrate_isolate(migratetype) ||</span><br><span class="line">						is_migrate_isolate(buddy_mt)))</span><br><span class="line">				<span class="keyword">goto</span> done_merging;</span><br><span class="line">		&#125;</span><br><span class="line">		max_order = order + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">goto</span> continue_merging;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done_merging:</span><br><span class="line">    <span class="comment">//设置order，同时标记为buddy system 的 page</span></span><br><span class="line">	set_buddy_order(page, order);</span><br><span class="line">    <span class="comment">// 判断free page该插入链表头还是尾</span></span><br><span class="line">	<span class="keyword">if</span> (fpi_flags &amp; FPI_TO_TAIL)</span><br><span class="line">		to_tail = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (is_shuffle_order(order))</span><br><span class="line">		to_tail = shuffle_pick_tail();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        <span class="comment">//检查下一个最高阶的buddy 是否空闲</span></span><br><span class="line">        <span class="comment">//如果是空闲的，那么free page可能很快被合并，加入尾部 方便合并</span></span><br><span class="line">		to_tail = buddy_merge_likely(pfn, buddy_pfn, page, order);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (to_tail)</span><br><span class="line">		add_to_free_list_tail(page, zone, order, migratetype);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		add_to_free_list(page, zone, order, migratetype);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Notify page reporting subsystem of freed page */</span></span><br><span class="line">	<span class="keyword">if</span> (!(fpi_flags &amp; FPI_SKIP_REPORT_NOTIFY))</span><br><span class="line">		page_reporting_notify_free(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Buddy_memory_allocation">https://en.wikipedia.org/wiki/Buddy_memory_allocation</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1518174">https://cloud.tencent.com/developer/article/1518174</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/502525143">https://zhuanlan.zhihu.com/p/502525143</a></p>
<p><a target="_blank" rel="noopener" href="https://arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/">https://arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269149.htm#msg_header_h3_12">https://bbs.pediy.com/thread-269149.htm#msg_header_h3_12</a></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>7r1p13J</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"># 内存管理</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/11/20/ebpf/">ebpf初探</a>
            
            
            <a class="next" rel="next" href="/2022/11/17/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Linux内存管理分析</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 7r1p13J | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>