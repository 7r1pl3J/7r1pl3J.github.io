<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="7r1p13J">





<title>slab源码阅读 | Hexo</title>



    <link rel="icon" href="/github-11-48.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">7r1pl3J&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">7r1pl3J&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">slab源码阅读</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">7r1p13J</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">November 24, 2022&nbsp;&nbsp;10:28:05</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/kernel/">kernel</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="slab分配器"><a href="#slab分配器" class="headerlink" title="slab分配器"></a>slab分配器</h1><h2 id="在一切开始之前"><a href="#在一切开始之前" class="headerlink" title="在一切开始之前"></a>在一切开始之前</h2><p>buddy system 只能做到按page_size 为粒度的内存分配，更加细小的内存分配使用slab分配器来实现，与申请页大小的大内存一样，slab分配器也是从页框分配器申请页框的</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/thdeg3ih7d.jpeg" alt="img"></p>
<p>另外还有一个比较形象的图，但是比较乱：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/v2-25c225837eaa6048d9d906cf225bd572_r.jpg" alt="img"></p>
<h3 id="slab分配器历史"><a href="#slab分配器历史" class="headerlink" title="slab分配器历史"></a>slab分配器历史</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/490588193">https://zhuanlan.zhihu.com/p/490588193</a></p>
</blockquote>
<p>slab的实现最早出现在<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Solaris_(operating_system)">Solaris</a> 2.4版本，以Sun公司研究员Jeff Bonwick发表的论文<a href="https://link.zhihu.com/?target=https://people.eecs.berkeley.edu/~kubitron/courses/cs194-24-S13/hand-outs/bonwick_slab.pdf">《The Slab Allocator: An Object-Caching Kernel Memory Allocator》</a>为雏形发展而来，现在已经在Unix和类Unix系统广泛使用了。slab的出现旨在解决以下两个问题：</p>
<ol>
<li>内存利用率低。正如前面提到的，如果只需要分配几个字节，如果只使用伙伴系统，则至少要分配一个页面，浪费率达到99.9%；</li>
<li>内存分配效率低和访问时间长。使用伙伴系统，需要走的分配路径很长，遇到内存不足时，还会进行内存压缩或回收。再者，伙伴系统每次至少分配一个页框，访问内存时，容易出现cache miss的情况。使用slab分配的小内存，即使被释放了，还很有可能在cache中，这时候再分配给其他任务使用，效率有较大提升。</li>
</ol>
<p>简单来说，<strong>slab可以认为是进程与伙伴系统之前的中间层</strong></p>
<p>而后面slab分配器也演变出了两种变体，一种是slob，一种是slub</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/20200321065553420.png" alt="https://img-blog.csdnimg.cn/20200321065553420.png"></p>
<p>slab分配器在大多数情况下状态良好，但其需要大量的元数据，对嵌入式系统来说，slab分配器的代码量和复杂性都过高，故开发者在slab的基础上开发了精简版slub分配器，其通过将页帧打包为组，然后再利用page结构中未使用的字段来管理这些组，试图最小化所需管理数据带来的开销。</p>
<p>主要是三点</p>
<p>1、每个node节点有三个链表，分别记录空闲slab、部分空闲slab和非空闲slab。当回收操作来不及时，三个链表记录的页框会较长时间停留到slab管理器中，不利于提高内存的使用率。针对这点，slub只保留了一个链表，就是部分空闲slub。另外就是shared共享链表可能导致一个slab持有较多slab，无法即使释放给伙伴系统。slub去掉了该链表。</p>
<p>2、slab为了增加分配速度，引入了一些管理数组，如每个cpu私有数据记录的是object的地址，这些object可能来自不同的slab，那么不利于slab的回收。slub改成记录一个实际可用的slub，不会影响其他slub的回收。slub分配器摒弃了很多管理数据，大大减小了内存开销。</p>
<p>3、出于对内存使用率的极致追求，slub去除了slab的着色做法，取而代之是slub复用，通过slub复用减轻cache冲突的情况。</p>
<p>而slob主要为小型的嵌入式系统设计，数据结构相对于slab来说比较简单，不会占用太多内存。</p>
<p>slab示意图：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/201012589736211.jpg" alt="img"></p>
<p>slub示意图：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/201027462546707.jpg" alt="img"></p>
<p>通过命令可以查看系统的slab相关信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/slabinfo </span><br></pre></td></tr></table></figure>

<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221124175733003.png" alt="image-20221124175733003"></p>
<h3 id="slab分配器基本原理"><a href="#slab分配器基本原理" class="headerlink" title="slab分配器基本原理"></a>slab分配器基本原理</h3><p>在分析源码之前，由于slab分配器实现较为复杂，故最好能先了解一下其基本原理，非常推荐<a target="_blank" rel="noopener" href="https://blog.csdn.net/lukuen/article/details/6935068?spm=1001.2014.3001.5506">这篇文章</a></p>
<p>以下的阐述也基本摘自此篇文章</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/0_1320653624E37J.gif" alt="img"></p>
<p>​       我们要申请的小内存，就是去申请一个object，object类似buddy system那样，也是有着各种不同大小的object，如kmalloc-16 ，kmalloc-32 等，一个object中有一个指针指向下一个object从而形成链表。</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/0_1320655427Rtw3.gif" alt="img"></p>
<p>我们将连续的整页内存，分成许多大小的object，然后再分别分配出去，这样的连续内存，称为一个slab。</p>
<p>每种不同大小的object由不同的kmem_cache结构体管理，可以将kmem_cache 视为零售商。</p>
<p>kmem_cache 又有两个部门，一个是仓库：kmem_cache_node，一个是营业厅：kmem_cache_cpu，该营业厅只保留一个slab，在没有剩余空闲内存的情况下，从仓库再批发slab换出。</p>
<p>而仓库管理着几个空闲链表，partial链表存访着仍有空闲空间的slab，full链表存放着分配完的slab。</p>
<p>kmem_cache_cpu的freelist变量中保存着下一个空闲object的地址</p>
<p>slab满换出的过程：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/0_1320657740tVXE.gif" alt="img"></p>
<p>申请一个object之后</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/0_1320656462HV6O.gif" alt="img"></p>
<p>当full的slab中有object被释放时，该slab就被放入partial链表用于再次分配</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/0_1320658245nPBk.gif" alt="img"></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/0_1320658279T6Lw.gif" alt="img"></p>
<p>当所有slab被分配完时，再从buddy system申请slab 并初始化</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/0_1320657914wZW2.gif" alt="img"></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/0_1320657952F10f.gif" alt="img"></p>
<blockquote>
<p>非常形象了，我也不好意思抄太多，不懂的建议看原文。</p>
</blockquote>
<h2 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h2><p>以下源码都出自v5.17的slub分配器，所以跟上面图的流程会有些小区别</p>
<p><strong>kmem_cache</strong> 定义于 <code>/include/linux/slub_def.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab cache management.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span> <span class="comment">//各cpu主要用于分配的slab 即前面所说的“营业厅”</span></span><br><span class="line">  	<span class="comment">//对于每个CPU都有一个本地的缓冲池，当分配Object的时候优先从per-cpu中分配</span></span><br><span class="line">	<span class="comment">/* Used for retrieving partial slabs, etc. */</span></span><br><span class="line">	<span class="type">slab_flags_t</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> min_partial; <span class="comment">// partital链表中最小的object个数，object个数应保持不低于这个值</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size;	<span class="comment">/* object size 包含元数据 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> object_size;<span class="comment">/* object size 不包含元数据 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reciprocal_value</span> <span class="title">reciprocal_size</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset;	<span class="comment">/* object指针的偏移，通过这个偏移可以找到下一个object的地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">	<span class="comment">/*  per cpu partial objects 的数量 */</span> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> cpu_partial;</span><br><span class="line">	<span class="comment">/* cpuslab partial链表中slab的最大数量 若超过则放入node中的普通partial链表 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> cpu_partial_slabs;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span><span class="comment">//分配给slab的页帧的阶数（高16位，也就是buddy system的order） </span></span><br><span class="line">                                       <span class="comment">//slab中的object数量（低16位）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">max</span>;</span><span class="comment">//最大分配数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span><span class="comment">//最小分配数</span></span><br><span class="line">	<span class="type">gfp_t</span> allocflags;	<span class="comment">/* 页帧gfp标志 */</span></span><br><span class="line">	<span class="type">int</span> refcount;		<span class="comment">/* </span></span><br><span class="line"><span class="comment">		一个缓存被引用的次数</span></span><br><span class="line"><span class="comment">    	当创建一个新缓存时，会首先搜索已存在缓存，查看是否存在大小相近，标志位相符的，如果符合，可以复用该已存在缓存 </span></span><br><span class="line"><span class="comment">    	若为-1，则代表不可复用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="type">void</span> (*ctor)(<span class="type">void</span> *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> inuse;		<span class="comment">/* 已经使用的object个数（?） */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> align;		<span class="comment">/* 对齐用的 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> red_left_pad;	<span class="comment">/* Left redzone padding size */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;	<span class="comment">/* 用于显示的缓存名 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>	<span class="comment">/* slab_caches链表 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>	<span class="comment">/* For sysfs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> random;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Defragmentation by allocating from a remote node.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> remote_node_defrag_ratio;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *random_seq;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kasan_cache</span> <span class="title">kasan_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> useroffset;	<span class="comment">/* Usercopy region offset */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> usersize;		<span class="comment">/* Usercopy region size */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span><span class="comment">//各个node节点的私有slab，UMA架构的话就只有一个</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>kmem_cache_cpu</strong> 定义于 <code>/include/linux/slub_def.h</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When changing the layout, make sure freelist and tid are still compatible</span></span><br><span class="line"><span class="comment"> * with this_cpu_cmpxchg_double() alignment requirements.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> **freelist;	<span class="comment">/* 指向下一个可用的object对象 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tid;	<span class="comment">/* cpu 标识 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span>	<span class="comment">/* 准备分配的slab */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">partial</span>;</span>	<span class="comment">/* partial 链表，其中的slab有空闲object */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">local_lock_t</span> lock;	<span class="comment">/* Protects the fields above */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line">	<span class="type">unsigned</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>kmem_cache_node</strong>定义于 <code>/mm/slab.h</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">	<span class="type">spinlock_t</span> list_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span>	<span class="comment">/* partial list first, better asm code */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> total_slabs;	<span class="comment">/* length of all slab lists */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> free_slabs;	<span class="comment">/* length of free slab list only */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> free_objects;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> free_limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> colour_next;	<span class="comment">/* Per-node cache coloring */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">shared</span>;</span>	<span class="comment">/* shared per node */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">alien_cache</span> **<span class="title">alien</span>;</span>	<span class="comment">/* on other nodes */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> next_reap;	<span class="comment">/* updated without locking */</span></span><br><span class="line">	<span class="type">int</span> free_touched;		<span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr_partial; <span class="comment">//partial 链表中 slab 的数量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span> <span class="comment">//当前节点的partial链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="type">atomic_long_t</span> nr_slabs;</span><br><span class="line">	<span class="type">atomic_long_t</span> total_objects;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">full</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从这里也可以看出 slub 相比于 slab ，减少了相当多的管理结构，取消了着色，链表也只保留了partial</p>
<p><strong>slab</strong>结构体定义于 <code>/mm/slab.h</code></p>
<p>早期版本的slab结构体集成在struct page中，在今年一月份的一次commit中将它单独定义了</p>
<p>我阅读的5.17版本的源码中却没有，查看了commit，发现在一月的时候有了这样的改动</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221103201437873.png" alt="image-20221103201437873"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mm: Remove slab from struct page</span><br><span class="line">All members of struct slab can now be removed from struct page.</span><br><span class="line">This shrinks the definition of struct page by 30 LOC, making</span><br><span class="line">it easier to understand.</span><br></pre></td></tr></table></figure>

<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221103201511781.png" alt="image-20221103201511781"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> __page_flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SLAB)</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line">	<span class="type">void</span> *freelist;	<span class="comment">/* array of free object indexes */</span></span><br><span class="line">	<span class="type">void</span> *s_mem;	<span class="comment">/* first object */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> active;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SLUB)</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span>  <span class="comment">//slab链表</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span> <span class="comment">//与RCU机制相关</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">next</span>;</span></span><br><span class="line">			<span class="type">int</span> slabs;	<span class="comment">/* Nr of slabs left */</span></span><br><span class="line">		&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line">	<span class="comment">/* Double-word boundary */</span></span><br><span class="line">	<span class="type">void</span> *freelist;		<span class="comment">//指向第一个空object（本slab的），这与cache_cpu的freelist不同</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="type">unsigned</span> inuse:<span class="number">16</span>;	<span class="comment">//有多少object正在被使用 </span></span><br><span class="line">			<span class="type">unsigned</span> objects:<span class="number">15</span>;<span class="comment">//object总对象数</span></span><br><span class="line">			<span class="type">unsigned</span> frozen:<span class="number">1</span>;<span class="comment">//是否被冻结（归某个cpu的partial链使用）</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __unused;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SLOB) </span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">	<span class="type">void</span> *__unused_1;</span><br><span class="line">	<span class="type">void</span> freelist;		</span><br><span class="line">	<span class="type">long</span> units;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __unused_2;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unexpected slab allocator configured&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_t</span> __page_refcount;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>和以前版本集成在page中差距并不大</p>
<h3 id="slab-amp-object的创建与初始化"><a href="#slab-amp-object的创建与初始化" class="headerlink" title="slab&amp;object的创建与初始化"></a>slab&amp;object的创建与初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> slab *<span class="title function_">new_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> flags, <span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(flags &amp; GFP_SLAB_BUG_MASK))</span><br><span class="line">		flags = kmalloc_fix_flags(flags);</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(s-&gt;ctor &amp;&amp; (flags &amp; __GFP_ZERO));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> allocate_slab(s,</span><br><span class="line">		flags &amp; (GFP_RECLAIM_MASK | GFP_CONSTRAINT_MASK), node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> slab *<span class="title function_">allocate_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> flags, <span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span> =</span> s-&gt;oo;</span><br><span class="line">	<span class="type">gfp_t</span> alloc_gfp;</span><br><span class="line">	<span class="type">void</span> *start, *p, *next;</span><br><span class="line">	<span class="type">int</span> idx;</span><br><span class="line">	<span class="type">bool</span> shuffle;</span><br><span class="line"></span><br><span class="line">	flags &amp;= gfp_allowed_mask;</span><br><span class="line"></span><br><span class="line">	flags |= s-&gt;allocflags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Let the initial higher-order allocation fail under memory pressure</span></span><br><span class="line"><span class="comment">	 * so we fall-back to the minimum order allocation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	alloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) &amp; ~__GFP_NOFAIL;</span><br><span class="line">	<span class="keyword">if</span> ((alloc_gfp &amp; __GFP_DIRECT_RECLAIM) &amp;&amp; oo_order(oo) &gt; oo_order(s-&gt;min))</span><br><span class="line">		alloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) &amp; ~(__GFP_RECLAIM|__GFP_NOFAIL);</span><br><span class="line"></span><br><span class="line">	slab = alloc_slab_page(s, alloc_gfp, node, oo);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!slab)) &#123;</span><br><span class="line">		oo = s-&gt;min;</span><br><span class="line">		alloc_gfp = flags;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Allocation may have failed due to fragmentation.</span></span><br><span class="line"><span class="comment">		 * Try a lower order alloc if possible</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		slab = alloc_slab_page(s, alloc_gfp, node, oo);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!slab))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		stat(s, ORDER_FALLBACK);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	slab-&gt;objects = oo_objects(oo);</span><br><span class="line"></span><br><span class="line">	account_slab(slab, oo_order(oo), s, flags);</span><br><span class="line"></span><br><span class="line">	slab-&gt;slab_cache = s;</span><br><span class="line"></span><br><span class="line">	kasan_poison_slab(slab);</span><br><span class="line"></span><br><span class="line">	start = slab_address(slab);</span><br><span class="line"></span><br><span class="line">	setup_slab_debug(s, slab, start);</span><br><span class="line"></span><br><span class="line">	shuffle = shuffle_freelist(s, slab);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	shuffle_freelist：</span></span><br><span class="line"><span class="comment">    if (slab-&gt;objects &lt; 2 || !s-&gt;random_seq)</span></span><br><span class="line"><span class="comment">		return false;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">if</span> (!shuffle) &#123;</span><br><span class="line">        <span class="comment">//找到第一个object的地址</span></span><br><span class="line">		start = fixup_red_left(s, start);</span><br><span class="line">		start = setup_object(s, slab, start);</span><br><span class="line">		slab-&gt;freelist = start;<span class="comment">//freelist指向第一个object</span></span><br><span class="line">        <span class="comment">//从第一个object开始，逐个初始化object链表</span></span><br><span class="line">		<span class="keyword">for</span> (idx = <span class="number">0</span>, p = start; idx &lt; slab-&gt;objects - <span class="number">1</span>; idx++) &#123;</span><br><span class="line">			next = p + s-&gt;size;<span class="comment">//kmem_cache所存的object size（包含元数据）</span></span><br><span class="line">			next = setup_object(s, slab, next);</span><br><span class="line">			set_freepointer(s, p, next);</span><br><span class="line">			p = next;</span><br><span class="line">		&#125;</span><br><span class="line">		set_freepointer(s, p, <span class="literal">NULL</span>);<span class="comment">//最后一个object的指针为NULL</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	slab-&gt;inuse = slab-&gt;objects;</span><br><span class="line">	slab-&gt;frozen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (!slab)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	inc_slabs_node(s, slab_nid(slab), slab-&gt;objects);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">setup_object</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab,</span></span><br><span class="line"><span class="params">				<span class="type">void</span> *object)</span></span><br><span class="line">&#123;</span><br><span class="line">	setup_object_debug(s, slab, object);</span><br><span class="line">	object = kasan_init_slab_obj(s, object);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(s-&gt;ctor)) &#123;</span><br><span class="line">		kasan_unpoison_object_data(s, object);</span><br><span class="line">		s-&gt;ctor(object);</span><br><span class="line">		kasan_poison_object_data(s, object);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个时候我们就可以画出个大概的图👀</p>
<p>l<img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221125215451571.png" alt="image-20221125215451571"></p>
<h2 id="申请object"><a href="#申请object" class="headerlink" title="申请object"></a>申请object</h2><p>slab申请和释放的入口  kmem_cache_alloc 与 kmem_cache_free</p>
<blockquote>
<p>如果我们去查看kmalloc源码 会发现其调用链为 kmalloc-&gt;__kmalloc -&gt;  kmalloc_slab -&gt;slab_alloc -&gt;slab_alloc_node </p>
<p>底层函数都是一样的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define allocate_mm()	(kmem_cache_alloc(mm_cachep, GFP_KERNEL))</span><br><span class="line">#define free_mm(mm)	(kmem_cache_free(mm_cachep, (mm)))</span><br></pre></td></tr></table></figure>

<p>kmem_cache_alloc 定义于  <code>/mm/slub.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmem_cache_alloc</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret = slab_alloc(s, gfpflags, _RET_IP_, s-&gt;object_size);</span><br><span class="line"></span><br><span class="line">	trace_kmem_cache_alloc(_RET_IP_, ret, s-&gt;object_size,</span><br><span class="line">				s-&gt;size, gfpflags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slab_alloc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">slab_alloc</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params">		<span class="type">gfp_t</span> gfpflags, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">size_t</span> orig_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr, orig_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slab_alloc_node  (快分配路径)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   内联快速路径，以便分配函数（kmalloc、kmem_cache_alloc）将快速路径折叠到它们的函数中。 因此，对于可以在快速路径上得到满足的请求，没有函数调用开销。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">   快速路径首先检查是否可以使用无锁freelist。</span></span><br><span class="line"><span class="comment">   如果不是，则调用 __slab_alloc 进行慢分配处理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">   否则我们可以简单地从无锁空闲列表中选择下一个对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">slab_alloc_node</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params">		<span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">size_t</span> orig_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *object;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">obj_cgroup</span> *<span class="title">objcg</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">bool</span> init = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	s = slab_pre_alloc_hook(s, &amp;objcg, <span class="number">1</span>, gfpflags);<span class="comment">//预处理的hook函数</span></span><br><span class="line">	<span class="keyword">if</span> (!s)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	object = kfence_alloc(s, orig_size, gfpflags);<span class="comment">//优先使用kfence_alloc 分配,貌似与kfence内存池有关,mark</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(object))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">redo:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 必须通过这个 cpu ptr 读取 kmem_cache cpu 数据。启用抢占。我们可能会在从一个 cpu 区域读取时在 cpus 之间来回切换。只要我们在执行 cmpxchg 时再次使用原始 cpu 就没有关系。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 我们必须保证在同一个 cpu 上检索到 tid 和 kmem_cache_cpu。我们首先读取 kmem_cache_cpu 指针并使用它来读取 tid。如果我们在两次读取之间被抢占并切换到另一个 cpu，那没关系，因为这两个 cpu 仍然与同一个 cpu 关联，稍后 cmpxchg 将验证 cpu。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得当前cpu_slab 与 tid</span></span><br><span class="line">	c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">	tid = READ_ONCE(c-&gt;tid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 这里使用的 Irqless 对象分配/释放算法取决于获取 cpu_slab 数据的顺序。 tid 应该在 c 上的任何内容之前获取，以保证与前一个 tid 关联的对象和 slab 不会与当前 tid 一起使用。如果我们先获取 tid，对象和 slab 可能与下一个 tid 关联，我们的分配/释放请求将失败。在这种情况下，我们将重试。所以，没问题。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//barrier内存屏障 用于保证内存访问按严格的顺序来</span></span><br><span class="line">	barrier();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 每个 cpu 和每个 cpu 队列上的每个操作的事务 ID 是全局唯一的。因此，他们可以保证 cmpxchg_double 出现在正确的处理器上，并且在其间的链表上没有任何操作。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	object = c-&gt;freelist;<span class="comment">//获取当前的第一个free object</span></span><br><span class="line">	slab = c-&gt;slab;<span class="comment">//获取当前的cpu slab</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 我们不能在 PREEMPT_RT 上使用无锁快速路径，因为如果慢速路径已采用 local_lock_irqsave()，则它无法防止 irq 处理程序中的快速路径操作。所以我们需要采取使用local_lock的慢速路径。如果有合适的cpu freelist还是比较快的。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_PREEMPT_RT) ||</span><br><span class="line">        <span class="comment">//当前slab为空或object为空或node与slab不匹配(也就是当前slab不在当前node中)</span></span><br><span class="line">        <span class="comment">//使用 __slab_alloc 慢分配(从 node cache中分配)        </span></span><br><span class="line">	    unlikely(!object || !slab || !node_match(slab, node))) &#123;</span><br><span class="line">		object = __slab_alloc(s, gfpflags, node, addr, c);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//slab不为空且object不为空且node与slab匹配</span></span><br><span class="line">        <span class="comment">//获得当前freelist-&gt;object的下一个object</span></span><br><span class="line">		<span class="type">void</span> *next_object = get_freepointer_safe(s, object);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 cmpxchg 只有在没有额外的操作并且我们在正确的处理器上时才会匹配。 cmpxchg 自动执行以下操作（没有锁定语义！）</span></span><br><span class="line"><span class="comment">         1. 将第一个指针重新定位到当前的每个 cpu 区域。</span></span><br><span class="line"><span class="comment">         2.验证tid和freelist没有变化</span></span><br><span class="line"><span class="comment">         3. 如果没有改变，替换 tid 和 freelist</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 因为这没有锁语义，所以保护只是防止代码在这个 cpu 上执行 * 而不是 * 被其他 cpu 访问。.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">//将freelist-&gt;object 解链, free-list-&gt;object=next_object</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(</span><br><span class="line">				s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,</span><br><span class="line">				object, tid,</span><br><span class="line">				next_object, next_tid(tid)))) &#123;</span><br><span class="line"></span><br><span class="line">			note_cmpxchg_failure(<span class="string">&quot;slab_alloc&quot;</span>, s, tid);</span><br><span class="line">			<span class="keyword">goto</span> redo;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		prefetch_freepointer(s, next_object);<span class="comment">//数据预取</span></span><br><span class="line">		stat(s, ALLOC_FASTPATH);<span class="comment">//状态保存</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	maybe_wipe_obj_freeptr(s, object);<span class="comment">//将object的指针(指向下一个object的)初始化为0 </span></span><br><span class="line">	init = slab_want_init_on_alloc(gfpflags, s);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	slab_post_alloc_hook(s, objcg, gfpflags, <span class="number">1</span>, &amp;object, init);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>__slab_alloc 慢分配路径</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ___slab_alloc() 的包装，用于尚未禁用抢占的上下文。 </span></span><br><span class="line"><span class="comment"> 通过重新获取每个 cpu 区域指针来补偿可能的 cpu 更改。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *__slab_alloc(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="keyword">struct</span> kmem_cache_cpu *c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 在禁用抢占之前，我们可能已经被抢占并重新安排在不同的 cpu 上。 需要重新加载 cpu 区域指针。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	c = slub_get_cpu_ptr(s-&gt;cpu_slab);<span class="comment">//重新获取cpu_slab </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	p = ___slab_alloc(s, gfpflags, node, addr, c);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT_COUNT</span></span><br><span class="line">	slub_put_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装的___slab_alloc函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入条件 当前slab为空或object为空或node与slab不匹配(也就是当前slab不在当前node中)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *___slab_alloc(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="keyword">struct</span> kmem_cache_cpu *c)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *freelist;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_SLOWPATH);</span><br><span class="line"></span><br><span class="line">reread_slab:</span><br><span class="line"></span><br><span class="line">	slab = READ_ONCE(c-&gt;slab);</span><br><span class="line">	<span class="keyword">if</span> (!slab) &#123;<span class="comment">//没有可用的slab 需要申请新slab</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 如果node不在线或者没有正常的内存，忽略node的约束限制</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">			     !node_isset(node, slab_nodes)))</span><br><span class="line">			node = NUMA_NO_NODE;</span><br><span class="line">		<span class="keyword">goto</span> new_slab;</span><br><span class="line">	&#125;</span><br><span class="line">redo:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!node_match(slab, node))) &#123;</span><br><span class="line">        <span class="comment">//node与当前slab不匹配</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * same as above but node_match() being false already</span></span><br><span class="line"><span class="comment">		 * implies node != NUMA_NO_NODE</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!node_isset(node, slab_nodes)) &#123;</span><br><span class="line">			node = NUMA_NO_NODE;</span><br><span class="line">			<span class="keyword">goto</span> redo;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			stat(s, ALLOC_NODE_MISMATCH);</span><br><span class="line">			<span class="keyword">goto</span> deactivate_slab;<span class="comment">// 移除 当前slab</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下为node与当前slab匹配</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 按理说，我们应该搜索 PFMEMALLOC 的 slab 页面，但现在，当页面离开 per-cpu 分配器时，我们正在丢失 pfmemalloc 信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags)))</span><br><span class="line">		<span class="keyword">goto</span> deactivate_slab; <span class="comment">//如果当前slAB是PF_MEMALLOC,调用deactivate_slab</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 必须再次检查 c-&gt;slab 以防我们被抢占并且它发生了变化 */</span></span><br><span class="line">	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123; <span class="comment">//检查slab是否被抢占</span></span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		<span class="keyword">goto</span> reread_slab;</span><br><span class="line">	&#125;</span><br><span class="line">	freelist = c-&gt;freelist;<span class="comment">//获取当前cpu_slab的freelist </span></span><br><span class="line">	<span class="keyword">if</span> (freelist)</span><br><span class="line">		<span class="keyword">goto</span> load_freelist;<span class="comment">// 这里正常来说应该是空(?),不是很懂</span></span><br><span class="line"></span><br><span class="line">	freelist = get_freelist(s, slab);<span class="comment">//重新获取</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!freelist) &#123;</span><br><span class="line">        <span class="comment">//如果freelist-&gt;object为空,slab置空 并去新建slab</span></span><br><span class="line">		c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);<span class="comment">//该slab解锁</span></span><br><span class="line">		stat(s, DEACTIVATE_BYPASS);</span><br><span class="line">		<span class="keyword">goto</span> new_slab;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_REFILL);</span><br><span class="line"></span><br><span class="line">load_freelist:</span><br><span class="line">	<span class="comment">//返回freelist的object,并让freelist指向下一个object</span></span><br><span class="line">	lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 freelist 是指向要使用的object list。</span></span><br><span class="line"><span class="comment">	 slab 是指向从中获取object的slab。 </span></span><br><span class="line"><span class="comment">	 必须冻结该 slab 才能使每个 cpu 分配正常工作。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	VM_BUG_ON(!c-&gt;slab-&gt;frozen);</span><br><span class="line">	c-&gt;freelist = get_freepointer(s, freelist);</span><br><span class="line">	c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">	local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">return</span> freelist;</span><br><span class="line"></span><br><span class="line">deactivate_slab:</span><br><span class="line">	<span class="comment">//移除当前slab</span></span><br><span class="line">	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (slab != c-&gt;slab) &#123;</span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		<span class="keyword">goto</span> reread_slab;</span><br><span class="line">	&#125;</span><br><span class="line">	freelist = c-&gt;freelist;</span><br><span class="line">	c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">	c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">	local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	deactivate_slab(s, slab, freelist);</span><br><span class="line"></span><br><span class="line">new_slab:</span><br><span class="line">	<span class="comment">//获取新的slab</span></span><br><span class="line">	<span class="keyword">if</span> (slub_percpu_partial(c)) &#123;</span><br><span class="line">		local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(c-&gt;slab)) &#123;</span><br><span class="line">			local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">			<span class="keyword">goto</span> reread_slab;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!slub_percpu_partial(c))) &#123;</span><br><span class="line">			local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">			<span class="comment">/* we were preempted and partial list got empty */</span></span><br><span class="line">			<span class="keyword">goto</span> new_objects;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		slab = c-&gt;slab = slub_percpu_partial(c);<span class="comment">//从partial链表中获取slab</span></span><br><span class="line">		slub_set_percpu_partial(c, slab);</span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		stat(s, CPU_PARTIAL_ALLOC);<span class="comment">//记录</span></span><br><span class="line">		<span class="keyword">goto</span> redo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">new_objects:</span><br><span class="line">	<span class="comment">//尝试从kmem_cache_node的partial链表中分配page</span></span><br><span class="line">	freelist = get_partial(s, gfpflags, node, &amp;slab);</span><br><span class="line">	<span class="keyword">if</span> (freelist)</span><br><span class="line">		<span class="keyword">goto</span> check_new_slab;</span><br><span class="line"></span><br><span class="line">	slub_put_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">	slab = new_slab(s, gfpflags, node);</span><br><span class="line">	c = slub_get_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!slab)) &#123;</span><br><span class="line">		slab_out_of_memory(s, gfpflags, node);<span class="comment">//调用buddy system，分配slab</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * No other reference to the slab yet so we can</span></span><br><span class="line"><span class="comment">	 * muck around with it freely without cmpxchg</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	freelist = slab-&gt;freelist;</span><br><span class="line">	slab-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_SLAB);</span><br><span class="line"></span><br><span class="line">check_new_slab:</span><br><span class="line">	<span class="comment">//检查从node中获取的slab </span></span><br><span class="line">	<span class="keyword">if</span> (kmem_cache_debug(s)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!alloc_debug_processing(s, slab, freelist, addr)) &#123;</span><br><span class="line">			<span class="comment">/* Slab failed checks. Next slab needed */</span></span><br><span class="line">			<span class="keyword">goto</span> new_slab;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * For debug case, we don&#x27;t load freelist so that all</span></span><br><span class="line"><span class="comment">			 * allocations go through alloc_debug_processing()</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">goto</span> return_single;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags)))</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For !pfmemalloc_match() case we don&#x27;t load freelist so that</span></span><br><span class="line"><span class="comment">		 * we don&#x27;t make further mismatched allocations easier.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">goto</span> return_single;</span><br><span class="line"></span><br><span class="line">retry_load_slab:</span><br><span class="line"></span><br><span class="line">	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(c-&gt;slab)) &#123;</span><br><span class="line">		<span class="type">void</span> *flush_freelist = c-&gt;freelist;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">flush_slab</span> =</span> c-&gt;slab;</span><br><span class="line"></span><br><span class="line">		c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">		c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">		c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line"></span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">		deactivate_slab(s, flush_slab, flush_freelist);</span><br><span class="line"></span><br><span class="line">		stat(s, CPUSLAB_FLUSH);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> retry_load_slab;</span><br><span class="line">	&#125;</span><br><span class="line">	c-&gt;slab = slab;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> load_freelist;</span><br><span class="line"></span><br><span class="line">return_single:</span><br><span class="line"></span><br><span class="line">	deactivate_slab(s, slab, get_freepointer(s, freelist));</span><br><span class="line">	<span class="keyword">return</span> freelist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>deactivate_slab()主要是将slab放回node,解冻该slab,并根据情况判断是否直接释放该slab放回buddy system</p>
<h2 id="释放object"><a href="#释放object" class="headerlink" title="释放object"></a>释放object</h2><p>接口为kmem_cache_free 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *x)</span></span><br><span class="line">&#123;</span><br><span class="line">	s = cache_from_obj(s, x);</span><br><span class="line">	<span class="keyword">if</span> (!s)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	trace_kmem_cache_free(_RET_IP_, x, s-&gt;name);</span><br><span class="line">	slab_free(s, virt_to_slab(x), x, <span class="literal">NULL</span>, <span class="number">1</span>, _RET_IP_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是kree的话</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="type">void</span> *object = (<span class="type">void</span> *)x;</span><br><span class="line"></span><br><span class="line">	trace_kfree(_RET_IP_, x);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(x)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	folio = virt_to_folio(x);<span class="comment">//通过虚拟地址找到对应的物理页的folio</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    folio 只是封装了 struct page 的一个容器，确保这个 page 不会是一个 tail page。因此，它可以用来以 single page 或更大的 page 为单位来指代内存区域。</span></span><br><span class="line"><span class="comment">     * page_folio - Converts from page to folio.</span></span><br><span class="line"><span class="comment"> * @p: The page.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Every page is part of a folio.  This function cannot be called on a</span></span><br><span class="line"><span class="comment"> * NULL pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Context: No reference, nor lock is required on @page.  If the caller</span></span><br><span class="line"><span class="comment"> * does not hold a reference, this call may race with a folio split, so</span></span><br><span class="line"><span class="comment"> * it should re-check the folio still contains this page after gaining</span></span><br><span class="line"><span class="comment"> * a reference on the folio.</span></span><br><span class="line"><span class="comment"> * Return: The folio which contains this page.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!folio_test_slab(folio))) &#123;</span><br><span class="line">		free_large_kmalloc(folio, object);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	slab = folio_slab(folio);</span><br><span class="line">	slab_free(slab-&gt;slab_cache, slab, object, <span class="literal">NULL</span>, <span class="number">1</span>, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kfree);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>slab_free 封装了do_slab_free</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要释放的object就是参数 void * head</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">slab_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab,</span></span><br><span class="line"><span class="params">				      <span class="type">void</span> *head, <span class="type">void</span> *tail, <span class="type">int</span> cnt,</span></span><br><span class="line"><span class="params">				      <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * With KASAN enabled slab_free_freelist_hook modifies the freelist</span></span><br><span class="line"><span class="comment">	 * to remove objects, whose reuse must be delayed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (slab_free_freelist_hook(s, &amp;head, &amp;tail, &amp;cnt))</span><br><span class="line">		do_slab_free(s, slab, head, tail, cnt, addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do_slab_free (快速路径)</p>
<p>从这里就可以看出slab分配是 LIFO的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 带强制内联的快速路径可生成 kfree 和 kmem_cache_free，无需额外的函数调用即可执行快速路径释放。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 仅当我们释放到该处理器的当前 cpu slab 时，fastpath 才有可能。 如果我们之前刚刚分配了项目，通常就是这种情况。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 如果无法使用快速路径，则退回到 __slab_free，我们将在其中处理各种特殊处理。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  通过指定 head 和 tail ptr，加上对象计数 (cnt)，可以批量释放具有多个对象（全部指向同一个 slab）的自由列表。 设置尾指针指示的批量释放。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">do_slab_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> slab *slab, <span class="type">void</span> *head, <span class="type">void</span> *tail,</span></span><br><span class="line"><span class="params">				<span class="type">int</span> cnt, <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *tail_obj = tail ? : head; <span class="comment">//object 为 head， 前面slab_free传入的tail为null，那么tail_obj记录的就是待插入的object</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* memcg_slab_free_hook() is already called for bulk free. */</span></span><br><span class="line">	<span class="keyword">if</span> (!tail)<span class="comment">//</span></span><br><span class="line">		memcg_slab_free_hook(s, &amp;head, <span class="number">1</span>);</span><br><span class="line">redo:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 确定当前每个 cpu slab 的 cpus。</span></span><br><span class="line"><span class="comment">* cpu 之后可能会发生变化。 然而，这并不重要，因为数据是通过该指针检索的。 如果我们在 cmpxchg 期间在同一个 cpu 上，那么 free 将会成功。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	c = raw_cpu_ptr(s-&gt;cpu_slab);<span class="comment">//获取当前cpu_cache</span></span><br><span class="line">	tid = READ_ONCE(c-&gt;tid);<span class="comment">//获取tid</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Same with comment on barrier() in slab_alloc_node() */</span></span><br><span class="line">	barrier();<span class="comment">//内存屏障 用于保证顺序性</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(slab == c-&gt;slab)) &#123;<span class="comment">//当前释放的slab就是cpu_cache-&gt;slab</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_PREEMPT_RT</span></span><br><span class="line">		<span class="type">void</span> **freelist = READ_ONCE(c-&gt;freelist);<span class="comment">//read once </span></span><br><span class="line">        <span class="comment">// 也就是读取了 *(cpu_cache-&gt;freelist)</span></span><br><span class="line"></span><br><span class="line">		set_freepointer(s, tail_obj, freelist);<span class="comment">//将释放的object的指针指向freelist </span></span><br><span class="line">		<span class="comment">// freelist指向当前待释放的object</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(</span><br><span class="line">				s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,</span><br><span class="line">				freelist, tid,</span><br><span class="line">				head, next_tid(tid)))) &#123;</span><br><span class="line"></span><br><span class="line">			note_cmpxchg_failure(<span class="string">&quot;slab_free&quot;</span>, s, tid);</span><br><span class="line">			<span class="keyword">goto</span> redo;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* CONFIG_PREEMPT_RT */</span></span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 我们不能在 PREEMPT_RT 上使用无锁快速路径，因为如果慢速路径已经采用了 local_lock_irqsave()，那么在 irq 处理程序中它不会受到快速路径操作的保护。 所以我们需要取local_lock。 我们不应该简单地遵从 __slab_free() 因为它根本不会使用 cpu freelist。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">void</span> **freelist;</span><br><span class="line"></span><br><span class="line">		local_lock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line">		c = this_cpu_ptr(s-&gt;cpu_slab);<span class="comment">//获取当前cpu_cache</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) &#123;</span><br><span class="line">			local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line">			<span class="keyword">goto</span> redo;</span><br><span class="line">		&#125;</span><br><span class="line">		tid = c-&gt;tid;</span><br><span class="line">		freelist = c-&gt;freelist;<span class="comment">//cpu_cache-&gt;freelist</span></span><br><span class="line"></span><br><span class="line">		set_freepointer(s, tail_obj, freelist);<span class="comment">//将释放的object的尾指针指向freelist </span></span><br><span class="line">		c-&gt;freelist = head;<span class="comment">//设置freelist为当前objec</span></span><br><span class="line">		c-&gt;tid = next_tid(tid);</span><br><span class="line"></span><br><span class="line">		local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		stat(s, FREE_FASTPATH);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//不是本cpu_cache的 ,进入慢分配</span></span><br><span class="line">		__slab_free(s, slab, head, tail_obj, cnt, addr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>__slab_free (慢分配函数)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line"> * Slow path handling. This may still be called frequently since objects</span><br><span class="line"> * have a longer lifetime than the cpu slabs in most processing loads.</span><br><span class="line"> *</span><br><span class="line"> * So we still attempt to reduce cache line usage. Just take the slab</span><br><span class="line"> * lock and <span class="built_in">free</span> the item. If there is no additional partial slab</span><br><span class="line"> * handling required then we can <span class="keyword">return</span> immediately.</span><br><span class="line"> */</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __slab_free(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab,</span><br><span class="line">			<span class="type">void</span> *head, <span class="type">void</span> *tail, <span class="type">int</span> cnt,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> addr)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *prior;</span><br><span class="line">	<span class="type">int</span> was_frozen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	stat(s, FREE_SLOWPATH);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kfence_free(head))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kmem_cache_debug(s) &amp;&amp;</span><br><span class="line">	    !free_debug_processing(s, slab, head, tail, cnt, addr))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(n)) &#123;</span><br><span class="line">			spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">			n = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		prior = slab-&gt;freelist;</span><br><span class="line">		counters = slab-&gt;counters;</span><br><span class="line">		set_freepointer(s, tail, prior);</span><br><span class="line">		new.counters = counters;</span><br><span class="line">		was_frozen = new.frozen;</span><br><span class="line">		new.inuse -= cnt;</span><br><span class="line">		<span class="keyword">if</span> ((!new.inuse || !prior) &amp;&amp; !was_frozen) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Slab was on no list before and will be</span></span><br><span class="line"><span class="comment">				 * partially empty</span></span><br><span class="line"><span class="comment">				 * We can defer the list move and instead</span></span><br><span class="line"><span class="comment">				 * freeze it.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				new.frozen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">/* Needs to be taken off a list */</span></span><br><span class="line"></span><br><span class="line">				n = get_node(s, slab_nid(slab));</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Speculatively acquire the list_lock.</span></span><br><span class="line"><span class="comment">				 * If the cmpxchg does not succeed then we may</span></span><br><span class="line"><span class="comment">				 * drop the list_lock without any processing.</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 * Otherwise the list_lock will synchronize with</span></span><br><span class="line"><span class="comment">				 * other processors updating the list of slabs.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (!cmpxchg_double_slab(s, slab,</span><br><span class="line">		prior, counters,</span><br><span class="line">		head, new.counters,</span><br><span class="line">		<span class="string">&quot;__slab_free&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(!n)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(was_frozen)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * The list lock was not taken therefore no list</span></span><br><span class="line"><span class="comment">			 * activity can be necessary.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			stat(s, FREE_FROZEN);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (new.frozen) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we just froze the slab then put it onto the</span></span><br><span class="line"><span class="comment">			 * per cpu partial list.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			put_cpu_partial(s, slab, <span class="number">1</span>);</span><br><span class="line">			stat(s, CPU_PARTIAL_FREE);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))</span><br><span class="line">		<span class="keyword">goto</span> slab_empty;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Objects left in the slab. If it was not on the partial list before</span></span><br><span class="line"><span class="comment">	 * then add it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) &#123;</span><br><span class="line">		remove_full(s, n, slab);</span><br><span class="line">		add_partial(n, slab, DEACTIVATE_TO_TAIL);</span><br><span class="line">		stat(s, FREE_ADD_PARTIAL);</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">slab_empty:</span><br><span class="line">	<span class="keyword">if</span> (prior) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Slab on the partial list.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		remove_partial(n, slab);</span><br><span class="line">		stat(s, FREE_REMOVE_PARTIAL);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Slab must be on the full list */</span></span><br><span class="line">		remove_full(s, n, slab);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">	stat(s, FREE_SLAB);</span><br><span class="line">	discard_slab(s, slab);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/490588193">https://zhuanlan.zhihu.com/p/490588193</a></p>
<p><a target="_blank" rel="noopener" href="https://evilpan.com/2020/03/21/linux-slab/">https://evilpan.com/2020/03/21/linux-slab/</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1622988">https://cloud.tencent.com/developer/article/1622988</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269149.htm#msg_header_h3_18">https://bbs.pediy.com/thread-269149.htm#msg_header_h3_18</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tolimit/p/4654109.html">https://www.cnblogs.com/tolimit/p/4654109.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lukuen/article/details/6935068?spm=1001.2014.3001.5506">https://blog.csdn.net/lukuen/article/details/6935068?spm=1001.2014.3001.5506</a></p>
<p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/412757.html">https://www.51cto.com/article/412757.html</a></p>
<p><a target="_blank" rel="noopener" href="http://www.wowotech.net/memory_management/426.html">http://www.wowotech.net/memory_management/426.html</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sky-heaven/p/16527927.html">https://www.cnblogs.com/sky-heaven/p/16527927.html</a> kfence相关</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>7r1p13J</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"># 内存管理</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/11/28/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">AFL-fuzz源码阅读</a>
            
            
            <a class="next" rel="next" href="/2022/11/22/CVE-2020-8835/">CVE-2020-8835 ebpf漏洞复现与分析</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 7r1p13J | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>