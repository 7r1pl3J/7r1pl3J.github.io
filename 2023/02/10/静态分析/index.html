<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="7r1p13J">





<title>《软件分析》课程笔记 | Hexo</title>



    <link rel="icon" href="/github-11-48.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">7r1pl3J&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">7r1pl3J&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/link">Links</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">《软件分析》课程笔记</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">7r1p13J</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">February 10, 2023&nbsp;&nbsp;18:35:09</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/fuzz/">fuzz</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>不存在完美的analysis</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131194451766.png" alt="image-20230131194451766"></p>
<p>定义有用的静态分析：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131194541697.png" alt="image-20230131194541697"></p>
<p>sound &#x2F; complete ，与漏报&#x2F; 误报有关，也会和后面讲到的 may &#x2F;must analysis 相关，大部分静态分析都是妥协sound的，也就是存在误报</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131194704959.png" alt="image-20230131194704959"></p>
<p>原因：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131194843905.png" alt="image-20230131194843905"></p>
<h1 id="IR"><a href="#IR" class="headerlink" title="IR"></a>IR</h1><h3 id="编译器与静态分析："><a href="#编译器与静态分析：" class="headerlink" title="编译器与静态分析："></a>编译器与静态分析：</h3><p>静态分析是在IR层面上分析的（3AC &#x2F;  SSA 等）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131194941223.png" alt="image-20230131194941223"></p>
<p><strong>为什么不在AST 语法树层面分析</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131195038997.png" alt="image-20230131195038997"></p>
<ol>
<li>语言无关更好，不同语言的AST可能完全不同</li>
<li>更接近底层机器码，适合优化</li>
<li>更直观 ，可以看出CFG</li>
<li>IR通常作为静态分析的基础</li>
</ol>
<p>然后有一大段关于java的一点点入门分析  主要是Soot相关，看视频了解一下即可 ，略过。</p>
<h3 id="3AC与SSA"><a href="#3AC与SSA" class="headerlink" title="3AC与SSA"></a>3AC与SSA</h3><p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131195519383.png" alt="image-20230131195519383"></p>
<p>SSA不是我们关注的重点</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131195554793.png" alt="image-20230131195554793"></p>
<h3 id="如何构建BB"><a href="#如何构建BB" class="headerlink" title="如何构建BB"></a>如何构建BB</h3><p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131195646961.png" alt="image-20230131195646961"></p>
<p>主要就是确定入口</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131195855738.png" alt="image-20230131195855738"></p>
<ul>
<li>第一条指令是入口；</li>
<li>任何跳转指令的目标地址是入口；</li>
<li>任何跟在跳转指令之后的指令是入口。</li>
</ul>
<p>非常好理解</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131195748744.png" alt="image-20230131195748744"></p>
<h3 id="如何构建CFG"><a href="#如何构建CFG" class="headerlink" title="如何构建CFG"></a>如何构建CFG</h3><p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131200203867.png" alt="image-20230131200203867"></p>
<p>主要就是三种：</p>
<ul>
<li>goto 直接跳转</li>
<li>条件跳转有两个出口</li>
<li>A,B相邻，且A结尾不是无条件跳转 （这时候B可能是别的语句的跳转目标啥的 ， A -&gt; B 直接连就行）</li>
</ul>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131200050452.png" alt="image-20230131200050452"></p>
<p>这里的一些概念： 边 Edges， 前驱 predecessor ， 后继successor</p>
<p>还要给程序加上出入口，静态分析才能运行（类似状态机有个初始状态？）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131200601177.png" alt="image-20230131200601177"></p>
<h1 id="Dataflow-Analysis"><a href="#Dataflow-Analysis" class="headerlink" title="Dataflow Analysis"></a>Dataflow Analysis</h1><p>数据流分析</p>
<p>定义：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131193705207.png" alt="image-20230131193705207"></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131193716730.png" alt="image-20230131193716730"></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131181139712.png" alt="image-20230131181139712"></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131181344349.png" alt="image-20230131181344349"></p>
<p>本质上是一种求解（？跟不动点有关）</p>
<p>主要就是处理 CFG（基本块之间），transfer function （基本块内）</p>
<p>一些基本的符号表示：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131181437410.png" alt="image-20230131181437410"></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131181520046.png" alt="image-20230131181520046"></p>
<h3 id="reaching-definitions-analysis"><a href="#reaching-definitions-analysis" class="headerlink" title="reaching definitions analysis"></a>reaching definitions analysis</h3><p><strong>定义：</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131181631031.png" alt="image-20230131181631031"></p>
<p>给变量v一个定义d（赋值），存在一条路径使得程序点p能够到达q，且在这个过程中不能改变v的赋值。</p>
<p>应用： 可以用于检测未定义变量</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131181846562.png" alt="image-20230131181846562"></p>
<p>关注对象为所有被定义的变量，使用bitmaps 抽象每一个变量 </p>
<p><strong>CFG分析：</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131182013209.png" alt="image-20230131182013209"></p>
<p>kill掉的是所有其他定义v的定义语句（也就是kill掉redefine）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131193249894.png" alt="image-20230131193249894"></p>
<p><strong>算法：</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131193359984.png" alt="image-20230131193359984"></p>
<p><strong>示例：</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131193634984.png" alt="image-20230131193634984"></p>
<blockquote>
<p>问题： 这个算法会停止吗？</p>
<p>OUT[B] &#x3D; genB U (IN[B] - killB)</p>
<p>我理解为对这个集合求解 ，解出来的集合是有上&#x2F;下界的 （全是0 &#x2F; 1），而for循环内对out的计算又是单调的（不严格），out[b]至少是不会减少的，所以一定会有上界，算法一定会停止。</p>
</blockquote>
<h3 id="line-variables-analysis"><a href="#line-variables-analysis" class="headerlink" title="line variables analysis"></a>line variables analysis</h3><p><strong>定义</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131162154540.png" alt="image-20230131162154540"></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131162244891.png" alt="image-20230131162244891"></p>
<p>简单来说就是分析路径中的变量值是否还存活，如上图所示，只要从p开始的某条路径中用到了变量v，则v在p处live。（变量v也不应该被重定义）</p>
<p>从定义就可以看出，这是一个<strong>may analysis</strong> ，因为是存在某条路径</p>
<p><strong>运用场景</strong>： 编译优化 ，如变量替换寄存器时，选择一个dead的变量进行覆盖</p>
<p>运用<strong>backward analysis</strong> ：这样更直观，只要从后面开始逆推的话就可以直接知道前面是否live了，如果使用forward，有可能得等到最后才能判断出一个变量是live的，此时又需要倒回去更新状态。</p>
<p><strong>CFG分析：</strong></p>
<p>由于是backward analysis ，故我们需要得出从out 到 in的表达式</p>
<p>通过六种语句分析：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131164345644.png" alt="image-20230131164345644"></p>
<p>情况4中，v是先被use 再 redefine的 ，本质上和情况6类似</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131164005607.png" alt="image-20230131164005607"></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131164020034.png" alt="image-20230131164020034"></p>
<p>这里课件打错了，out[B] 后面那个应该是 IN【S】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OUT[B] = US a_successor_of_BIN[S]</span><br></pre></td></tr></table></figure>

<p>被kill掉的情况其实就是 redefine （3，4，5，6） ，但要考虑 4 ，6 的情况 （在redefine之前被use） ，才得出这样的表达式，所以需要 注意 这里的use b并不是块中被use的所有变量，。</p>
<p><strong>算法</strong>：</p>
<p>与Reaching Definitions Analysis 相似，区别基本就是换成了backwards </p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131165133659.png" alt="image-20230131165133659"></p>
<p><strong>示例</strong>：</p>
<p>三次迭代以后， IN 不再改变</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131170308058.png" alt="image-20230131170308058"></p>
<h3 id="available-expressions-analysis"><a href="#available-expressions-analysis" class="headerlink" title="available expressions analysis"></a>available expressions analysis</h3><p><strong>定义</strong>：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131170949362.png" alt="image-20230131170949362"></p>
<p>从定义可以看出这是个 <strong>must analysis</strong>， 需要全部路径都满足。</p>
<p>有点类似于表达式是否可以reach？ 不是很直观，可以看一个available的例子：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131171937725.png" alt="image-20230131171937725"></p>
<p>在此基础上我们可以做一些优化，比如说合并临时变量：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131172110514.png" alt="image-20230131172110514"></p>
<p>在这个例子中 ，我们不需要考虑中间的path，直接计算t的最后一次expressions即可得到t的值</p>
<p>与前面对象为变量不同，分析对象为全部表达式</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131171055746.png" alt="image-20230131171055746"></p>
<p><strong>CFG分析：</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131172412691.png" alt="image-20230131172412691"></p>
<p>genB为块B中所有的新表达式，kill去变量被redefine的表达式</p>
<p>IN[B] 取交集，也就是满足 all path</p>
<p>我们需要safe- approximation，就算我们有漏报（本应是available 报为unavailable ），也算是safe的，最需要保证的是不要优化错了（误报），也就是must analysis -&gt; under-approximation</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131172531536.png" alt="image-20230131172531536"></p>
<p><strong>算法：</strong></p>
<p> <img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131173128518.png" alt="image-20230131173128518"></p>
<p>计算的时候 先计算kill B，在计算gen B，可以解决表达式中一个变量被重新赋值，但该表达式又被再次使用的情况，或者直接按statement的顺序一句句计算也行。</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131174109015.png" alt="image-20230131174109015"></p>
<p><strong>示例：</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131174320863.png" alt="image-20230131174320863"></p>
<h2 id="comparison"><a href="#comparison" class="headerlink" title="comparison"></a>comparison</h2><p>Boundary与 Direction 有关，forward的话就是entry，backwards的话就是exit</p>
<p>Initialization 初始化值与may&#x2F;must 有关， 对象与Direction有关（参考Bondary），may常常初始化为空集，must常常初始化为全集。</p>
<p>must 通常为  ∩ ，也就是汇聚，may通常为  U，这里我也不是特别理解（我就简单理解为，may是某条路径的话自然取交集，must同理自然取并集 ），老师也没讲理论还</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131174953152.png" alt="image-20230131174953152"></p>
<h2 id="Foundation"><a href="#Foundation" class="headerlink" title="Foundation"></a>Foundation</h2><p>这里涉及到很多集合论相关的，我只在离散数学中接触过一些</p>
<h3 id="函数和集合"><a href="#函数和集合" class="headerlink" title="函数和集合"></a>函数和集合</h3><p>V k 代表一个 k个节点的CFG的 OUT的集合</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131211842501.png" alt="image-20230131211842501"></p>
<p>函数可以看成集合到集合的一次迭代 </p>
<p>非常直观的解释，引入<strong>不动点</strong>，我们前面的dataflow analysis，本质上也是找到函数的不动点</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131212244443.png" alt="image-20230131212244443"></p>
<blockquote>
<p>问题：</p>
<ol>
<li>算法一定能找到不动点吗，该函数一定有解吗？  涉及单调性</li>
<li>如果存在解，那有多少个解（不动点）？</li>
<li>我们的算法需要多少次迭代才能找到不动点？</li>
</ol>
</blockquote>
<h3 id="偏序集"><a href="#偏序集" class="headerlink" title="偏序集"></a>偏序集</h3><p>离散数学学过一些，简单截个图</p>
<p>主要就是讲 偏序关系 的 自反性，对称性，以及传递性，</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131213117383.png" alt="image-20230131213117383"></p>
<p><strong>偏序关系不要求任意两个元素都满足偏序关系</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131213308108.png" alt="image-20230131213308108"></p>
<h3 id="上下界-最小上界-最大下界"><a href="#上下界-最小上界-最大下界" class="headerlink" title="上下界 最小上界 最大下界"></a>上下界 最小上界 最大下界</h3><p>主要认认符号</p>
<p>需要注意的是 <strong>子集的上下界并不一定属于该子集</strong> ，注意看上下界的定义就是了。</p>
<p><strong>最小上界（lub &#x2F; join ）</strong></p>
<p><strong>最大下界 （glb &#x2F; meet）</strong> </p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131213943200.png" alt="image-20230131213943200"></p>
<p><strong>清晰的例子：</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/6349402-6c47df50882c3168.png" alt="img"></p>
<p><strong>性质：</strong></p>
<ul>
<li>不是所有偏序集合都有 最小上界  &#x2F; 最大下界</li>
<li>如果存在 最小上界 &#x2F; 最大下界 ，那它一定是唯一的</li>
</ul>
<blockquote>
<p>证明很简单，离散上也讲过，这里给出反证法</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131214226863.png" alt="image-20230131214226863"></p>
</blockquote>
<h3 id="格（-lattice）-x2F-半格-x2F-全格-x2F-格点积"><a href="#格（-lattice）-x2F-半格-x2F-全格-x2F-格点积" class="headerlink" title="格（ lattice）&#x2F; 半格 &#x2F; 全格 &#x2F; 格点积"></a>格（ lattice）&#x2F; 半格 &#x2F; 全格 &#x2F; 格点积</h3><p>格：偏序集中的<strong>任意两个元素</strong>构成的集合均<strong>存在最小上界和最大下界</strong></p>
<p>半格： 偏序集中的<strong>任意两个元素</strong>构成的集合均仅最小上界<strong>或</strong>最大下界存在</p>
<p>全格： 偏序集中的<strong>任意若干元素</strong>构成的集合均<strong>存在最小上界和最大下界</strong>  （全格的任意子集都满足格）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131214640372.png" alt="image-20230131214640372"></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131215502252.png" alt="image-20230131215502252"></p>
<p>complete lattice为我们主要关注的，我们静态分析的对象一般是<strong>有穷</strong>的全格</p>
<p>还有就是记住<strong>top</strong> 和 <strong>bottom</strong></p>
<p>Product Lattice(<em>格点积</em>)</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131220003434.png" alt="image-20230131220003434"></p>
<p>上面的 ✖ 是笛卡尔积</p>
<ul>
<li>格点积是格</li>
<li>若构成格点积的格是全格，则 格点积也是全格</li>
</ul>
<h3 id="通过-格-表示-Data-Flow-Analysis-Framework-（D-L-F）"><a href="#通过-格-表示-Data-Flow-Analysis-Framework-（D-L-F）" class="headerlink" title="通过 格 表示 Data Flow Analysis Framework （D,L,F）"></a>通过 格 表示 Data Flow Analysis Framework （D,L,F）</h3><ul>
<li>D代表CFG方向，forward&#x2F;backwards</li>
<li>L代表格 ，值域为V ，join  <strong>或</strong> meet 操作（偏序关系） （CFG 块间操作）</li>
<li>F代表transfer functions，集合V-&gt;V 的迭代 （块内操作）</li>
</ul>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131220946231.png" alt="image-20230131220946231"></p>
<p>那么Data flow就可以看成是通过 对格进行 join&#x2F;meet 以及 F 操作</p>
<h3 id="不动点定理"><a href="#不动点定理" class="headerlink" title="不动点定理"></a>不动点定理</h3><p>单调有穷的格 ，对 <strong>top &#x2F; bottom</strong> 迭代可以得到<strong>最大不动点</strong>&#x2F; <strong>最小不动点</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131221842738.png" alt="image-20230131221842738"></p>
<p><strong>证明：</strong></p>
<ul>
<li><p>证明存在不动点 存在</p>
<p>以bottom为例</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131222413086.png" alt="image-20230131222413086"></p>
<p>有点像鸽笼原理，L的值域优先，假设有k个元素，在k+1 次迭代中 必然会存在两个相同的值</p>
<p>不过这里用鸽笼原理，是k 和 k+1 就说不通了，应该结合了单调性 ，比较trick</p>
</li>
<li><p>证明最大&#x2F;最小不动点</p>
<p>假设了有别的不动点，证明我们求出的不动点一定小于等于别的不动点</p>
</li>
</ul>
<p>​			此处用了数学归纳法 </p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230131223525041.png" alt="image-20230131223525041"></p>
<p>​     证明唯一：</p>
<p>​     参考最小上界&#x2F;最大下界 唯一的证明，基本类似。（利用反对称性）</p>
<p>add &#x2F;edit stuck </p>
<h3 id="迭代算法不动点证明"><a href="#迭代算法不动点证明" class="headerlink" title="迭代算法不动点证明"></a>迭代算法不动点证明</h3><p>首先需要证明我们的迭代算法对象是 一个 <strong>单调</strong> ，<strong>有穷</strong> 的 <strong>全格</strong></p>
<p><strong>全格证明：</strong></p>
<p>通过product lattice 证明 ，每个BB的值域相当于一个lattice，每次迭代k个BB的值域就是k-tuple，k-tuple 可以看成是lattice 积，根据格点积性质即可证明为全格。</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230201200602434.png" alt="image-20230201200602434"></p>
<p><strong>有穷证明：</strong></p>
<p>我们的集合是有限的（不然我们求个无穷解干嘛），值域就是 0 &#x2F; 1 ，所以lattice有穷</p>
<p><strong>单调证明</strong>：</p>
<p>首先，Gen &#x2F; Kill 表达式 是单调的（不严格），这在前面的3个analysis例子就可以直观看出来了</p>
<p>现在主要证明 二元操作符是单调的 ，二元操作符就是我们块间操作时的meet&#x2F;join </p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230201201244061.png" alt="image-20230201201244061"></p>
<p>用上下界和偏序集的性质证明：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230201201631949.png" alt="image-20230201201631949"></p>
<p> 现在回到前面的第三个问题：</p>
<h4 id="什么时候会达到不动点"><a href="#什么时候会达到不动点" class="headerlink" title="什么时候会达到不动点"></a>什么时候会达到不动点</h4><p>lattice高度定义：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230201202152592.png" alt="image-20230201202152592"></p>
<p>考虑最坏的情况，每次只有一位变成 0&#x2F; 1 ，那每次都会走h步，走k次，那就是h*k</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230201202606120.png" alt="image-20230201202606120"></p>
<p>三个问题基本解决：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230201202636501.png" alt="image-20230201202636501"></p>
<h3 id="may-x2F-must-analysis分析"><a href="#may-x2F-must-analysis分析" class="headerlink" title="may&#x2F;must analysis分析"></a>may&#x2F;must analysis分析</h3><p>我们把整个BB构成的CFG看成一个product lattice ，这样可以就是对一个lattice</p>
<p>无论是may&#x2F;must analysis ，都是从<strong>unsafe-&gt;safe</strong> 走，且是<strong>单调</strong>的</p>
<p>以<strong>reaching definition</strong>来看 <strong>may analysis</strong></p>
<p>从unsafe result出发 ，初值为<strong>bottom</strong>（没有define可以reach） ，直到第一个不动点（<strong>最小不动点</strong>），得到一个safe result，这是一个best的不动点，因为越靠近Safe 越没用（比如说直接假设所有变量都有可能reaching，虽然safe，但是没几把用）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230201204340250.png" alt="image-20230201204340250"></p>
<p>以 <strong>available expression</strong> 来看 <strong>must analysis</strong></p>
<p>需要从unsafe的结果出发，初值为 <strong>top</strong>（所有expression都available，可以被优化），最终会走到<strong>最大不动点</strong>，这也是一个best的结果。</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230201204943274.png" alt="image-20230201204943274"></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230201204955521.png" alt="image-20230201204955521"></p>
<p>这样就解决了我们前面第二个问题，求出的不动点为什么是best result</p>
<blockquote>
<p>另一个角度：</p>
<p>may analysis时使用union ∪，而must analysis使用 ∩</p>
</blockquote>
<h3 id="衡量精度-MOP"><a href="#衡量精度-MOP" class="headerlink" title="衡量精度 MOP"></a>衡量精度 MOP</h3><p>MOP（Meet-Over-All-Paths Solution）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230201210641469.png" alt="image-20230201210641469"></p>
<p>有循环的话很容易路径爆炸</p>
<h3 id="迭代算法-VS-MOP"><a href="#迭代算法-VS-MOP" class="headerlink" title="迭代算法 VS MOP"></a><strong>迭代算法 VS MOP</strong></h3><p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230201211008885.png" alt="image-20230201211008885"></p>
<p>MOP会比我们的迭代算法更准确，证明：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230201211352298.png" alt="image-20230201211352298"></p>
<p>当然 ，这是偏序关系，如果F运算满足分配律，那他们可以是相当的</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230201211435693.png" alt="image-20230201211435693"></p>
<h3 id="constant-propagation-常量传播"><a href="#constant-propagation-常量传播" class="headerlink" title="constant propagation 常量传播"></a>constant propagation 常量传播</h3><p><del>涉及lab1，不过我可能不一定有机会来做lab?</del></p>
<p>判断p处变量x是否为常量，(x,v) 表示变量x可以由常量v代替</p>
<p><strong>D:</strong>  forwards </p>
<p><strong>L：</strong>因为要考虑所有的路径，x在所有路径值都不变才为常量，故为must分析，must的unsafe-&gt;safe,就是以所有变量都为常量出发（这样做优化就是unsafe的，相反如果认为所有都不是常量，不优化就没影响）</p>
<p>变量初始化为常量不好表示，在初始化前都是undefine，所以以undefine来初始化表示</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230204143111774.png" alt="image-20230204143111774"></p>
<p>meet&#x2F;join，我们在每个路径的汇聚处都进行meet operation，这里的meet操作为我们自定义的</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230204143031610.png" alt="image-20230204143031610"></p>
<blockquote>
<p>这里有一点就是如果有一条path是undefine，其他path都是常量v，那么我们也认为x是常量，是正确的</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230204143015711.png" alt="image-20230204143015711"></p>
</blockquote>
<p><strong>F:</strong>  val（） 为取对应变量的值</p>
<p>对于新加入的语句，主要有常量赋值，变量赋值，表达式赋值三种，分类处理</p>
<blockquote>
<p>这里有一个trick，对于y，z一个是undefine，另一个是constants的情况，y op z也算作undefine，否则的话整个f表达式就不满足monotonic了。</p>
<p>如果算作是constants，整个lattice就可能存在往回流的路径了（参考前面的图）</p>
</blockquote>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230204144307587.png" alt="image-20230204144307587"></p>
<p><strong>是否满足分配律？</strong></p>
<p>考虑相加为常量的情况，可以看出是不满足的，也就是精度不如MOP</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230204144729722.png" alt="image-20230204144729722"></p>
<h3 id="迭代算法优化-worklist"><a href="#迭代算法优化-worklist" class="headerlink" title="迭代算法优化 worklist"></a>迭代算法优化 worklist</h3><p>原算法：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230204145004303.png" alt="image-20230204145004303"></p>
<p>while循环的冗余了，我们前面已经知道，我们只需要重新计算out改变的nodes即可，不需要所有的nodes都重新计算。</p>
<p>采用队列进行存储，初始化为所有nodes</p>
<p>因为前驱的out不变的话，后继的in就不变，只有前驱的out变时，才需要把所有的后继加入worklist</p>
<p>故每次循环判断当前的nodes out是否改变即可。</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230204145532858.png" alt="image-20230204145532858"></p>
<h1 id="Interprocedural-Analysis-过程间分析-x2F-函数间分析"><a href="#Interprocedural-Analysis-过程间分析-x2F-函数间分析" class="headerlink" title="Interprocedural Analysis 过程间分析&#x2F;函数间分析"></a>Interprocedural Analysis 过程间分析&#x2F;函数间分析</h1><p><strong>原因：</strong></p>
<p>我们以往的过程内分析只考虑了过程内部的语句而忽略了过程的调用，这会导致我们分析不精确。</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230204224249942.png" alt="image-20230204224249942"></p>
<h2 id="Call-Graph"><a href="#Call-Graph" class="headerlink" title="Call Graph"></a>Call Graph</h2><p>为了实现过程间分析，我们就需要知道调用关系，绘制出程序的调用图 <strong>call graph</strong></p>
<p>简单来说就是<strong>调用点（call sites）</strong>到<strong>目标方法（target methods）</strong>的**边(edges)**的集合</p>
<p>一个简单的例子：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230204224556344.png" alt="image-20230204224556344"></p>
<p>call graph的应用</p>
<ul>
<li>理论上过程间分析（跨函数分析）的基础，</li>
<li>程序优化</li>
<li>程序理解</li>
<li>程序调试</li>
</ul>
<h2 id="面向对象的call-graph构造-（Java-为例）"><a href="#面向对象的call-graph构造-（Java-为例）" class="headerlink" title="面向对象的call graph构造 （Java 为例）"></a>面向对象的call graph构造 （Java 为例）</h2><p>我们分析第1，4个算法（CHA，k-CFA）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230204224958555.png" alt="image-20230204224958555"></p>
<p>方法调用分类，主要三种：静态调用，特殊调用，虚函数调用</p>
<p>virtual call无法在编译时决定目标函数，我们主要的关键就是处理virtual call，另外两个都只有一个目标函数，相对来说简单一些。</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230204225255635.png" alt="image-20230204225255635"></p>
<h3 id="method-dispath-of-virtual-calls"><a href="#method-dispath-of-virtual-calls" class="headerlink" title="method dispath of virtual calls"></a>method dispath of virtual calls</h3><p>virtual  call 需要运行时才能确定，主要涉及两点：</p>
<ol>
<li><p>接受对象的类型 <strong>c</strong></p>
</li>
<li><p>call site 处的函数签名 <strong>m</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205001200715.png" alt="image-20230205001200715"></p>
<p>函数签名：</p>
<p><strong>signature</strong> &#x3D; class type(类名) + method name(函数名) + descriptor（描述符）</p>
<p><strong>descriptor</strong> &#x3D; return type(返回类型) + parameter types(参数类型)</p>
<p>下图右边为soot采用的缩写</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205001520703.png" alt="image-20230205001520703"></p>
<p>我们定义dispatch 函数 模拟 virtual dispatch过程：</p>
<p>该函数用于找到类所调用的具体函数方法</p>
<p>若为<strong>抽象函数</strong>或者<strong>不存在</strong>同名函数则一直用父类调用该函数进行查找（也就是继承函数的情况），直至找到第一个满足的非抽象函数方法为</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205001806838.png" alt="image-20230205001806838"></p>
<p>以下示例分别展示了派生类赋值给基类，以及派生类覆盖基类成员函数的情况</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205002423788.png" alt="image-20230205002423788"></p>
</li>
</ol>
<h4 id="Class-Hierarchy-Analysis（CHA）类层级分析"><a href="#Class-Hierarchy-Analysis（CHA）类层级分析" class="headerlink" title="Class Hierarchy Analysis（CHA）类层级分析"></a>Class Hierarchy Analysis（CHA）类层级分析</h4><p>根据 declared type of receiver variable，也就是 <strong>receiver variable</strong> 的<strong>声明类型</strong>来找到所有可能的调用方法</p>
<p>receiver variable 可以简单理解为被赋值的那个，比如说下图的 <strong>a</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205003113278.png" alt="image-20230205003113278"></p>
<p><strong>cs 代表 call site</strong></p>
<p><strong>算法：</strong></p>
<p>求解的T为函数签名集合</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205003618037.png" alt="image-20230205003618037"></p>
<p><strong>static call：</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205003643638.png" alt="image-20230205003643638"></p>
<p><strong>special call：</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205004159470.png" alt="image-20230205004159470"></p>
<p> 三种情况：构造函数，私有方法，父类方法</p>
<p>父类方法：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205004151577.png" alt="image-20230205004151577"></p>
<p>构造方法，私有方法基本和static call一样</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205004256406.png" alt="image-20230205004256406"></p>
<p>dispatch的参数所给的类名是唯一的，返回值当然也是唯一的。</p>
<p><strong>virtual call：</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205004434524.png" alt="image-20230205004434524"></p>
<p> 对c本身，<strong>和</strong> c所有的子类以及子类的子类等（继承树上的所有子类）**c ‘**，都调用 <strong>Dispatch (c’,M)</strong>,将返回值加入T当中。</p>
<blockquote>
<p>注意dispatch的定义，只有调用dispatch才会可能去找父类，而virtual call的for循环用于找子类</p>
<p>如果继承类自己实现了函数且没有子类，那么就会对自己调用dispatch，从而找到自己的函数</p>
<p>如这种：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205014705470.png" alt="image-20230205014705470"></p>
</blockquote>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205004914646.png" alt="image-20230205004914646"></p>
<p>我这里就以基类调用派生类函数方法理解了（基类声明虚函数，<del>我java不太行，用cpp理解了</del>），需要遍历其所有继承子类才可以知道最终调用的是哪个函数方法</p>
<blockquote>
<p>题外话，通过cpp补点java基础：</p>
<p>一、Java中的虚函数<br>普通函数就是虚函数（同等于C语言中virtual关键词修饰的方法）<br>虚函数的存在是为了多态<br>C++中普通成员函数加上virtual关键字就成为虚函数<br>Java中其实没有虚函数的概念，它的普通函数就相当于C++的虚函数，动态绑定是Java的默认行为。如果Java中不希望某个函数具有虚函数特性，可以加上final关键字变成非虚函数<br>据统计Java的：静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法，除此之外都是虚方法<br>二、参考<br>C++虚函数    &#x3D;&#x3D;  Java普通函数<br>C++纯虚函数  &#x3D;&#x3D;  Java抽象函数<br>C++抽象类    &#x3D;&#x3D;  Java抽象类<br>C++虚基类    &#x3D;&#x3D;  Java接口<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/trojanpizza/article/details/6556604">https://blog.csdn.net/trojanpizza/article/details/6556604</a></p>
</blockquote>
<p><strong>示例</strong>：</p>
<p> 这里有一个比较容易漏的地方：</p>
<p>B类自身没有foo函数，故既需要向上（也就是找继承父类的函数），也需要向下（找子类实现的函数）</p>
<p>其实也就是对应了前面算法的：1.对B本身进行dispatch，返回A.foo 2. 对B的所有子类进行dispatch，返回C，D的foo</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205010708494.png" alt="image-20230205010708494"></p>
<p>此处具体为new B也是一样的，这里弹幕答错的人有点多，感觉可能是没好好看CHA定义？毕竟定义就说了只关注类的声明类型。不过这里也暴露了CHA的不足，毕竟程序运行的话是不会调用C，D的foo方法的</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205010917229.png" alt="image-20230205010917229"></p>
<p><strong>CHA特点：</strong></p>
<p>1.速度快</p>
<p>   只考虑调用点 receiver variable 的声明类型</p>
<p>   忽略数据流，控制流信息</p>
<p>2.不精确</p>
<p>   很容易引入冗余的调用方法，如上图示例</p>
<p>​    可以用别的方法避免这个缺陷</p>
<p>现代IDE找call site就有用到CHA，毕竟速度快，反应的结果也是给人看的</p>
<p>老师给了IDEA的例子：</p>
<p>与上图例子相同，使用了CHA，不够精确</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205011633487.png" alt="image-20230205011633487"></p>
<h5 id="使用CHA构造call-graph"><a href="#使用CHA构造call-graph" class="headerlink" title="使用CHA构造call graph"></a>使用CHA构造call graph</h5><p>对每个调用点应用CHA，一直重复直至没有新的方法被找到（有可能存在有些方法是不可达的<del>就跟数据结构学的构建图差不多</del>）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205011842115.png" alt="image-20230205011842115"></p>
<p>算法: 相当简单粗暴的worklist，算法思想有点类似于BFS，以<strong>所有main函数内方法为worklist，</strong>不断从worklist中取方法，然后又加入新的方法这样  </p>
<p>RM集合用于优化，可以在遇到以及处理过的函数方法时直接快速进入下一次循环 </p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205012619503.png" alt="image-20230205012619503"></p>
<p>示例：</p>
<p>跟个算法走一遍就行了，很好理解</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205015004836.png" alt="image-20230205015004836"></p>
<h3 id="Interprocedural-Control-Flow-Graph-（ICFG）"><a href="#Interprocedural-Control-Flow-Graph-（ICFG）" class="headerlink" title="Interprocedural Control-Flow Graph （ICFG）"></a>Interprocedural Control-Flow Graph （ICFG）</h3><p><strong>ICFG &#x3D; CFGs +call edges + return edges</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205135058386.png" alt="image-20230205135058386"></p>
<p>retrun site可以理解为紧跟着call site的下一句</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205135134568.png" alt="image-20230205135134568"></p>
<p>ICFG示例：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205145126556.png" alt="image-20230205145126556"></p>
<blockquote>
<p>这里有个问题就是有了调用边返回边，为什么还需要CFG的那条边</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205145207743.png"></p>
<p>解释：</p>
<p>这里只考虑值传递（不考虑引用传递），这条边可以传播本地的数据流</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205152346085.png" alt="image-20230205152346085"></p>
<p>如果没有这条边的话就会这样：</p>
<p>目标方法中会有额外的变量，这是没必要也不应该的</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205152540176.png" alt="image-20230205152540176"></p>
<p>故需要这样：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205152645812.png" alt="image-20230205152645812"></p>
</blockquote>
<h3 id="过程间数据流分析"><a href="#过程间数据流分析" class="headerlink" title="过程间数据流分析"></a>过程间数据流分析</h3><p>分析建立在整个程序基础上的ICFG，但没有标准的做法</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205151605660.png" alt="image-20230205151605660"></p>
<p>在node中数据流分析时，要去掉call site处的左值（赋值语句的左边，因为此时该值还未确定），其余与过程内分析相同</p>
<blockquote>
<p> 如果保留的话，数据流在meet join时就有可能出错：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205153234299.png" alt="image-20230205153234299"></p>
<p>这个b&#x3D;10应该能覆盖原值才对，kill掉就能避免这种精度上的损失：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205153333518.png" alt="image-20230205153333518"></p>
</blockquote>
<p>call edge则传参</p>
<p>retuen edge则传返回值</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205151940880.png" alt="image-20230205151940880"></p>
<p><strong>以常量传播为例：</strong></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205153353873.png" alt="image-20230205153353873"></p>
<p>过程内分析会做最保守的假设，十分不精确：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230205153505165.png" alt="image-20230205153505165"></p>
<h1 id="Poniter-Analysis"><a href="#Poniter-Analysis" class="headerlink" title="Poniter Analysis"></a>Poniter Analysis</h1><p><del>只能说指针分析这部分是这门课学起来最难受且有些枯燥的</del></p>
<p>为什么需要指针分析？以CHA为例，CHA只考虑了调用者的类型，在以下常量传播中会给出非常不精确的答案，若用指针分析的话就可以解决这类冗余调用边的的问题：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230209234950208.png" alt="image-20230209234950208"></p>
<h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>计算指针具体指向的内存</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230209235336576.png" alt="image-20230209235336576"></p>
<p>例子：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230209235913118.png" alt="image-20230209235913118"></p>
<h3 id="别名-Alias"><a href="#别名-Alias" class="headerlink" title="别名 Alias"></a>别名 Alias</h3><p>指针p，q指向同一个对象就称为别名</p>
<p>别名分析和指针分析相关 <del>但是不讲</del></p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210000110640.png" alt="image-20230210000110640"></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>与安全相关的，空指针分析，以及程序流分析等</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210000209262.png" alt="image-20230210000209262"></p>
<h3 id="关键要素"><a href="#关键要素" class="headerlink" title="关键要素"></a>关键要素</h3><p>对于不同的场景有不同的选择</p>
<ul>
<li>堆抽象</li>
<li>上下文敏感&#x2F;不敏感</li>
<li>流敏感&#x2F;不敏感</li>
<li>全程序分析</li>
</ul>
<p>标红的是我们将要学习的</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210003635455.png" alt="image-20230210003635455"></p>
<h4 id="heap-abstraction"><a href="#heap-abstraction" class="headerlink" title="heap abstraction"></a>heap abstraction</h4><p>对于循环&#x2F;递归产生的大量堆指针对象，抽象相似对象 合并为一个对象便于静态分析（限制处理对象的个数，保证静态分析可以终止）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210000732186.png" alt="image-20230210000732186"></p>
<p>两大流派：store based&#x2F;storeless model，以及他们的混合流派</p>
<p>我们学习store based下的allocation sites ，因为最常见，最实用&#x2F;有效（对java）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210000932106.png" alt="image-20230210000932106"></p>
<h5 id="allocation-sites-abstraction-创建点抽象"><a href="#allocation-sites-abstraction-创建点抽象" class="headerlink" title="allocation sites abstraction 创建点抽象"></a>allocation sites abstraction 创建点抽象</h5><p>意外的挺直观，（简单来说有几个new语句就会处理几个对象）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210001208583.png" alt="image-20230210001208583"></p>
<h4 id="context-sensitivity"><a href="#context-sensitivity" class="headerlink" title="context sensitivity"></a>context sensitivity</h4><p>上下文敏感：模拟动态执行，对同一方法的不同上下文调用，分开分析  （更精确，对java提升很明显）</p>
<p>上下文不敏感：汇聚在一起分析，只分析一次</p>
<p> <img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210001625846.png" alt="image-20230210001625846"></p>
<h4 id="flow-sensitivity"><a href="#flow-sensitivity" class="headerlink" title="flow sensitivity"></a>flow sensitivity</h4><p>主要考虑怎样对控制执行流进行建模 </p>
<p>我们前面学到的那些data flow 数据流分析都是流敏感的</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210002004114.png" alt="image-20230210002004114"></p>
<p>通过在程序每个位置维护一个指向图来实现流敏感，非流敏感则在整个程序中只维护一个指向关系图（不考虑控制流执行顺序）</p>
<p>流敏感&#x2F;非敏感比较：</p>
<p> <img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210003044546.png" alt="image-20230210003044546"></p>
<p><strong>对C类的语言的流敏感分析非常有效（精度提高），但目前没有研究表明对java的流敏感分析能显著提高精度</strong></p>
<h4 id="Analysis-Scope"><a href="#Analysis-Scope" class="headerlink" title="Analysis Scope"></a>Analysis Scope</h4><p>简单来说就是选择需要分析的对象，需求驱动的分析就只分析部分指针（计算量更小，但不一定会小很多），否则就是全程序都分析（主流，适应几乎所有情况）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210003623562.png" alt="image-20230210003623562"></p>
<h3 id="关注对象"><a href="#关注对象" class="headerlink" title="关注对象"></a>关注对象</h3><p>只考虑影响指针&#x2F;指针相关的</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210004057121.png" alt="image-20230210004057121"></p>
<p>以java为例：</p>
<p>对于数组的分析，我们忽略下标，将数组当成单个的指针对象来看待</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210004256627.png" alt="image-20230210004256627"></p>
<p>那么大概就是关注5类语句：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210004611735.png" alt="image-20230210004611735"></p>
<p>call就是之前call graph例子中的三种：static call，special call，<strong>virtual call</strong>(重点)</p>
<p>对于多重指针，会使用3AC简化：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210004721688.png" alt="image-20230210004721688"></p>
<h2 id="Foundation-1"><a href="#Foundation-1" class="headerlink" title="Foundation"></a>Foundation</h2><h3 id="域-x2F-符号-domains-x2F-notations"><a href="#域-x2F-符号-domains-x2F-notations" class="headerlink" title="域&#x2F;符号(domains&#x2F;notations)"></a>域&#x2F;符号(domains&#x2F;notations)</h3><p> 指针域 可以理解为 <strong>变量域 + (对象域 × 实例对象域)</strong></p>
<p>pt可以理解为映射关系（函数）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210005645786.png" alt="image-20230210005645786"></p>
<h3 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h3><p><strong>以下的rules不考虑不考虑call</strong></p>
<p>集合关系都挺好理解的，以store&#x2F;load为例子(理解这两个其他就都理解了)理解一下关系图和符号就行</p>
<p>premise为前提，conclusion为推导结论</p>
<p>store:</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210010613056.png" alt="image-20230210010613056"></p>
<p>load:</p>
<p>以store为前提的推导，结合store就很好理解</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210010915542.png" alt="image-20230210010915542"></p>
<p>总览图：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210011348657.png" alt="image-20230210011348657"></p>
<p>分析有点类似传播信息，本质上可以看作是对包含关系的约束求解</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210012739051.png" alt="image-20230210012739051"></p>
<h3 id="Pinter-Flow-Graph-PFG"><a href="#Pinter-Flow-Graph-PFG" class="headerlink" title="Pinter Flow Graph(PFG)"></a>Pinter Flow Graph(PFG)</h3><p>节点nodes即为程序中的指针，边edges代表指针对象之间的流动关系</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210013446956.png" alt="image-20230210013446956"></p>
<p>边符号表达，可以理解为信息传播：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210013625568.png" alt="image-20230210013625568"></p>
<p>示例：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210014419697.png" alt="image-20230210014419697"></p>
<p>这样算法就可以抽象为在图上指针信息的传播，但并不是单单分析PFG的的问题那么简单，因为PFG的构建也依赖于指向关系信息</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210014953276.png" alt="image-20230210014953276"></p>
<h3 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h3><p>算法总览：（不考虑call语句，只考虑4中语句）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210015223890.png" alt="image-20230210015223890"></p>
<p>worklist和前面的worklist类似，存放我们需要处理的指针信息</p>
<p>每个entry以pair的形式 <strong>&lt;指针，指向的对象&gt;</strong> 存储</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210015433670.png" alt="image-20230210015433670"></p>
<h4 id="new-amp-amp-assign"><a href="#new-amp-amp-assign" class="headerlink" title="new &amp;&amp; assign"></a>new &amp;&amp; assign</h4><p>这两种情况比较好理解，先处理所有的new作为初始化，再将assign边加入</p>
<p>这里assign addedge的处理要保证集合能包含右值（也就是**确保满足pt（y）包含于pt(x)****）,所以AddEdge最后需要有一个add worklist操作</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210015852167.png" alt="image-20230210015852167"></p>
<p> worklist处理：</p>
<p>从队列中取出一个entry，计算出 需要被增加的那部分集合（也就是要减去原有集合的部分，算出来是真正需要传播的部分，本质上就是<strong>去重</strong>），然后调用Propagate（传播）处</p>
<blockquote>
<p>为什么要去重这步操作？</p>
<p>这是从实际工程的角度考虑的，差异计算主要就是避免冗余操作（多次处理重复指针）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210021812273.png" alt="image-20230210021812273"></p>
<p>除了上面这里，在后面的foreach循环中也有优化效果</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210022114393.png" alt="image-20230210022114393"></p>
</blockquote>
<p>Propagate：</p>
<p>修改就是一个简单的并集（如果不是空集的话）</p>
<p>然后需要对被修改的指针的所有后继都进行修改（通过PFG可以查找后继，对后继进行修改也就是沿着PFG传播）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210020735405.png" alt="image-20230210020735405"></p>
<h4 id="store-amp-amp-load"><a href="#store-amp-amp-load" class="headerlink" title="store &amp;&amp; load"></a>store &amp;&amp; load</h4><blockquote>
<p>这里感觉比较模糊，我一开始比较不理解的地方就是 store&#x2F;load 为什么是对 Δ进行处理就行，pt(n) 到底是在哪里处理过了</p>
<p>事实上算法是个流不敏感算法，本质上就是先处理完new &amp;&amp; assign语句进行初始化，然后再对worklist中出现的变量一一处理：worklist中的变量存在store&#x2F;load的话就进入foreach循环，那么对于一个变量的load&#x2F;store语句，就是第一次遇见该变量时处理的，此时的Δ就是pts，pt(n)为空集 ，这样就搞清楚了。</p>
</blockquote>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210022842580.png" alt="image-20230210022842580"></p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>谭老师详细讲述了整个过程，这里跟着视频走一遍算法或者看ppt就很好理解了（第九讲）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210025101875.png" alt="image-20230210025101875"></p>
<h3 id="处理call语句"><a href="#处理call语句" class="headerlink" title="处理call语句"></a>处理call语句</h3><p>分析call语句需要建立在call graph基础之上（不然的话不知道往哪传播），而用我们之前学习的CHA来建立call graph会有冗余的信息，我们使用指针分析来计算call graph，这样比起只关注声明类型的CHA更精确</p>
<p>这与之前的PFG类似，call graph也是分析中建立的，我们称为 <strong>on-the-fly call graph construction</strong> </p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210031704098.png" alt="image-20230210031704098"></p>
<p>方法调用主要涉及:</p>
<p>1.找到目标方法（Dispatch）</p>
<p>2.传目标方法</p>
<p>3.传参</p>
<p>4.传返回值</p>
<p>Rule基本也就是做这四件事</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210033215577.png" alt="image-20230210033215577"></p>
<p>Dispatch定义与前面函数间分析基本相同，用于找到目标方法</p>
<p>在示例中就是找到T.foo()</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210033354539.png" alt="image-20230210033354539"></p>
<p>传目标方法：把x传给this（也就是pt（x）中的oi传递给pt（this））</p>
<p>传参：类似传目标方法，对每个参数执行传目标方法的操作，将实际参数的域传给形参，可以往实参-&gt;形参加一条边</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210033911284.png" alt="image-20230210033911284"></p>
<blockquote>
<p>这里容易想到一个问题，为什么对this（传目标方法时）不像传参也加一条边来传递呢 x-&gt;this</p>
<p>因为x可能会有多个对象的方法调用，而receiver object应该只流向this对应的对象，考虑示例的情况：</p>
<p>A，B，C的this分别就是new A，new B，new C</p>
<p>如果加上了边的话，x的所有对象会沿着边传入this，这样ABC的this都会指向三个对象，然而对于A的this来说，不可能流向B，C当中，对BC也同理，这样就不会乱流,传递冗余的对象了</p>
<p>我们可以通过类型等方法判断this，故我们不连边，但我们根据参数就判断不出来具体的目标形参，只采取保守的做法，直接连边</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210034658137.png" alt="image-20230210034658137"></p>
</blockquote>
<p>传返回值：pt(ret)传给接受返回值的pt(r)，加一条边</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210034025045.png" alt="image-20230210034025045"></p>
<p>总览：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210034046975.png" alt="image-20230210034046975"></p>
<p>call graph和指针分析相辅相成，都是在过程中构造出来的，这样对指针分析是有好处的，逐渐形成的call graph将会是一个可达图</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210040238213.png" alt="image-20230210040238213"></p>
<h3 id="Algorithm-（含call）"><a href="#Algorithm-（含call）" class="headerlink" title="Algorithm （含call）"></a>Algorithm （含call）</h3><p>相比没有call的情况，多了call graph集合以及可达集合</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210183944436.png" alt="image-20230210183944436"></p>
<h4 id="AddReachable"><a href="#AddReachable" class="headerlink" title="AddReachable"></a>AddReachable</h4><p>该函数用于增加可达边，有两种情况：</p>
<ol>
<li>入口方法可达，作为初始状态</li>
<li>新的call edge边被发现</li>
</ol>
<p>一个新的方法m第一次被处理时（实际上也只处理一次，毕竟第一次处理完就算reachable了），依旧是先处理其new,assign语句</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210183604455.png" alt="image-20230210183604455"></p>
<p>addedge与之前相同：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210183908493.png" alt="image-20230210183908493">  </p>
<h4 id="ProcessCall"><a href="#ProcessCall" class="headerlink" title="ProcessCall"></a>ProcessCall</h4><p>该函数实际上就是实现call 语句的Rule</p>
<p>1.找到目标方法（Dispatch）</p>
<p>2.传目标方法</p>
<p>3.传参</p>
<p>4.传返回值</p>
<p>dispatch是根据类型找类的，所以可能会发生第一次遇到的oi但是边已经处理过的情况，所以需要判断，避免冗余计算</p>
<p>建立call graph是在add 边到CG处建立的（第一次遇到该边的时候）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210190259374.png" alt="image-20230210190259374"></p>
<p>L是callsite语句，在多次调用ProcessCall的时候可能会重复分析同一条L语句，因为一个变量x的pt(x)发生变化时都会触发一次ProcessCall而L对于一个特定的x是固定不变的</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230210192516148.png" alt="image-20230210192516148"></p>
<p>这是目前为止第一个完整的全过程分析算法，输出：pt，CG</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>过程建议看视频</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230215235447557.png" alt="image-20230215235447557"></p>
<h1 id="Static-Analysis-for-Security"><a href="#Static-Analysis-for-Security" class="headerlink" title="Static Analysis for Security"></a>Static Analysis for Security</h1><p>保密性：信息泄漏，读保护</p>
<p>完整性：信息篡改（污染），写保护（防止低-&gt;高），如sql注入等</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230213011634615.png" alt="image-20230213011634615"></p>
<p>完整性需要确保准确性、完全性、一致性，即数据不被破坏，存储了所有的数据，数据的发送&#x2F;接受是一致的</p>
<h3 id="隐藏信道（Covert-x2F-Hidden-Channels）"><a href="#隐藏信道（Covert-x2F-Hidden-Channels）" class="headerlink" title="隐藏信道（Covert&#x2F;Hidden Channels）"></a>隐藏信道（Covert&#x2F;Hidden Channels）</h3><p>没有数据流也可以泄露信息，有点侧信道攻击的意思</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230213203707828.png" alt="image-20230213203707828"></p>
<p>一些能推断出secret可能是负数的隐藏信道例子：</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230213203601617.png" alt="image-20230213203601617"></p>
<h3 id="污点分析（Taint-Analysis）"><a href="#污点分析（Taint-Analysis）" class="headerlink" title="污点分析（Taint Analysis）"></a>污点分析（Taint Analysis）</h3><p>思路：将程序中的数据分为两类</p>
<p>1.污点数据，有标记&#x2F;有意义的数据（如用户输入的不可信数据，或保密的数据  ）</p>
<p>2.普通数据</p>
<p>从污点数据的源头开始分析其流向，判断它是否会流向sink（一些敏感的方法，如泄露或代码执行），本质上和指针分析十分相似</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230213204738555.png" alt="image-20230213204738555"></p>
<p>应用：分别对应完整性（如执行注入的恶意代码）和保密性（如泄露敏感信息）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230213204912724.png" alt="image-20230213204912724"></p>
<h3 id="借助指针分析来实现污点分析"><a href="#借助指针分析来实现污点分析" class="headerlink" title="借助指针分析来实现污点分析"></a>借助指针分析来实现污点分析</h3><p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230213210128658.png" alt="image-20230213210128658"></p>
<h4 id="拓展指针分析的域"><a href="#拓展指针分析的域" class="headerlink" title="拓展指针分析的域"></a>拓展指针分析的域</h4><p>多了污点数据集合</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230213210251323.png" alt="image-20230213210251323"></p>
<h4 id="输入-x2F-输出"><a href="#输入-x2F-输出" class="headerlink" title="输入&#x2F;输出"></a>输入&#x2F;输出</h4><p>输入</p>
<p>1.由于只关注污点数据，故sources只需要关注与污点数据有关的方法</p>
<p>2.关注的特定流向sinks（敏感方法集合）</p>
<p>输出:</p>
<p>污点流：污点数据以及sink方法的pair集合（<strong>污点数据</strong>流向sink方法）</p>
<h4 id="Rules-1"><a href="#Rules-1" class="headerlink" title="Rules"></a>Rules</h4><p>sink&amp;&amp;source处理</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230213212305762.png" alt="image-20230213212305762"></p>
<p>   方法处理（我们关注的是显示流）</p>
<p><img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230213211218160.png" alt="image-20230213211218160"></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>log为写日志行为，存在泄露</p>
<p>（注意这里是上下文不敏感的分析）</p>
<p> <img src="https://blogimg-1314041910.cos.ap-guangzhou.myqcloud.com/image-20230213213753252.png" alt="image-20230213213753252"></p>
<p>分析器：c++用llvm，java用soot，wala，也有一些拿datalog实现</p>
<h1 id="Datalog"><a href="#Datalog" class="headerlink" title="Datalog"></a>Datalog</h1><p>命令式语言（imperative）：常见编程语言如c类语言，java，go等</p>
<p>声明式语言（declarative）：如sql语言</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>7r1p13J</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/fuzz/"># fuzz</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/07/10/gpu/"></a>
            
            
            <a class="next" rel="next" href="/2023/02/04/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912022/">西湖论剑2022</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 7r1p13J | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>